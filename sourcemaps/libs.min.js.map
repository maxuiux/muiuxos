{"version":3,"sources":["nouislider.js","swiper-bundle.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","noUiSlider","this","PipsMode","PipsType","isValidPartialFormatter","entry","to","removeElement","el","parentElement","removeChild","isSet","value","preventDefault","e","isNumeric","a","isNaN","isFinite","addClassFor","element","className","duration","addClass","setTimeout","removeClass","limit","Math","max","min","asArray","Array","isArray","countDecimals","numStr","pieces","String","split","length","classList","test","add","remove","replace","RegExp","join","getPageOffset","doc","supportPageOffset","undefined","window","pageXOffset","isCSS1Compat","compatMode","x","documentElement","scrollLeft","body","y","pageYOffset","scrollTop","subRangeRatio","pa","pb","fromPercentage","range","startRange","getJ","arr","j","toStepping","xVal","xPct","slice","va","vb","abs","toPercentage","getStep","xSteps","snap","b","round","closest","Spectrum","singleStep","index","xNumSteps","xHighestCompleteStep","ordered","Object","keys","forEach","push","sort","handleEntryPoint","handleStepPoint","prototype","getDistance","distances","getAbsoluteDistance","direction","start_factor","xPct_index","rest_factor","rest_rel_distance","range_pct","rel_range_distance","abs_distance_counter","range_counter","fromStepping","isPercentage","getDefaultStep","isDown","size","getNearbySteps","stepBefore","startValue","step","highestStep","thisStep","stepAfter","countStepDecimals","stepDecimals","map","apply","hasNoSize","convert","percentage","parseFloat","Error","value1","Number","i","n","totalSteps","ceil","toFixed","defaultFormatter","from","cssClasses","target","base","origin","handle","handleLower","handleUpper","touchArea","horizontal","vertical","background","connect","connects","ltr","rtl","textDirectionLtr","textDirectionRtl","draggable","drag","tap","active","tooltip","pips","pipsHorizontal","pipsVertical","marker","markerHorizontal","markerVertical","markerNormal","markerLarge","markerSub","valueHorizontal","valueVertical","valueNormal","valueLarge","valueSub","INTERNAL_EVENT_NS","testStep","parsed","testKeyboardPageMultiplier","keyboardPageMultiplier","testKeyboardMultiplier","keyboardMultiplier","testKeyboardDefaultStep","keyboardDefaultStep","testRange","spectrum","testStart","handles","start","testSnap","testAnimate","animate","testAnimationDuration","animationDuration","testConnect","testOrientation","ort","testMargin","margin","testLimit","testPadding","padding","totalPadding","firstValue","testDirection","dir","testBehaviour","indexOf","fixed","hover","unconstrained","dragAll","smoothSteps","events","testTooltips","tooltips","formatter","testHandleAttributes","handleAttributes","testAriaFormat","ariaFormat","testFormat","isValidFormatter","format","testKeyboardSupport","keyboardSupport","testDocumentElement","testCssPrefix","cssPrefix","testCssClasses","key","testOptions","options","tests","r","t","orientation","behaviour","defaults","name","d","document","createElement","msPrefix","style","msTransform","noPrefix","transform","transformRule","scope","originalOptions","scope_Base","scope_Handles","scope_Connects","scope_Pips","scope_Tooltips","addTarget","actions","navigator","pointerEnabled","move","end","msPointerEnabled","supportsPassive","CSS","supports","opts","defineProperty","get","addEventListener","getSupportsPassive","scope_Target","scope_Spectrum","scope_Values","scope_Locations","scope_HandleNumbers","scope_ActiveHandlesCount","scope_Events","scope_Document","ownerDocument","scope_DocumentElement","scope_Body","scope_DirOffset","addNodeTo","div","appendChild","addOrigin","handleNumber","setAttribute","event","isSliderDisabled","isHandleDisabled","horizontalKeys","verticalKeys","largeStepKeys","edgeKeys","reverse","isLargeDown","isLargeUp","isUp","isMin","isMax","getNextStepsForHandle","setHandle","fireEvent","eventKeydown","attributes_1","attribute","addConnect","addTooltip","firstChild","hasAttribute","removeTooltips","removeEvent","bindEvent","values","unencoded","formattedValue","innerHTML","mapToRange","stepped","generateSpread","array","group","mode","Range","Steps","Count","interval","spread","Positions","Values","getGroup","indexes","firstInRange","lastInRange","ignoreFirst","ignoreLast","prevPct","filter","unshift","current","q","newPct","pctDifference","pctPos","type","steps","realSteps","stepSize","low","high","isSteps","density","LargeValue","SmallValue","NoValue","addMarking","filterFunc","_a","_b","valueSizeClasses","None","markerSizeClasses","valueOrientationClasses","markerOrientationClasses","getClasses","source","sizeClasses","offset","node","addSpread","removePips","baseSize","rect","getBoundingClientRect","alt","width","height","attachEvent","callback","data","method","pageOffset","eventTarget","touch","mouse","pointer","buttons","touches","isTouchOnTarget","checkTouch","contains","composed","composedPath","shift","targetTouches","call","pageX","pageY","targetTouch","find","changedTouches","clientX","clientY","points","cursor","fixEvent","doNotReject","calcPoint","methods","eventName","passive","calcPointToPercentage","elem","docElem","proposal","userAgent","top","clientTop","left","clientLeft","documentLeave","nodeName","relatedTarget","eventEnd","eventMove","appVersion","buttonsProperty","movement","startCalcPoint","moveHandles","locations","handleNumbers","listeners","c","removeEventListener","setZindex","eventStart","some","children","stopPropagation","moveEvent","endEvent","outEvent","concat","getComputedStyle","eventTap","clickedPosition","smallestDifference","handlePosition","differenceWithThisHandle","getClosestHandle","eventHover","targetEvent","scope_Self","namespacedEvent","namespace","substring","bind","tEvent","tNamespace","isInternalNamespace","eventType","checkHandlePosition","reference","lookBackward","lookForward","getValue","distance","inRuleOrder","v","o","upward","proposals","firstHandle","f","state","transformDirection","zIndex","exactInput","translateRule","updateConnect","updateHandlePosition","l","h","connectWidth","scaleRule","resolveToValue","valueSet","input","fireSetEvent","isInit","space_1","valueGet","location","nearbySteps","increment","decrement","connectOptions","connectBase","addElements","handleBefore","handleAfter","eventHolders","handlesToDrag","handleNumbersToDrag","eventHolder","positions","now","text","destroy","on","off","set","reset","disable","removeAttribute","enable","__moveHandles","updateOptions","optionsToUpdate","updateAble","newOptions","getPositions","getTooltips","getOrigins","initialize","api","nouislider","__spectrum","create","Swiper","isObject$1","obj","constructor","extend$1","src","ssrDocument","[object Object]","activeElement","querySelector","querySelectorAll","getElementById","createEvent","childNodes","getElementsByTagName","createElementNS","importNode","hash","host","hostname","href","pathname","protocol","search","getDocument","ssrWindow","history","CustomEvent","getPropertyValue","screen","matchMedia","requestAnimationFrame","id","clearTimeout","getWindow","win","nextTick","delay","Date","getTranslate","axis","matrix","curTransform","transformMatrix","curStyle","currentStyle","getComputedStyle$1","WebKitCSSMatrix","webkitTransform","MozTransform","OTransform","MsTransform","toString","m41","m42","isObject","isNode","HTMLElement","nodeType","extend","arguments","noExtend","nextSource","keysArray","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","__swiper__","setCSSProperty","varName","varValue","setProperty","animateCSSModeScroll","_ref","swiper","targetPosition","side","startPosition","translate","time","startTime","params","speed","wrapperEl","scrollSnapType","cancelAnimationFrame","cssModeFrameID","isOutOfBound","getTime","progress","easeProgress","cos","PI","currentPosition","scrollTo","overflow","getSlideTransformEl","slideEl","shadowRoot","elementChildren","selector","matches","tag","classes","elementOffset","box","scrollY","scrollX","elementStyle","prop","elementIndex","child","previousSibling","elementParents","parents","parent","elementTransitionEnd","fireCallBack","elementOuterSize","includeMargins","offsetWidth","support","deviceCached","browser","getSupport","smoothScroll","DocumentTouch","calcSupport","getDevice","overrides","_temp","platform","ua","device","ios","android","screenWidth","screenHeight","match","ipad","ipod","iphone","windows","macos","os","calcDevice","getBrowser","needPerspectiveFix","isSafari","toLowerCase","includes","major","minor","num","isWebView","calcBrowser","eventsEmitter","handler","priority","eventsListeners","destroyed","onceHandler","__emitterProxy","_len","args","_key","eventsAnyListeners","splice","eventHandler","context","_len2","_key2","processLazyPreloader","imageEl","isElement","slideClass","lazyEl","lazyPreloaderClass","unlazy","slides","preload","amount","lazyPreloadPrevNext","slidesPerView","slidesPerViewDynamic","activeIndex","grid","rows","activeColumn","preloadColumns","_","column","slideIndexLastInView","rewind","loop","realIndex","transitionEmit","runCallbacks","previousIndex","emit","onTouchStart","touchEventsData","evCache","enabled","simulateTouch","pointerType","animating","preventInteractionOnTransition","cssMode","loopFix","originalEvent","targetEl","touchEventsTarget","which","button","isTouched","isMoved","swipingClassHasValue","noSwipingClass","eventPath","path","noSwipingSelector","isTargetShadow","noSwiping","__closestFrom","assignedSlot","found","getRootNode","closestElement","allowClick","swipeHandler","currentX","currentY","startX","startY","edgeSwipeDetection","iOSEdgeSwipeDetection","edgeSwipeThreshold","iOSEdgeSwipeThreshold","innerWidth","assign","allowTouchCallbacks","isScrolling","startMoving","touchStartTime","updateSize","swipeDirection","threshold","allowThresholdMove","focusableElements","blur","shouldPreventDefault","allowTouchMove","touchStartPreventDefault","touchStartForcePreventDefault","isContentEditable","freeMode","onTouchMove","rtlTranslate","pointerIndex","findIndex","cachedEv","pointerId","preventedByNestedSwiper","prevX","prevY","touchReleaseOnEdges","isVertical","maxTranslate","minTranslate","diffX","diffY","sqrt","touchAngle","isHorizontal","atan2","zoom","cancelable","touchMoveStopPropagation","nested","diff","touchesDiff","previousX","previousY","oneWayMovement","touchRatio","prevTouchesDirection","touchesDirection","isLoop","startTranslate","setTransition","evt","bubbles","dispatchEvent","allowMomentumBounce","grabCursor","allowSlideNext","allowSlidePrev","setGrabCursor","loopFixed","setTranslate","currentTranslate","disableParentSwiper","resistanceRatio","centeredSlides","activeSlideIndex","resistance","followFinger","watchSlidesProgress","updateActiveIndex","updateSlidesClasses","updateProgress","onTouchEnd","slidesGrid","touchEndTime","timeDiff","pathTree","updateClickedSlide","lastClickTime","currentPos","stopIndex","groupSize","slidesSizesGrid","slidesPerGroupSkip","slidesPerGroup","rewindFirstIndex","rewindLastIndex","isBeginning","virtual","isEnd","ratio","longSwipesMs","longSwipes","slideTo","longSwipesRatio","shortSwipes","navigation","nextEl","prevEl","onResize","breakpoints","setBreakpoint","snapGrid","isVirtual","updateSlides","isVirtualLoop","slideToLoop","autoplay","running","paused","resizeTimeout","resume","watchOverflow","checkOverflow","onClick","preventClicks","preventClicksPropagation","stopImmediatePropagation","onScroll","newProgress","previousTranslate","translatesDiff","onLoad","autoHeight","update","dummyEventAttached","dummyEventListener","capture","domMethod","swiperMethod","updateOnWindowResize","isGridEnabled","init","initialSlide","resizeObserver","createElements","url","setWrapperSize","virtualTranslate","effect","breakpointsBase","spaceBetween","slidesPerGroupAuto","centeredSlidesBounds","slidesOffsetBefore","slidesOffsetAfter","normalizeSlideIndex","centerInsufficientSlides","roundLengths","uniqueNavElements","slideToClickedSlide","loopedSlides","loopPreventsSliding","passiveListeners","maxBackfaceHiddenSlides","containerModifierClass","slideActiveClass","slideVisibleClass","slideNextClass","slidePrevClass","wrapperClass","runCallbacksOnInit","_emitClasses","moduleExtendParams","allModulesParams","moduleParamName","moduleParams","auto","prototypes","clientWidth","clientHeight","parseInt","getDirectionLabel","property","margin-top","margin-bottom ","margin-left","margin-right","padding-left","padding-right","marginRight","getDirectionPropertyValue","label","slidesEl","swiperSize","wrongRTL","previousSlidesLength","slidesLength","offsetBefore","offsetAfter","previousSnapGridLength","previousSlidesGridLength","slidePosition","prevSlideSize","virtualSize","marginLeft","marginBottom","marginTop","gridEnabled","slideSize","initSlides","shouldResetSlideSize","slide","updateSlide","slideStyles","currentTransform","currentWebKitTransform","paddingLeft","paddingRight","boxSizing","floor","swiperSlideSize","updateWrapperSize","newSlidesGrid","slidesGridItem","groups","slidesBefore","slidesAfter","slideIndex","allSlidesSize","slideSizeValue","maxSnap","allSlidesOffset","snapIndex","addToSnapGrid","addToSlidesGrid","updateSlidesOffset","backFaceHiddenClass","hasClassBackfaceClassAdded","updateAutoHeight","activeSlides","newHeight","getSlideByIndex","getSlideIndexByData","visibleSlides","offsetHeight","minusOffset","offsetLeft","offsetTop","swiperSlideOffset","cssOverflowAdjustment","updateSlidesProgress","offsetCenter","visibleSlidesIndexes","slideOffset","slideProgress","originalSlideProgress","slideBefore","slideAfter","originalProgress","multiplier","progressLoop","wasBeginning","wasEnd","isBeginningRounded","isEndRounded","firstSlideIndex","lastSlideIndex","firstSlideTranslate","lastSlideTranslate","translateMax","translateAbs","getFilteredSlide","activeSlide","nextSlide","nextEls","nextElementSibling","next","elementNextAll","prevSlide","prevEls","previousElementSibling","prev","elementPrevAll","emitSlidesClasses","newActiveIndex","previousRealIndex","previousSnapIndex","getVirtualRealIndex","aIndex","getActiveIndexByTranslate","skip","getAttribute","initialized","slideFound","clickedSlide","clickedIndex","byController","translateTo","translateBounds","internal","newTranslate","isH","behavior","onTranslateToWrapperTransitionEnd","transition","transitionDuration","transitionStart","transitionEnd","initial","normalizedTranslate","normalizedGrid","normalizedGridNext","_immediateVirtual","_cssModeVirtualInitialSet","onSlideToWrapperTransitionEnd","newIndex","slideNext","perGroup","_clientLeft","slidePrev","normalize","val","normalizedSnapGrid","prevSnap","prevSnapIndex","prevIndex","lastIndex","slideReset","slideToClosest","currentSnap","slideToIndex","slideSelector","getSlideIndex","loopCreate","slideRealIndex","byMousewheel","prependSlidesIndexes","appendSlidesIndexes","isNext","isPrev","slidesPrepended","slidesAppended","swiperLoopMoveDOM","prepend","append","recalcSlides","currentSlideTranslate","controller","control","loopParams","loopDestroy","newSlidesOrder","swiperSlideIndex","moving","isLocked","__preventObserver__","unsetGrabCursor","attachEvents","detachEvents","breakpoint","getBreakpoint","currentBreakpoint","breakpointParams","originalParams","wasMultiRow","isMultiRow","wasEnabled","emitContainerClasses","fill","wasModuleEnabled","isModuleEnabled","directionChanged","needsReLoop","changeDirection","isEnabled","containerEl","currentHeight","innerHeight","point","minRatio","substr","wasLocked","lastSlideRightEdge","addClasses","classNames","suffixes","entries","prefix","resultClasses","item","prepareClasses","free-mode","autoheight","grid-column","css-mode","centered","watch-progress","removeClasses","extendedDefaults","swipers","newParams","modules","__modules__","mod","extendParams","once","swiperParams","passedParams","onAny","velocity","trunc","clickTimeout","velocities","imagesToLoad","imagesLoaded","cls","updates","getSlideClasses","view","exact","spv","breakLoop","translateValue","translated","complete","newDirection","needUpdate","currentDirection","mounted","parentNode","getWrapperSelector","trim","getWrapper","hostEl","mount","deleteInstance","cleanStyles","object","deleteProps","newDefaults","m","installModule","createElementIfNotDefined","checkProps","classesToSelector","appendSlide","appendElement","tempDOM","observer","prependSlide","prependElement","addSlide","activeIndexBuffer","baseLength","slidesBuffer","currentSlide","removeSlide","slidesIndexes","indexToRemove","removeAllSlides","effectInit","overwriteParams","perspective","recreateShadows","getEffectParams","requireUpdateOnVirtual","overwriteParamsResult","_s","slideShadows","shadowEl","effectTarget","effectParams","transformEl","backfaceVisibility","effectVirtualTransitionEnd","transformElements","allSlides","transitionEndTarget","eventTriggered","getSlide","createShadow","suffix","shadowClass","shadowContainer","prototypeGroup","protoMethod","use","animationFrame","resizeHandler","orientationChangeHandler","ResizeObserver","newWidth","_ref2","contentBoxSize","contentRect","inlineSize","blockSize","observe","unobserve","observers","attach","MutationObserver","WebkitMutationObserver","mutations","observerUpdate","attributes","childList","characterData","observeParents","observeSlideChildren","containerParents","disconnect","cssModeTimeout","cache","renderSlide","renderExternal","renderExternalUpdate","addSlidesBefore","addSlidesAfter","force","previousFrom","previousTo","previousSlidesGrid","previousOffset","offsetProp","onRendered","slidesToRender","prependIndexes","appendIndexes","loopFrom","loopTo","domSlidesAssigned","numberOfNewSlides","newCache","cachedIndex","cachedEl","cachedElIndex","kc","keyCode","charCode","pageUpDown","keyboard","isPageUp","isPageDown","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","shiftKey","altKey","ctrlKey","metaKey","onlyInViewport","inView","swiperWidth","swiperHeight","windowWidth","windowHeight","swiperOffset","swiperCoord","returnValue","timeout","mousewheel","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","noMousewheelClass","lastEventBeforeSnap","lastScrollTime","recentWheelEvents","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","delta","raw","targetElContainsTarget","rtlFactor","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","HORIZONTAL_AXIS","deltaY","deltaX","deltaMode","spinX","spinY","pixelX","pixelY","sign","ignoreWheelEvents","position","sticky","prevEvent","firstEvent","snapToThreshold","autoplayDisableOnInteraction","stop","releaseScroll","hideOnClick","disabledClass","hiddenClass","lockClass","navigationDisabledClass","makeElementsArray","getEl","res","toggleEl","disabled","subEl","tagName","onPrevClick","onNextClick","initButton","destroyButton","pagination","clickable","isHidden","toggle","pfx","bulletSize","bulletElement","renderBullet","renderProgressbar","renderFraction","renderCustom","progressbarOpposite","dynamicBullets","dynamicMainBullets","formatFractionCurrent","number","formatFractionTotal","bulletClass","bulletActiveClass","modifierClass","currentClass","totalClass","progressbarFillClass","progressbarOppositeClass","clickableClass","horizontalClass","verticalClass","paginationDisabledClass","bullets","dynamicBulletIndex","isPaginationDisabled","setSideBullets","bulletEl","onBulletClick","newSlideIndex","currentSlideIndex","total","firstIndex","midIndex","classesToRemove","s","flat","bullet","bulletIndex","firstDisplayedBullet","lastDisplayedBullet","dynamicBulletsLength","bulletsOffset","subElIndex","fractionEl","textContent","totalEl","progressbarDirection","scale","scaleX","scaleY","progressEl","render","paginationHTML","numberOfBullets","dragStartPos","dragSize","trackSize","divider","dragTimeout","scrollbar","dragEl","newSize","newPos","hide","opacity","display","getPointerPosition","setDragPosition","positionRatio","onDragStart","onDragMove","onDragEnd","snapOnRelease","activeListener","passiveListener","eventMethod","swiperEl","dragClass","scrollbarDisabledClass","parallax","setTransform","p","rotate","currentOpacity","_swiper","parallaxEl","parallaxDuration","maxRatio","containerClass","zoomedSlideClass","fakeGestureTouched","fakeGestureMoved","currentScale","isScaling","gesture","originX","originY","slideWidth","slideHeight","imageWrapEl","image","minX","minY","maxX","maxY","touchesStart","touchesCurrent","prevPositionX","prevPositionY","prevTime","getDistanceBetweenTouches","x1","y1","x2","y2","eventWithinSlide","onGestureStart","scaleStart","getScaleOrigin","onGestureChange","scaleMove","onGestureEnd","eventWithinZoomContainer","scaledWidth","scaledHeight","scaleRatio","onTransitionEnd","zoomIn","touchX","touchY","offsetX","offsetY","translateX","translateY","imageWidth","imageHeight","translateMinX","translateMinY","translateMaxX","translateMaxY","touchAction","forceZoomRatio","zoomOut","zoomToggle","getListeners","activeListenerWithCapture","momentumDurationX","momentumDurationY","momentumDistanceX","newPositionX","momentumDistanceY","newPositionY","momentumDuration","in","out","LinearSpline","binarySearch","maxIndex","minIndex","guess","i1","i3","interpolate","removeSpline","spline","inverse","by","controlElement","onControllerSwiper","_t","controlled","controlledTranslate","setControlledTranslate","getInterpolateFunction","setControlledTransition","a11y","notificationClass","prevSlideMessage","nextSlideMessage","firstSlideMessage","lastSlideMessage","paginationBulletMessage","slideLabelMessage","containerMessage","containerRoleDescriptionMessage","itemRoleDescriptionMessage","slideRole","clicked","liveRegion","notify","message","notification","makeElFocusable","makeElNotFocusable","addElRole","role","addElRoleDescription","description","addElLabel","disableEl","enableEl","onEnterOrSpaceKey","click","hasPagination","hasClickablePagination","initNavEl","wrapperId","controls","addElControls","handlePointerDown","handlePointerUp","handleFocus","isActive","isVisible","sourceCapabilities","firesTouchEvents","repeat","random","live","addElLive","updateNavigation","updatePagination","root","replaceState","keepQuery","paths","slugify","getPathValues","urlOverride","URL","pathArray","part","setHistory","currentState","pushState","scrollToSlide","setHistoryPopState","hashNavigation","watchState","slideWithHash","onHashChange","newHash","activeSlideEl","setHash","activeSlideHash","raf","timeLeft","waitForTransition","disableOnInteraction","stopOnLastSlide","reverseDirection","pauseOnMouseEnter","autoplayTimeLeft","wasPaused","pausedByTouch","touchStartTimeout","slideChanged","pausedByInteraction","autoplayDelayTotal","autoplayDelayCurrent","autoplayStartTime","calcTimeLeft","run","delayForce","currentSlideDelay","getSlideDelay","proceed","pause","onVisibilityChange","visibilityState","onPointerEnter","onPointerLeave","thumbs","multipleActiveThumbs","autoScrollOffset","slideThumbActiveClass","thumbsContainerClass","swiperCreated","onThumbClick","thumbsSwiper","thumbsParams","SwiperClass","thumbsSwiperParams","thumbsToActivate","thumbActiveClass","useOffset","currentThumbsIndex","newThumbsIndex","newThumbsSlide","getThumbsElementAndInit","thumbsElement","onThumbsSwiper","watchForThumbsToAppear","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","minimumVelocity","lastMoveEvent","pop","velocityEvent","momentumDistance","newPosition","afterBouncePosition","doBounce","bounceAmount","needsLoopFix","moveDistance","currentSlideSize","slidesNumberEvenToRows","slidesPerRow","numFullColumns","getSpaceBetween","newSlideOrderIndex","row","groupIndex","slideIndexInGroup","columnsInGroup","order","fadeEffect","crossFade","tx","ty","slideOpacity","cubeEffect","shadow","shadowOffset","shadowScale","createSlideShadows","shadowBefore","shadowAfter","cubeShadowEl","wrapperRotate","slideAngle","tz","transformOrigin","shadowAngle","sin","scale1","scale2","zFactor","flipEffect","limitRotation","rotateY","rotateX","coverflowEffect","stretch","depth","modifier","center","centerOffset","offsetMultiplier","translateZ","slideTransform","shadowBeforeEl","shadowAfterEl","creativeEffect","limitProgress","shadowPerProgress","progressMultiplier","getTranslateValue","isCenteredSlides","custom","translateString","rotateString","scaleString","opacityString","shadowOpacity","cardsEffect","perSlideRotate","perSlideOffset","tX","tY","tZ","tXAdd","isSwipeToNext","isSwipeToPrev","subProgress"],"mappings":"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","file":"../swiper/libs.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.noUiSlider = {}));\n})(this, (function (exports) { 'use strict';\n\n    exports.PipsMode = void 0;\n    (function (PipsMode) {\n        PipsMode[\"Range\"] = \"range\";\n        PipsMode[\"Steps\"] = \"steps\";\n        PipsMode[\"Positions\"] = \"positions\";\n        PipsMode[\"Count\"] = \"count\";\n        PipsMode[\"Values\"] = \"values\";\n    })(exports.PipsMode || (exports.PipsMode = {}));\n    exports.PipsType = void 0;\n    (function (PipsType) {\n        PipsType[PipsType[\"None\"] = -1] = \"None\";\n        PipsType[PipsType[\"NoValue\"] = 0] = \"NoValue\";\n        PipsType[PipsType[\"LargeValue\"] = 1] = \"LargeValue\";\n        PipsType[PipsType[\"SmallValue\"] = 2] = \"SmallValue\";\n    })(exports.PipsType || (exports.PipsType = {}));\n    //region Helper Methods\n    function isValidFormatter(entry) {\n        return isValidPartialFormatter(entry) && typeof entry.from === \"function\";\n    }\n    function isValidPartialFormatter(entry) {\n        // partial formatters only need a to function and not a from function\n        return typeof entry === \"object\" && typeof entry.to === \"function\";\n    }\n    function removeElement(el) {\n        el.parentElement.removeChild(el);\n    }\n    function isSet(value) {\n        return value !== null && value !== undefined;\n    }\n    // Bindable version\n    function preventDefault(e) {\n        e.preventDefault();\n    }\n    // Removes duplicates from an array.\n    function unique(array) {\n        return array.filter(function (a) {\n            return !this[a] ? (this[a] = true) : false;\n        }, {});\n    }\n    // Round a value to the closest 'to'.\n    function closest(value, to) {\n        return Math.round(value / to) * to;\n    }\n    // Current position of an element relative to the document.\n    function offset(elem, orientation) {\n        var rect = elem.getBoundingClientRect();\n        var doc = elem.ownerDocument;\n        var docElem = doc.documentElement;\n        var pageOffset = getPageOffset(doc);\n        // getBoundingClientRect contains left scroll in Chrome on Android.\n        // I haven't found a feature detection that proves this. Worst case\n        // scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\n        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\n            pageOffset.x = 0;\n        }\n        return orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft;\n    }\n    // Checks whether a value is numerical.\n    function isNumeric(a) {\n        return typeof a === \"number\" && !isNaN(a) && isFinite(a);\n    }\n    // Sets a class and removes it after [duration] ms.\n    function addClassFor(element, className, duration) {\n        if (duration > 0) {\n            addClass(element, className);\n            setTimeout(function () {\n                removeClass(element, className);\n            }, duration);\n        }\n    }\n    // Limits a value to 0 - 100\n    function limit(a) {\n        return Math.max(Math.min(a, 100), 0);\n    }\n    // Wraps a variable as an array, if it isn't one yet.\n    // Note that an input array is returned by reference!\n    function asArray(a) {\n        return Array.isArray(a) ? a : [a];\n    }\n    // Counts decimals\n    function countDecimals(numStr) {\n        numStr = String(numStr);\n        var pieces = numStr.split(\".\");\n        return pieces.length > 1 ? pieces[1].length : 0;\n    }\n    // http://youmightnotneedjquery.com/#add_class\n    function addClass(el, className) {\n        if (el.classList && !/\\s/.test(className)) {\n            el.classList.add(className);\n        }\n        else {\n            el.className += \" \" + className;\n        }\n    }\n    // http://youmightnotneedjquery.com/#remove_class\n    function removeClass(el, className) {\n        if (el.classList && !/\\s/.test(className)) {\n            el.classList.remove(className);\n        }\n        else {\n            el.className = el.className.replace(new RegExp(\"(^|\\\\b)\" + className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"), \" \");\n        }\n    }\n    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\n    function hasClass(el, className) {\n        return el.classList ? el.classList.contains(className) : new RegExp(\"\\\\b\" + className + \"\\\\b\").test(el.className);\n    }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\n    function getPageOffset(doc) {\n        var supportPageOffset = window.pageXOffset !== undefined;\n        var isCSS1Compat = (doc.compatMode || \"\") === \"CSS1Compat\";\n        var x = supportPageOffset\n            ? window.pageXOffset\n            : isCSS1Compat\n                ? doc.documentElement.scrollLeft\n                : doc.body.scrollLeft;\n        var y = supportPageOffset\n            ? window.pageYOffset\n            : isCSS1Compat\n                ? doc.documentElement.scrollTop\n                : doc.body.scrollTop;\n        return {\n            x: x,\n            y: y,\n        };\n    }\n    // we provide a function to compute constants instead\n    // of accessing window.* as soon as the module needs it\n    // so that we do not compute anything if not needed\n    function getActions() {\n        // Determine the events to bind. IE11 implements pointerEvents without\n        // a prefix, which breaks compatibility with the IE10 implementation.\n        return window.navigator.pointerEnabled\n            ? {\n                start: \"pointerdown\",\n                move: \"pointermove\",\n                end: \"pointerup\",\n            }\n            : window.navigator.msPointerEnabled\n                ? {\n                    start: \"MSPointerDown\",\n                    move: \"MSPointerMove\",\n                    end: \"MSPointerUp\",\n                }\n                : {\n                    start: \"mousedown touchstart\",\n                    move: \"mousemove touchmove\",\n                    end: \"mouseup touchend\",\n                };\n    }\n    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    // Issue #785\n    function getSupportsPassive() {\n        var supportsPassive = false;\n        /* eslint-disable */\n        try {\n            var opts = Object.defineProperty({}, \"passive\", {\n                get: function () {\n                    supportsPassive = true;\n                },\n            });\n            // @ts-ignore\n            window.addEventListener(\"test\", null, opts);\n        }\n        catch (e) { }\n        /* eslint-enable */\n        return supportsPassive;\n    }\n    function getSupportsTouchActionNone() {\n        return window.CSS && CSS.supports && CSS.supports(\"touch-action\", \"none\");\n    }\n    //endregion\n    //region Range Calculation\n    // Determine the size of a sub-range in relation to a full range.\n    function subRangeRatio(pa, pb) {\n        return 100 / (pb - pa);\n    }\n    // (percentage) How many percent is this value of this range?\n    function fromPercentage(range, value, startRange) {\n        return (value * 100) / (range[startRange + 1] - range[startRange]);\n    }\n    // (percentage) Where is this value on this range?\n    function toPercentage(range, value) {\n        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0], 0);\n    }\n    // (value) How much is this percentage on this range?\n    function isPercentage(range, value) {\n        return (value * (range[1] - range[0])) / 100 + range[0];\n    }\n    function getJ(value, arr) {\n        var j = 1;\n        while (value >= arr[j]) {\n            j += 1;\n        }\n        return j;\n    }\n    // (percentage) Input a value, find where, on a scale of 0-100, it applies.\n    function toStepping(xVal, xPct, value) {\n        if (value >= xVal.slice(-1)[0]) {\n            return 100;\n        }\n        var j = getJ(value, xVal);\n        var va = xVal[j - 1];\n        var vb = xVal[j];\n        var pa = xPct[j - 1];\n        var pb = xPct[j];\n        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\n    }\n    // (value) Input a percentage, find where it is on the specified range.\n    function fromStepping(xVal, xPct, value) {\n        // There is no range group that fits 100\n        if (value >= 100) {\n            return xVal.slice(-1)[0];\n        }\n        var j = getJ(value, xPct);\n        var va = xVal[j - 1];\n        var vb = xVal[j];\n        var pa = xPct[j - 1];\n        var pb = xPct[j];\n        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\n    }\n    // (percentage) Get the step that applies at a certain value.\n    function getStep(xPct, xSteps, snap, value) {\n        if (value === 100) {\n            return value;\n        }\n        var j = getJ(value, xPct);\n        var a = xPct[j - 1];\n        var b = xPct[j];\n        // If 'snap' is set, steps are used as fixed points on the slider.\n        if (snap) {\n            // Find the closest position, a or b.\n            if (value - a > (b - a) / 2) {\n                return b;\n            }\n            return a;\n        }\n        if (!xSteps[j - 1]) {\n            return value;\n        }\n        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\n    }\n    //endregion\n    //region Spectrum\n    var Spectrum = /** @class */ (function () {\n        function Spectrum(entry, snap, singleStep) {\n            this.xPct = [];\n            this.xVal = [];\n            this.xSteps = [];\n            this.xNumSteps = [];\n            this.xHighestCompleteStep = [];\n            this.xSteps = [singleStep || false];\n            this.xNumSteps = [false];\n            this.snap = snap;\n            var index;\n            var ordered = [];\n            // Map the object keys to an array.\n            Object.keys(entry).forEach(function (index) {\n                ordered.push([asArray(entry[index]), index]);\n            });\n            // Sort all entries by value (numeric sort).\n            ordered.sort(function (a, b) {\n                return a[0][0] - b[0][0];\n            });\n            // Convert all entries to subranges.\n            for (index = 0; index < ordered.length; index++) {\n                this.handleEntryPoint(ordered[index][1], ordered[index][0]);\n            }\n            // Store the actual step values.\n            // xSteps is sorted in the same order as xPct and xVal.\n            this.xNumSteps = this.xSteps.slice(0);\n            // Convert all numeric steps to the percentage of the subrange they represent.\n            for (index = 0; index < this.xNumSteps.length; index++) {\n                this.handleStepPoint(index, this.xNumSteps[index]);\n            }\n        }\n        Spectrum.prototype.getDistance = function (value) {\n            var distances = [];\n            for (var index = 0; index < this.xNumSteps.length - 1; index++) {\n                distances[index] = fromPercentage(this.xVal, value, index);\n            }\n            return distances;\n        };\n        // Calculate the percentual distance over the whole scale of ranges.\n        // direction: 0 = backwards / 1 = forwards\n        Spectrum.prototype.getAbsoluteDistance = function (value, distances, direction) {\n            var xPct_index = 0;\n            // Calculate range where to start calculation\n            if (value < this.xPct[this.xPct.length - 1]) {\n                while (value > this.xPct[xPct_index + 1]) {\n                    xPct_index++;\n                }\n            }\n            else if (value === this.xPct[this.xPct.length - 1]) {\n                xPct_index = this.xPct.length - 2;\n            }\n            // If looking backwards and the value is exactly at a range separator then look one range further\n            if (!direction && value === this.xPct[xPct_index + 1]) {\n                xPct_index++;\n            }\n            if (distances === null) {\n                distances = [];\n            }\n            var start_factor;\n            var rest_factor = 1;\n            var rest_rel_distance = distances[xPct_index];\n            var range_pct = 0;\n            var rel_range_distance = 0;\n            var abs_distance_counter = 0;\n            var range_counter = 0;\n            // Calculate what part of the start range the value is\n            if (direction) {\n                start_factor = (value - this.xPct[xPct_index]) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);\n            }\n            else {\n                start_factor = (this.xPct[xPct_index + 1] - value) / (this.xPct[xPct_index + 1] - this.xPct[xPct_index]);\n            }\n            // Do until the complete distance across ranges is calculated\n            while (rest_rel_distance > 0) {\n                // Calculate the percentage of total range\n                range_pct = this.xPct[xPct_index + 1 + range_counter] - this.xPct[xPct_index + range_counter];\n                // Detect if the margin, padding or limit is larger then the current range and calculate\n                if (distances[xPct_index + range_counter] * rest_factor + 100 - start_factor * 100 > 100) {\n                    // If larger then take the percentual distance of the whole range\n                    rel_range_distance = range_pct * start_factor;\n                    // Rest factor of relative percentual distance still to be calculated\n                    rest_factor = (rest_rel_distance - 100 * start_factor) / distances[xPct_index + range_counter];\n                    // Set start factor to 1 as for next range it does not apply.\n                    start_factor = 1;\n                }\n                else {\n                    // If smaller or equal then take the percentual distance of the calculate percentual part of that range\n                    rel_range_distance = ((distances[xPct_index + range_counter] * range_pct) / 100) * rest_factor;\n                    // No rest left as the rest fits in current range\n                    rest_factor = 0;\n                }\n                if (direction) {\n                    abs_distance_counter = abs_distance_counter - rel_range_distance;\n                    // Limit range to first range when distance becomes outside of minimum range\n                    if (this.xPct.length + range_counter >= 1) {\n                        range_counter--;\n                    }\n                }\n                else {\n                    abs_distance_counter = abs_distance_counter + rel_range_distance;\n                    // Limit range to last range when distance becomes outside of maximum range\n                    if (this.xPct.length - range_counter >= 1) {\n                        range_counter++;\n                    }\n                }\n                // Rest of relative percentual distance still to be calculated\n                rest_rel_distance = distances[xPct_index + range_counter] * rest_factor;\n            }\n            return value + abs_distance_counter;\n        };\n        Spectrum.prototype.toStepping = function (value) {\n            value = toStepping(this.xVal, this.xPct, value);\n            return value;\n        };\n        Spectrum.prototype.fromStepping = function (value) {\n            return fromStepping(this.xVal, this.xPct, value);\n        };\n        Spectrum.prototype.getStep = function (value) {\n            value = getStep(this.xPct, this.xSteps, this.snap, value);\n            return value;\n        };\n        Spectrum.prototype.getDefaultStep = function (value, isDown, size) {\n            var j = getJ(value, this.xPct);\n            // When at the top or stepping down, look at the previous sub-range\n            if (value === 100 || (isDown && value === this.xPct[j - 1])) {\n                j = Math.max(j - 1, 1);\n            }\n            return (this.xVal[j] - this.xVal[j - 1]) / size;\n        };\n        Spectrum.prototype.getNearbySteps = function (value) {\n            var j = getJ(value, this.xPct);\n            return {\n                stepBefore: {\n                    startValue: this.xVal[j - 2],\n                    step: this.xNumSteps[j - 2],\n                    highestStep: this.xHighestCompleteStep[j - 2],\n                },\n                thisStep: {\n                    startValue: this.xVal[j - 1],\n                    step: this.xNumSteps[j - 1],\n                    highestStep: this.xHighestCompleteStep[j - 1],\n                },\n                stepAfter: {\n                    startValue: this.xVal[j],\n                    step: this.xNumSteps[j],\n                    highestStep: this.xHighestCompleteStep[j],\n                },\n            };\n        };\n        Spectrum.prototype.countStepDecimals = function () {\n            var stepDecimals = this.xNumSteps.map(countDecimals);\n            return Math.max.apply(null, stepDecimals);\n        };\n        Spectrum.prototype.hasNoSize = function () {\n            return this.xVal[0] === this.xVal[this.xVal.length - 1];\n        };\n        // Outside testing\n        Spectrum.prototype.convert = function (value) {\n            return this.getStep(this.toStepping(value));\n        };\n        Spectrum.prototype.handleEntryPoint = function (index, value) {\n            var percentage;\n            // Covert min/max syntax to 0 and 100.\n            if (index === \"min\") {\n                percentage = 0;\n            }\n            else if (index === \"max\") {\n                percentage = 100;\n            }\n            else {\n                percentage = parseFloat(index);\n            }\n            // Check for correct input.\n            if (!isNumeric(percentage) || !isNumeric(value[0])) {\n                throw new Error(\"noUiSlider: 'range' value isn't numeric.\");\n            }\n            // Store values.\n            this.xPct.push(percentage);\n            this.xVal.push(value[0]);\n            var value1 = Number(value[1]);\n            // NaN will evaluate to false too, but to keep\n            // logging clear, set step explicitly. Make sure\n            // not to override the 'step' setting with false.\n            if (!percentage) {\n                if (!isNaN(value1)) {\n                    this.xSteps[0] = value1;\n                }\n            }\n            else {\n                this.xSteps.push(isNaN(value1) ? false : value1);\n            }\n            this.xHighestCompleteStep.push(0);\n        };\n        Spectrum.prototype.handleStepPoint = function (i, n) {\n            // Ignore 'false' stepping.\n            if (!n) {\n                return;\n            }\n            // Step over zero-length ranges (#948);\n            if (this.xVal[i] === this.xVal[i + 1]) {\n                this.xSteps[i] = this.xHighestCompleteStep[i] = this.xVal[i];\n                return;\n            }\n            // Factor to range ratio\n            this.xSteps[i] =\n                fromPercentage([this.xVal[i], this.xVal[i + 1]], n, 0) / subRangeRatio(this.xPct[i], this.xPct[i + 1]);\n            var totalSteps = (this.xVal[i + 1] - this.xVal[i]) / this.xNumSteps[i];\n            var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\n            var step = this.xVal[i] + this.xNumSteps[i] * highestStep;\n            this.xHighestCompleteStep[i] = step;\n        };\n        return Spectrum;\n    }());\n    //endregion\n    //region Options\n    /*\tEvery input option is tested and parsed. This will prevent\n        endless validation in internal methods. These tests are\n        structured with an item for every option available. An\n        option can be marked as required by setting the 'r' flag.\n        The testing function is provided with three arguments:\n            - The provided value for the option;\n            - A reference to the options object;\n            - The name for the option;\n\n        The testing function returns false when an error is detected,\n        or true when everything is OK. It can also modify the option\n        object, to make sure all values can be correctly looped elsewhere. */\n    //region Defaults\n    var defaultFormatter = {\n        to: function (value) {\n            return value === undefined ? \"\" : value.toFixed(2);\n        },\n        from: Number,\n    };\n    var cssClasses = {\n        target: \"target\",\n        base: \"base\",\n        origin: \"origin\",\n        handle: \"handle\",\n        handleLower: \"handle-lower\",\n        handleUpper: \"handle-upper\",\n        touchArea: \"touch-area\",\n        horizontal: \"horizontal\",\n        vertical: \"vertical\",\n        background: \"background\",\n        connect: \"connect\",\n        connects: \"connects\",\n        ltr: \"ltr\",\n        rtl: \"rtl\",\n        textDirectionLtr: \"txt-dir-ltr\",\n        textDirectionRtl: \"txt-dir-rtl\",\n        draggable: \"draggable\",\n        drag: \"state-drag\",\n        tap: \"state-tap\",\n        active: \"active\",\n        tooltip: \"tooltip\",\n        pips: \"pips\",\n        pipsHorizontal: \"pips-horizontal\",\n        pipsVertical: \"pips-vertical\",\n        marker: \"marker\",\n        markerHorizontal: \"marker-horizontal\",\n        markerVertical: \"marker-vertical\",\n        markerNormal: \"marker-normal\",\n        markerLarge: \"marker-large\",\n        markerSub: \"marker-sub\",\n        value: \"value\",\n        valueHorizontal: \"value-horizontal\",\n        valueVertical: \"value-vertical\",\n        valueNormal: \"value-normal\",\n        valueLarge: \"value-large\",\n        valueSub: \"value-sub\",\n    };\n    // Namespaces of internal event listeners\n    var INTERNAL_EVENT_NS = {\n        tooltips: \".__tooltips\",\n        aria: \".__aria\",\n    };\n    //endregion\n    function testStep(parsed, entry) {\n        if (!isNumeric(entry)) {\n            throw new Error(\"noUiSlider: 'step' is not numeric.\");\n        }\n        // The step option can still be used to set stepping\n        // for linear sliders. Overwritten if set in 'range'.\n        parsed.singleStep = entry;\n    }\n    function testKeyboardPageMultiplier(parsed, entry) {\n        if (!isNumeric(entry)) {\n            throw new Error(\"noUiSlider: 'keyboardPageMultiplier' is not numeric.\");\n        }\n        parsed.keyboardPageMultiplier = entry;\n    }\n    function testKeyboardMultiplier(parsed, entry) {\n        if (!isNumeric(entry)) {\n            throw new Error(\"noUiSlider: 'keyboardMultiplier' is not numeric.\");\n        }\n        parsed.keyboardMultiplier = entry;\n    }\n    function testKeyboardDefaultStep(parsed, entry) {\n        if (!isNumeric(entry)) {\n            throw new Error(\"noUiSlider: 'keyboardDefaultStep' is not numeric.\");\n        }\n        parsed.keyboardDefaultStep = entry;\n    }\n    function testRange(parsed, entry) {\n        // Filter incorrect input.\n        if (typeof entry !== \"object\" || Array.isArray(entry)) {\n            throw new Error(\"noUiSlider: 'range' is not an object.\");\n        }\n        // Catch missing start or end.\n        if (entry.min === undefined || entry.max === undefined) {\n            throw new Error(\"noUiSlider: Missing 'min' or 'max' in 'range'.\");\n        }\n        parsed.spectrum = new Spectrum(entry, parsed.snap || false, parsed.singleStep);\n    }\n    function testStart(parsed, entry) {\n        entry = asArray(entry);\n        // Validate input. Values aren't tested, as the public .val method\n        // will always provide a valid location.\n        if (!Array.isArray(entry) || !entry.length) {\n            throw new Error(\"noUiSlider: 'start' option is incorrect.\");\n        }\n        // Store the number of handles.\n        parsed.handles = entry.length;\n        // When the slider is initialized, the .val method will\n        // be called with the start options.\n        parsed.start = entry;\n    }\n    function testSnap(parsed, entry) {\n        if (typeof entry !== \"boolean\") {\n            throw new Error(\"noUiSlider: 'snap' option must be a boolean.\");\n        }\n        // Enforce 100% stepping within subranges.\n        parsed.snap = entry;\n    }\n    function testAnimate(parsed, entry) {\n        if (typeof entry !== \"boolean\") {\n            throw new Error(\"noUiSlider: 'animate' option must be a boolean.\");\n        }\n        // Enforce 100% stepping within subranges.\n        parsed.animate = entry;\n    }\n    function testAnimationDuration(parsed, entry) {\n        if (typeof entry !== \"number\") {\n            throw new Error(\"noUiSlider: 'animationDuration' option must be a number.\");\n        }\n        parsed.animationDuration = entry;\n    }\n    function testConnect(parsed, entry) {\n        var connect = [false];\n        var i;\n        // Map legacy options\n        if (entry === \"lower\") {\n            entry = [true, false];\n        }\n        else if (entry === \"upper\") {\n            entry = [false, true];\n        }\n        // Handle boolean options\n        if (entry === true || entry === false) {\n            for (i = 1; i < parsed.handles; i++) {\n                connect.push(entry);\n            }\n            connect.push(false);\n        }\n        // Reject invalid input\n        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\n            throw new Error(\"noUiSlider: 'connect' option doesn't match handle count.\");\n        }\n        else {\n            connect = entry;\n        }\n        parsed.connect = connect;\n    }\n    function testOrientation(parsed, entry) {\n        // Set orientation to an a numerical value for easy\n        // array selection.\n        switch (entry) {\n            case \"horizontal\":\n                parsed.ort = 0;\n                break;\n            case \"vertical\":\n                parsed.ort = 1;\n                break;\n            default:\n                throw new Error(\"noUiSlider: 'orientation' option is invalid.\");\n        }\n    }\n    function testMargin(parsed, entry) {\n        if (!isNumeric(entry)) {\n            throw new Error(\"noUiSlider: 'margin' option must be numeric.\");\n        }\n        // Issue #582\n        if (entry === 0) {\n            return;\n        }\n        parsed.margin = parsed.spectrum.getDistance(entry);\n    }\n    function testLimit(parsed, entry) {\n        if (!isNumeric(entry)) {\n            throw new Error(\"noUiSlider: 'limit' option must be numeric.\");\n        }\n        parsed.limit = parsed.spectrum.getDistance(entry);\n        if (!parsed.limit || parsed.handles < 2) {\n            throw new Error(\"noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.\");\n        }\n    }\n    function testPadding(parsed, entry) {\n        var index;\n        if (!isNumeric(entry) && !Array.isArray(entry)) {\n            throw new Error(\"noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.\");\n        }\n        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {\n            throw new Error(\"noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers.\");\n        }\n        if (entry === 0) {\n            return;\n        }\n        if (!Array.isArray(entry)) {\n            entry = [entry, entry];\n        }\n        // 'getDistance' returns false for invalid values.\n        parsed.padding = [parsed.spectrum.getDistance(entry[0]), parsed.spectrum.getDistance(entry[1])];\n        for (index = 0; index < parsed.spectrum.xNumSteps.length - 1; index++) {\n            // last \"range\" can't contain step size as it is purely an endpoint.\n            if (parsed.padding[0][index] < 0 || parsed.padding[1][index] < 0) {\n                throw new Error(\"noUiSlider: 'padding' option must be a positive number(s).\");\n            }\n        }\n        var totalPadding = entry[0] + entry[1];\n        var firstValue = parsed.spectrum.xVal[0];\n        var lastValue = parsed.spectrum.xVal[parsed.spectrum.xVal.length - 1];\n        if (totalPadding / (lastValue - firstValue) > 1) {\n            throw new Error(\"noUiSlider: 'padding' option must not exceed 100% of the range.\");\n        }\n    }\n    function testDirection(parsed, entry) {\n        // Set direction as a numerical value for easy parsing.\n        // Invert connection for RTL sliders, so that the proper\n        // handles get the connect/background classes.\n        switch (entry) {\n            case \"ltr\":\n                parsed.dir = 0;\n                break;\n            case \"rtl\":\n                parsed.dir = 1;\n                break;\n            default:\n                throw new Error(\"noUiSlider: 'direction' option was not recognized.\");\n        }\n    }\n    function testBehaviour(parsed, entry) {\n        // Make sure the input is a string.\n        if (typeof entry !== \"string\") {\n            throw new Error(\"noUiSlider: 'behaviour' must be a string containing options.\");\n        }\n        // Check if the string contains any keywords.\n        // None are required.\n        var tap = entry.indexOf(\"tap\") >= 0;\n        var drag = entry.indexOf(\"drag\") >= 0;\n        var fixed = entry.indexOf(\"fixed\") >= 0;\n        var snap = entry.indexOf(\"snap\") >= 0;\n        var hover = entry.indexOf(\"hover\") >= 0;\n        var unconstrained = entry.indexOf(\"unconstrained\") >= 0;\n        var dragAll = entry.indexOf(\"drag-all\") >= 0;\n        var smoothSteps = entry.indexOf(\"smooth-steps\") >= 0;\n        if (fixed) {\n            if (parsed.handles !== 2) {\n                throw new Error(\"noUiSlider: 'fixed' behaviour must be used with 2 handles\");\n            }\n            // Use margin to enforce fixed state\n            testMargin(parsed, parsed.start[1] - parsed.start[0]);\n        }\n        if (unconstrained && (parsed.margin || parsed.limit)) {\n            throw new Error(\"noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit\");\n        }\n        parsed.events = {\n            tap: tap || snap,\n            drag: drag,\n            dragAll: dragAll,\n            smoothSteps: smoothSteps,\n            fixed: fixed,\n            snap: snap,\n            hover: hover,\n            unconstrained: unconstrained,\n        };\n    }\n    function testTooltips(parsed, entry) {\n        if (entry === false) {\n            return;\n        }\n        if (entry === true || isValidPartialFormatter(entry)) {\n            parsed.tooltips = [];\n            for (var i = 0; i < parsed.handles; i++) {\n                parsed.tooltips.push(entry);\n            }\n        }\n        else {\n            entry = asArray(entry);\n            if (entry.length !== parsed.handles) {\n                throw new Error(\"noUiSlider: must pass a formatter for all handles.\");\n            }\n            entry.forEach(function (formatter) {\n                if (typeof formatter !== \"boolean\" && !isValidPartialFormatter(formatter)) {\n                    throw new Error(\"noUiSlider: 'tooltips' must be passed a formatter or 'false'.\");\n                }\n            });\n            parsed.tooltips = entry;\n        }\n    }\n    function testHandleAttributes(parsed, entry) {\n        if (entry.length !== parsed.handles) {\n            throw new Error(\"noUiSlider: must pass a attributes for all handles.\");\n        }\n        parsed.handleAttributes = entry;\n    }\n    function testAriaFormat(parsed, entry) {\n        if (!isValidPartialFormatter(entry)) {\n            throw new Error(\"noUiSlider: 'ariaFormat' requires 'to' method.\");\n        }\n        parsed.ariaFormat = entry;\n    }\n    function testFormat(parsed, entry) {\n        if (!isValidFormatter(entry)) {\n            throw new Error(\"noUiSlider: 'format' requires 'to' and 'from' methods.\");\n        }\n        parsed.format = entry;\n    }\n    function testKeyboardSupport(parsed, entry) {\n        if (typeof entry !== \"boolean\") {\n            throw new Error(\"noUiSlider: 'keyboardSupport' option must be a boolean.\");\n        }\n        parsed.keyboardSupport = entry;\n    }\n    function testDocumentElement(parsed, entry) {\n        // This is an advanced option. Passed values are used without validation.\n        parsed.documentElement = entry;\n    }\n    function testCssPrefix(parsed, entry) {\n        if (typeof entry !== \"string\" && entry !== false) {\n            throw new Error(\"noUiSlider: 'cssPrefix' must be a string or `false`.\");\n        }\n        parsed.cssPrefix = entry;\n    }\n    function testCssClasses(parsed, entry) {\n        if (typeof entry !== \"object\") {\n            throw new Error(\"noUiSlider: 'cssClasses' must be an object.\");\n        }\n        if (typeof parsed.cssPrefix === \"string\") {\n            parsed.cssClasses = {};\n            Object.keys(entry).forEach(function (key) {\n                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\n            });\n        }\n        else {\n            parsed.cssClasses = entry;\n        }\n    }\n    // Test all developer settings and parse to assumption-safe values.\n    function testOptions(options) {\n        // To prove a fix for #537, freeze options here.\n        // If the object is modified, an error will be thrown.\n        // Object.freeze(options);\n        var parsed = {\n            margin: null,\n            limit: null,\n            padding: null,\n            animate: true,\n            animationDuration: 300,\n            ariaFormat: defaultFormatter,\n            format: defaultFormatter,\n        };\n        // Tests are executed in the order they are presented here.\n        var tests = {\n            step: { r: false, t: testStep },\n            keyboardPageMultiplier: { r: false, t: testKeyboardPageMultiplier },\n            keyboardMultiplier: { r: false, t: testKeyboardMultiplier },\n            keyboardDefaultStep: { r: false, t: testKeyboardDefaultStep },\n            start: { r: true, t: testStart },\n            connect: { r: true, t: testConnect },\n            direction: { r: true, t: testDirection },\n            snap: { r: false, t: testSnap },\n            animate: { r: false, t: testAnimate },\n            animationDuration: { r: false, t: testAnimationDuration },\n            range: { r: true, t: testRange },\n            orientation: { r: false, t: testOrientation },\n            margin: { r: false, t: testMargin },\n            limit: { r: false, t: testLimit },\n            padding: { r: false, t: testPadding },\n            behaviour: { r: true, t: testBehaviour },\n            ariaFormat: { r: false, t: testAriaFormat },\n            format: { r: false, t: testFormat },\n            tooltips: { r: false, t: testTooltips },\n            keyboardSupport: { r: true, t: testKeyboardSupport },\n            documentElement: { r: false, t: testDocumentElement },\n            cssPrefix: { r: true, t: testCssPrefix },\n            cssClasses: { r: true, t: testCssClasses },\n            handleAttributes: { r: false, t: testHandleAttributes },\n        };\n        var defaults = {\n            connect: false,\n            direction: \"ltr\",\n            behaviour: \"tap\",\n            orientation: \"horizontal\",\n            keyboardSupport: true,\n            cssPrefix: \"noUi-\",\n            cssClasses: cssClasses,\n            keyboardPageMultiplier: 5,\n            keyboardMultiplier: 1,\n            keyboardDefaultStep: 10,\n        };\n        // AriaFormat defaults to regular format, if any.\n        if (options.format && !options.ariaFormat) {\n            options.ariaFormat = options.format;\n        }\n        // Run all options through a testing mechanism to ensure correct\n        // input. It should be noted that options might get modified to\n        // be handled properly. E.g. wrapping integers in arrays.\n        Object.keys(tests).forEach(function (name) {\n            // If the option isn't set, but it is required, throw an error.\n            if (!isSet(options[name]) && defaults[name] === undefined) {\n                if (tests[name].r) {\n                    throw new Error(\"noUiSlider: '\" + name + \"' is required.\");\n                }\n                return;\n            }\n            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);\n        });\n        // Forward pips options\n        parsed.pips = options.pips;\n        // All recent browsers accept unprefixed transform.\n        // We need -ms- for IE9 and -webkit- for older Android;\n        // Assume use of -webkit- if unprefixed and -ms- are not supported.\n        // https://caniuse.com/#feat=transforms2d\n        var d = document.createElement(\"div\");\n        var msPrefix = d.style.msTransform !== undefined;\n        var noPrefix = d.style.transform !== undefined;\n        parsed.transformRule = noPrefix ? \"transform\" : msPrefix ? \"msTransform\" : \"webkitTransform\";\n        // Pips don't move, so we can place them using left/top.\n        var styles = [\n            [\"left\", \"top\"],\n            [\"right\", \"bottom\"],\n        ];\n        parsed.style = styles[parsed.dir][parsed.ort];\n        return parsed;\n    }\n    //endregion\n    function scope(target, options, originalOptions) {\n        var actions = getActions();\n        var supportsTouchActionNone = getSupportsTouchActionNone();\n        var supportsPassive = supportsTouchActionNone && getSupportsPassive();\n        // All variables local to 'scope' are prefixed with 'scope_'\n        // Slider DOM Nodes\n        var scope_Target = target;\n        var scope_Base;\n        var scope_Handles;\n        var scope_Connects;\n        var scope_Pips;\n        var scope_Tooltips;\n        // Slider state values\n        var scope_Spectrum = options.spectrum;\n        var scope_Values = [];\n        var scope_Locations = [];\n        var scope_HandleNumbers = [];\n        var scope_ActiveHandlesCount = 0;\n        var scope_Events = {};\n        // Document Nodes\n        var scope_Document = target.ownerDocument;\n        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;\n        var scope_Body = scope_Document.body;\n        // For horizontal sliders in standard ltr documents,\n        // make .noUi-origin overflow to the left so the document doesn't scroll.\n        var scope_DirOffset = scope_Document.dir === \"rtl\" || options.ort === 1 ? 0 : 100;\n        // Creates a node, adds it to target, returns the new node.\n        function addNodeTo(addTarget, className) {\n            var div = scope_Document.createElement(\"div\");\n            if (className) {\n                addClass(div, className);\n            }\n            addTarget.appendChild(div);\n            return div;\n        }\n        // Append a origin to the base\n        function addOrigin(base, handleNumber) {\n            var origin = addNodeTo(base, options.cssClasses.origin);\n            var handle = addNodeTo(origin, options.cssClasses.handle);\n            addNodeTo(handle, options.cssClasses.touchArea);\n            handle.setAttribute(\"data-handle\", String(handleNumber));\n            if (options.keyboardSupport) {\n                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\n                // 0 = focusable and reachable\n                handle.setAttribute(\"tabindex\", \"0\");\n                handle.addEventListener(\"keydown\", function (event) {\n                    return eventKeydown(event, handleNumber);\n                });\n            }\n            if (options.handleAttributes !== undefined) {\n                var attributes_1 = options.handleAttributes[handleNumber];\n                Object.keys(attributes_1).forEach(function (attribute) {\n                    handle.setAttribute(attribute, attributes_1[attribute]);\n                });\n            }\n            handle.setAttribute(\"role\", \"slider\");\n            handle.setAttribute(\"aria-orientation\", options.ort ? \"vertical\" : \"horizontal\");\n            if (handleNumber === 0) {\n                addClass(handle, options.cssClasses.handleLower);\n            }\n            else if (handleNumber === options.handles - 1) {\n                addClass(handle, options.cssClasses.handleUpper);\n            }\n            origin.handle = handle;\n            return origin;\n        }\n        // Insert nodes for connect elements\n        function addConnect(base, add) {\n            if (!add) {\n                return false;\n            }\n            return addNodeTo(base, options.cssClasses.connect);\n        }\n        // Add handles to the slider base.\n        function addElements(connectOptions, base) {\n            var connectBase = addNodeTo(base, options.cssClasses.connects);\n            scope_Handles = [];\n            scope_Connects = [];\n            scope_Connects.push(addConnect(connectBase, connectOptions[0]));\n            // [::::O====O====O====]\n            // connectOptions = [0, 1, 1, 1]\n            for (var i = 0; i < options.handles; i++) {\n                // Keep a list of all added handles.\n                scope_Handles.push(addOrigin(base, i));\n                scope_HandleNumbers[i] = i;\n                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));\n            }\n        }\n        // Initialize a single slider.\n        function addSlider(addTarget) {\n            // Apply classes and data to the target.\n            addClass(addTarget, options.cssClasses.target);\n            if (options.dir === 0) {\n                addClass(addTarget, options.cssClasses.ltr);\n            }\n            else {\n                addClass(addTarget, options.cssClasses.rtl);\n            }\n            if (options.ort === 0) {\n                addClass(addTarget, options.cssClasses.horizontal);\n            }\n            else {\n                addClass(addTarget, options.cssClasses.vertical);\n            }\n            var textDirection = getComputedStyle(addTarget).direction;\n            if (textDirection === \"rtl\") {\n                addClass(addTarget, options.cssClasses.textDirectionRtl);\n            }\n            else {\n                addClass(addTarget, options.cssClasses.textDirectionLtr);\n            }\n            return addNodeTo(addTarget, options.cssClasses.base);\n        }\n        function addTooltip(handle, handleNumber) {\n            if (!options.tooltips || !options.tooltips[handleNumber]) {\n                return false;\n            }\n            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\n        }\n        function isSliderDisabled() {\n            return scope_Target.hasAttribute(\"disabled\");\n        }\n        // Disable the slider dragging if any handle is disabled\n        function isHandleDisabled(handleNumber) {\n            var handleOrigin = scope_Handles[handleNumber];\n            return handleOrigin.hasAttribute(\"disabled\");\n        }\n        function disable(handleNumber) {\n            if (handleNumber !== null && handleNumber !== undefined) {\n                scope_Handles[handleNumber].setAttribute(\"disabled\", \"\");\n                scope_Handles[handleNumber].handle.removeAttribute(\"tabindex\");\n            }\n            else {\n                scope_Target.setAttribute(\"disabled\", \"\");\n                scope_Handles.forEach(function (handle) {\n                    handle.handle.removeAttribute(\"tabindex\");\n                });\n            }\n        }\n        function enable(handleNumber) {\n            if (handleNumber !== null && handleNumber !== undefined) {\n                scope_Handles[handleNumber].removeAttribute(\"disabled\");\n                scope_Handles[handleNumber].handle.setAttribute(\"tabindex\", \"0\");\n            }\n            else {\n                scope_Target.removeAttribute(\"disabled\");\n                scope_Handles.forEach(function (handle) {\n                    handle.removeAttribute(\"disabled\");\n                    handle.handle.setAttribute(\"tabindex\", \"0\");\n                });\n            }\n        }\n        function removeTooltips() {\n            if (scope_Tooltips) {\n                removeEvent(\"update\" + INTERNAL_EVENT_NS.tooltips);\n                scope_Tooltips.forEach(function (tooltip) {\n                    if (tooltip) {\n                        removeElement(tooltip);\n                    }\n                });\n                scope_Tooltips = null;\n            }\n        }\n        // The tooltips option is a shorthand for using the 'update' event.\n        function tooltips() {\n            removeTooltips();\n            // Tooltips are added with options.tooltips in original order.\n            scope_Tooltips = scope_Handles.map(addTooltip);\n            bindEvent(\"update\" + INTERNAL_EVENT_NS.tooltips, function (values, handleNumber, unencoded) {\n                if (!scope_Tooltips || !options.tooltips) {\n                    return;\n                }\n                if (scope_Tooltips[handleNumber] === false) {\n                    return;\n                }\n                var formattedValue = values[handleNumber];\n                if (options.tooltips[handleNumber] !== true) {\n                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\n                }\n                scope_Tooltips[handleNumber].innerHTML = formattedValue;\n            });\n        }\n        function aria() {\n            removeEvent(\"update\" + INTERNAL_EVENT_NS.aria);\n            bindEvent(\"update\" + INTERNAL_EVENT_NS.aria, function (values, handleNumber, unencoded, tap, positions) {\n                // Update Aria Values for all handles, as a change in one changes min and max values for the next.\n                scope_HandleNumbers.forEach(function (index) {\n                    var handle = scope_Handles[index];\n                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);\n                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);\n                    var now = positions[index];\n                    // Formatted value for display\n                    var text = String(options.ariaFormat.to(unencoded[index]));\n                    // Map to slider range values\n                    min = scope_Spectrum.fromStepping(min).toFixed(1);\n                    max = scope_Spectrum.fromStepping(max).toFixed(1);\n                    now = scope_Spectrum.fromStepping(now).toFixed(1);\n                    handle.children[0].setAttribute(\"aria-valuemin\", min);\n                    handle.children[0].setAttribute(\"aria-valuemax\", max);\n                    handle.children[0].setAttribute(\"aria-valuenow\", now);\n                    handle.children[0].setAttribute(\"aria-valuetext\", text);\n                });\n            });\n        }\n        function getGroup(pips) {\n            // Use the range.\n            if (pips.mode === exports.PipsMode.Range || pips.mode === exports.PipsMode.Steps) {\n                return scope_Spectrum.xVal;\n            }\n            if (pips.mode === exports.PipsMode.Count) {\n                if (pips.values < 2) {\n                    throw new Error(\"noUiSlider: 'values' (>= 2) required for mode 'count'.\");\n                }\n                // Divide 0 - 100 in 'count' parts.\n                var interval = pips.values - 1;\n                var spread = 100 / interval;\n                var values = [];\n                // List these parts and have them handled as 'positions'.\n                while (interval--) {\n                    values[interval] = interval * spread;\n                }\n                values.push(100);\n                return mapToRange(values, pips.stepped);\n            }\n            if (pips.mode === exports.PipsMode.Positions) {\n                // Map all percentages to on-range values.\n                return mapToRange(pips.values, pips.stepped);\n            }\n            if (pips.mode === exports.PipsMode.Values) {\n                // If the value must be stepped, it needs to be converted to a percentage first.\n                if (pips.stepped) {\n                    return pips.values.map(function (value) {\n                        // Convert to percentage, apply step, return to value.\n                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\n                    });\n                }\n                // Otherwise, we can simply use the values.\n                return pips.values;\n            }\n            return []; // pips.mode = never\n        }\n        function mapToRange(values, stepped) {\n            return values.map(function (value) {\n                return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\n            });\n        }\n        function generateSpread(pips) {\n            function safeIncrement(value, increment) {\n                // Avoid floating point variance by dropping the smallest decimal places.\n                return Number((value + increment).toFixed(7));\n            }\n            var group = getGroup(pips);\n            var indexes = {};\n            var firstInRange = scope_Spectrum.xVal[0];\n            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\n            var ignoreFirst = false;\n            var ignoreLast = false;\n            var prevPct = 0;\n            // Create a copy of the group, sort it and filter away all duplicates.\n            group = unique(group.slice().sort(function (a, b) {\n                return a - b;\n            }));\n            // Make sure the range starts with the first element.\n            if (group[0] !== firstInRange) {\n                group.unshift(firstInRange);\n                ignoreFirst = true;\n            }\n            // Likewise for the last one.\n            if (group[group.length - 1] !== lastInRange) {\n                group.push(lastInRange);\n                ignoreLast = true;\n            }\n            group.forEach(function (current, index) {\n                // Get the current step and the lower + upper positions.\n                var step;\n                var i;\n                var q;\n                var low = current;\n                var high = group[index + 1];\n                var newPct;\n                var pctDifference;\n                var pctPos;\n                var type;\n                var steps;\n                var realSteps;\n                var stepSize;\n                var isSteps = pips.mode === exports.PipsMode.Steps;\n                // When using 'steps' mode, use the provided steps.\n                // Otherwise, we'll step on to the next subrange.\n                if (isSteps) {\n                    step = scope_Spectrum.xNumSteps[index];\n                }\n                // Default to a 'full' step.\n                if (!step) {\n                    step = high - low;\n                }\n                // If high is undefined we are at the last subrange. Make sure it iterates once (#1088)\n                if (high === undefined) {\n                    high = low;\n                }\n                // Make sure step isn't 0, which would cause an infinite loop (#654)\n                step = Math.max(step, 0.0000001);\n                // Find all steps in the subrange.\n                for (i = low; i <= high; i = safeIncrement(i, step)) {\n                    // Get the percentage value for the current step,\n                    // calculate the size for the subrange.\n                    newPct = scope_Spectrum.toStepping(i);\n                    pctDifference = newPct - prevPct;\n                    steps = pctDifference / (pips.density || 1);\n                    realSteps = Math.round(steps);\n                    // This ratio represents the amount of percentage-space a point indicates.\n                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.\n                    // Round the percentage offset to an even number, then divide by two\n                    // to spread the offset on both sides of the range.\n                    stepSize = pctDifference / realSteps;\n                    // Divide all points evenly, adding the correct number to this subrange.\n                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.\n                    for (q = 1; q <= realSteps; q += 1) {\n                        // The ratio between the rounded value and the actual size might be ~1% off.\n                        // Correct the percentage offset by the number of points\n                        // per subrange. density = 1 will result in 100 points on the\n                        // full range, 2 for 50, 4 for 25, etc.\n                        pctPos = prevPct + q * stepSize;\n                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];\n                    }\n                    // Determine the point type.\n                    type = group.indexOf(i) > -1 ? exports.PipsType.LargeValue : isSteps ? exports.PipsType.SmallValue : exports.PipsType.NoValue;\n                    // Enforce the 'ignoreFirst' option by overwriting the type for 0.\n                    if (!index && ignoreFirst && i !== high) {\n                        type = 0;\n                    }\n                    if (!(i === high && ignoreLast)) {\n                        // Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\n                        indexes[newPct.toFixed(5)] = [i, type];\n                    }\n                    // Update the percentage count.\n                    prevPct = newPct;\n                }\n            });\n            return indexes;\n        }\n        function addMarking(spread, filterFunc, formatter) {\n            var _a, _b;\n            var element = scope_Document.createElement(\"div\");\n            var valueSizeClasses = (_a = {},\n                _a[exports.PipsType.None] = \"\",\n                _a[exports.PipsType.NoValue] = options.cssClasses.valueNormal,\n                _a[exports.PipsType.LargeValue] = options.cssClasses.valueLarge,\n                _a[exports.PipsType.SmallValue] = options.cssClasses.valueSub,\n                _a);\n            var markerSizeClasses = (_b = {},\n                _b[exports.PipsType.None] = \"\",\n                _b[exports.PipsType.NoValue] = options.cssClasses.markerNormal,\n                _b[exports.PipsType.LargeValue] = options.cssClasses.markerLarge,\n                _b[exports.PipsType.SmallValue] = options.cssClasses.markerSub,\n                _b);\n            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\n            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\n            addClass(element, options.cssClasses.pips);\n            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\n            function getClasses(type, source) {\n                var a = source === options.cssClasses.value;\n                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\n                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\n                return source + \" \" + orientationClasses[options.ort] + \" \" + sizeClasses[type];\n            }\n            function addSpread(offset, value, type) {\n                // Apply the filter function, if it is set.\n                type = filterFunc ? filterFunc(value, type) : type;\n                if (type === exports.PipsType.None) {\n                    return;\n                }\n                // Add a marker for every point\n                var node = addNodeTo(element, false);\n                node.className = getClasses(type, options.cssClasses.marker);\n                node.style[options.style] = offset + \"%\";\n                // Values are only appended for points marked '1' or '2'.\n                if (type > exports.PipsType.NoValue) {\n                    node = addNodeTo(element, false);\n                    node.className = getClasses(type, options.cssClasses.value);\n                    node.setAttribute(\"data-value\", String(value));\n                    node.style[options.style] = offset + \"%\";\n                    node.innerHTML = String(formatter.to(value));\n                }\n            }\n            // Append all points.\n            Object.keys(spread).forEach(function (offset) {\n                addSpread(offset, spread[offset][0], spread[offset][1]);\n            });\n            return element;\n        }\n        function removePips() {\n            if (scope_Pips) {\n                removeElement(scope_Pips);\n                scope_Pips = null;\n            }\n        }\n        function pips(pips) {\n            // Fix #669\n            removePips();\n            var spread = generateSpread(pips);\n            var filter = pips.filter;\n            var format = pips.format || {\n                to: function (value) {\n                    return String(Math.round(value));\n                },\n            };\n            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));\n            return scope_Pips;\n        }\n        // Shorthand for base dimensions.\n        function baseSize() {\n            var rect = scope_Base.getBoundingClientRect();\n            var alt = (\"offset\" + [\"Width\", \"Height\"][options.ort]);\n            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\n        }\n        // Handler for attaching events trough a proxy.\n        function attachEvent(events, element, callback, data) {\n            // This function can be used to 'filter' events to the slider.\n            // element is a node, not a nodeList\n            var method = function (event) {\n                var e = fixEvent(event, data.pageOffset, data.target || element);\n                // fixEvent returns false if this event has a different target\n                // when handling (multi-) touch events;\n                if (!e) {\n                    return false;\n                }\n                // doNotReject is passed by all end events to make sure released touches\n                // are not rejected, leaving the slider \"stuck\" to the cursor;\n                if (isSliderDisabled() && !data.doNotReject) {\n                    return false;\n                }\n                // Stop if an active 'tap' transition is taking place.\n                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {\n                    return false;\n                }\n                // Ignore right or middle clicks on start #454\n                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\n                    return false;\n                }\n                // Ignore right or middle clicks on start #454\n                if (data.hover && e.buttons) {\n                    return false;\n                }\n                // 'supportsPassive' is only true if a browser also supports touch-action: none in CSS.\n                // iOS safari does not, so it doesn't get to benefit from passive scrolling. iOS does support\n                // touch-action: manipulation, but that allows panning, which breaks\n                // sliders after zooming/on non-responsive pages.\n                // See: https://bugs.webkit.org/show_bug.cgi?id=133112\n                if (!supportsPassive) {\n                    e.preventDefault();\n                }\n                e.calcPoint = e.points[options.ort];\n                // Call the event handler with the event [ and additional data ].\n                callback(e, data);\n                return;\n            };\n            var methods = [];\n            // Bind a closure on the target for every event type.\n            events.split(\" \").forEach(function (eventName) {\n                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);\n                methods.push([eventName, method]);\n            });\n            return methods;\n        }\n        // Provide a clean event with standardized offset values.\n        function fixEvent(e, pageOffset, eventTarget) {\n            // Filter the event to register the type, which can be\n            // touch, mouse or pointer. Offset changes need to be\n            // made on an event specific basis.\n            var touch = e.type.indexOf(\"touch\") === 0;\n            var mouse = e.type.indexOf(\"mouse\") === 0;\n            var pointer = e.type.indexOf(\"pointer\") === 0;\n            var x = 0;\n            var y = 0;\n            // IE10 implemented pointer events with a prefix;\n            if (e.type.indexOf(\"MSPointer\") === 0) {\n                pointer = true;\n            }\n            // Erroneous events seem to be passed in occasionally on iOS/iPadOS after user finishes interacting with\n            // the slider. They appear to be of type MouseEvent, yet they don't have usual properties set. Ignore\n            // events that have no touches or buttons associated with them. (#1057, #1079, #1095)\n            if (e.type === \"mousedown\" && !e.buttons && !e.touches) {\n                return false;\n            }\n            // The only thing one handle should be concerned about is the touches that originated on top of it.\n            if (touch) {\n                // Returns true if a touch originated on the target.\n                var isTouchOnTarget = function (checkTouch) {\n                    var target = checkTouch.target;\n                    return (target === eventTarget ||\n                        eventTarget.contains(target) ||\n                        (e.composed && e.composedPath().shift() === eventTarget));\n                };\n                // In the case of touchstart events, we need to make sure there is still no more than one\n                // touch on the target so we look amongst all touches.\n                if (e.type === \"touchstart\") {\n                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);\n                    // Do not support more than one touch per handle.\n                    if (targetTouches.length > 1) {\n                        return false;\n                    }\n                    x = targetTouches[0].pageX;\n                    y = targetTouches[0].pageY;\n                }\n                else {\n                    // In the other cases, find on changedTouches is enough.\n                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);\n                    // Cancel if the target touch has not moved.\n                    if (!targetTouch) {\n                        return false;\n                    }\n                    x = targetTouch.pageX;\n                    y = targetTouch.pageY;\n                }\n            }\n            pageOffset = pageOffset || getPageOffset(scope_Document);\n            if (mouse || pointer) {\n                x = e.clientX + pageOffset.x;\n                y = e.clientY + pageOffset.y;\n            }\n            e.pageOffset = pageOffset;\n            e.points = [x, y];\n            e.cursor = mouse || pointer; // Fix #435\n            return e;\n        }\n        // Translate a coordinate in the document to a percentage on the slider\n        function calcPointToPercentage(calcPoint) {\n            var location = calcPoint - offset(scope_Base, options.ort);\n            var proposal = (location * 100) / baseSize();\n            // Clamp proposal between 0% and 100%\n            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements\n            // are used (e.g. contained handles feature)\n            proposal = limit(proposal);\n            return options.dir ? 100 - proposal : proposal;\n        }\n        // Find handle closest to a certain percentage on the slider\n        function getClosestHandle(clickedPosition) {\n            var smallestDifference = 100;\n            var handleNumber = false;\n            scope_Handles.forEach(function (handle, index) {\n                // Disabled handles are ignored\n                if (isHandleDisabled(index)) {\n                    return;\n                }\n                var handlePosition = scope_Locations[index];\n                var differenceWithThisHandle = Math.abs(handlePosition - clickedPosition);\n                // Initial state\n                var clickAtEdge = differenceWithThisHandle === 100 && smallestDifference === 100;\n                // Difference with this handle is smaller than the previously checked handle\n                var isCloser = differenceWithThisHandle < smallestDifference;\n                var isCloserAfter = differenceWithThisHandle <= smallestDifference && clickedPosition > handlePosition;\n                if (isCloser || isCloserAfter || clickAtEdge) {\n                    handleNumber = index;\n                    smallestDifference = differenceWithThisHandle;\n                }\n            });\n            return handleNumber;\n        }\n        // Fire 'end' when a mouse or pen leaves the document.\n        function documentLeave(event, data) {\n            if (event.type === \"mouseout\" &&\n                event.target.nodeName === \"HTML\" &&\n                event.relatedTarget === null) {\n                eventEnd(event, data);\n            }\n        }\n        // Handle movement on document for handle and range drag.\n        function eventMove(event, data) {\n            // Fix #498\n            // Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\n            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\n            // IE9 has .buttons and .which zero on mousemove.\n            // Firefox breaks the spec MDN defines.\n            if (navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\n                return eventEnd(event, data);\n            }\n            // Check if we are moving up or down\n            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\n            // Convert the movement into a percentage of the slider width/height\n            var proposal = (movement * 100) / data.baseSize;\n            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers, data.connect);\n        }\n        // Unbind move events on document, call callbacks.\n        function eventEnd(event, data) {\n            // The handle is no longer active, so remove the class.\n            if (data.handle) {\n                removeClass(data.handle, options.cssClasses.active);\n                scope_ActiveHandlesCount -= 1;\n            }\n            // Unbind the move and end events, which are added on 'start'.\n            data.listeners.forEach(function (c) {\n                scope_DocumentElement.removeEventListener(c[0], c[1]);\n            });\n            if (scope_ActiveHandlesCount === 0) {\n                // Remove dragging class.\n                removeClass(scope_Target, options.cssClasses.drag);\n                setZindex();\n                // Remove cursor styles and text-selection events bound to the body.\n                if (event.cursor) {\n                    scope_Body.style.cursor = \"\";\n                    scope_Body.removeEventListener(\"selectstart\", preventDefault);\n                }\n            }\n            if (options.events.smoothSteps) {\n                data.handleNumbers.forEach(function (handleNumber) {\n                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, false, false);\n                });\n                data.handleNumbers.forEach(function (handleNumber) {\n                    fireEvent(\"update\", handleNumber);\n                });\n            }\n            data.handleNumbers.forEach(function (handleNumber) {\n                fireEvent(\"change\", handleNumber);\n                fireEvent(\"set\", handleNumber);\n                fireEvent(\"end\", handleNumber);\n            });\n        }\n        // Bind move events on document.\n        function eventStart(event, data) {\n            // Ignore event if any handle is disabled\n            if (data.handleNumbers.some(isHandleDisabled)) {\n                return;\n            }\n            var handle;\n            if (data.handleNumbers.length === 1) {\n                var handleOrigin = scope_Handles[data.handleNumbers[0]];\n                handle = handleOrigin.children[0];\n                scope_ActiveHandlesCount += 1;\n                // Mark the handle as 'active' so it can be styled.\n                addClass(handle, options.cssClasses.active);\n            }\n            // A drag should never propagate up to the 'tap' event.\n            event.stopPropagation();\n            // Record the event listeners.\n            var listeners = [];\n            // Attach the move and end events.\n            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\n                // The event target has changed so we need to propagate the original one so that we keep\n                // relying on it to extract target touches.\n                target: event.target,\n                handle: handle,\n                connect: data.connect,\n                listeners: listeners,\n                startCalcPoint: event.calcPoint,\n                baseSize: baseSize(),\n                pageOffset: event.pageOffset,\n                handleNumbers: data.handleNumbers,\n                buttonsProperty: event.buttons,\n                locations: scope_Locations.slice(),\n            });\n            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\n                target: event.target,\n                handle: handle,\n                listeners: listeners,\n                doNotReject: true,\n                handleNumbers: data.handleNumbers,\n            });\n            var outEvent = attachEvent(\"mouseout\", scope_DocumentElement, documentLeave, {\n                target: event.target,\n                handle: handle,\n                listeners: listeners,\n                doNotReject: true,\n                handleNumbers: data.handleNumbers,\n            });\n            // We want to make sure we pushed the listeners in the listener list rather than creating\n            // a new one as it has already been passed to the event handlers.\n            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));\n            // Text selection isn't an issue on touch devices,\n            // so adding cursor styles can be skipped.\n            if (event.cursor) {\n                // Prevent the 'I' cursor and extend the range-drag cursor.\n                scope_Body.style.cursor = getComputedStyle(event.target).cursor;\n                // Mark the target with a dragging state.\n                if (scope_Handles.length > 1) {\n                    addClass(scope_Target, options.cssClasses.drag);\n                }\n                // Prevent text selection when dragging the handles.\n                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\n                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\n                // meaning the only holdout is iOS Safari. This doesn't matter: text selection isn't triggered there.\n                // The 'cursor' flag is false.\n                // See: http://caniuse.com/#search=selectstart\n                scope_Body.addEventListener(\"selectstart\", preventDefault, false);\n            }\n            data.handleNumbers.forEach(function (handleNumber) {\n                fireEvent(\"start\", handleNumber);\n            });\n        }\n        // Move closest handle to tapped location.\n        function eventTap(event) {\n            // The tap event shouldn't propagate up\n            event.stopPropagation();\n            var proposal = calcPointToPercentage(event.calcPoint);\n            var handleNumber = getClosestHandle(proposal);\n            // Tackle the case that all handles are 'disabled'.\n            if (handleNumber === false) {\n                return;\n            }\n            // Flag the slider as it is now in a transitional state.\n            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\n            if (!options.events.snap) {\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n            }\n            setHandle(handleNumber, proposal, true, true);\n            setZindex();\n            fireEvent(\"slide\", handleNumber, true);\n            fireEvent(\"update\", handleNumber, true);\n            if (!options.events.snap) {\n                fireEvent(\"change\", handleNumber, true);\n                fireEvent(\"set\", handleNumber, true);\n            }\n            else {\n                eventStart(event, { handleNumbers: [handleNumber] });\n            }\n        }\n        // Fires a 'hover' event for a hovered mouse/pen position.\n        function eventHover(event) {\n            var proposal = calcPointToPercentage(event.calcPoint);\n            var to = scope_Spectrum.getStep(proposal);\n            var value = scope_Spectrum.fromStepping(to);\n            Object.keys(scope_Events).forEach(function (targetEvent) {\n                if (\"hover\" === targetEvent.split(\".\")[0]) {\n                    scope_Events[targetEvent].forEach(function (callback) {\n                        callback.call(scope_Self, value);\n                    });\n                }\n            });\n        }\n        // Handles keydown on focused handles\n        // Don't move the document when pressing arrow keys on focused handles\n        function eventKeydown(event, handleNumber) {\n            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {\n                return false;\n            }\n            var horizontalKeys = [\"Left\", \"Right\"];\n            var verticalKeys = [\"Down\", \"Up\"];\n            var largeStepKeys = [\"PageDown\", \"PageUp\"];\n            var edgeKeys = [\"Home\", \"End\"];\n            if (options.dir && !options.ort) {\n                // On an right-to-left slider, the left and right keys act inverted\n                horizontalKeys.reverse();\n            }\n            else if (options.ort && !options.dir) {\n                // On a top-to-bottom slider, the up and down keys act inverted\n                verticalKeys.reverse();\n                largeStepKeys.reverse();\n            }\n            // Strip \"Arrow\" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n            var key = event.key.replace(\"Arrow\", \"\");\n            var isLargeDown = key === largeStepKeys[0];\n            var isLargeUp = key === largeStepKeys[1];\n            var isDown = key === verticalKeys[0] || key === horizontalKeys[0] || isLargeDown;\n            var isUp = key === verticalKeys[1] || key === horizontalKeys[1] || isLargeUp;\n            var isMin = key === edgeKeys[0];\n            var isMax = key === edgeKeys[1];\n            if (!isDown && !isUp && !isMin && !isMax) {\n                return true;\n            }\n            event.preventDefault();\n            var to;\n            if (isUp || isDown) {\n                var direction = isDown ? 0 : 1;\n                var steps = getNextStepsForHandle(handleNumber);\n                var step = steps[direction];\n                // At the edge of a slider, do nothing\n                if (step === null) {\n                    return false;\n                }\n                // No step set, use the default of 10% of the sub-range\n                if (step === false) {\n                    step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, options.keyboardDefaultStep);\n                }\n                if (isLargeUp || isLargeDown) {\n                    step *= options.keyboardPageMultiplier;\n                }\n                else {\n                    step *= options.keyboardMultiplier;\n                }\n                // Step over zero-length ranges (#948);\n                step = Math.max(step, 0.0000001);\n                // Decrement for down steps\n                step = (isDown ? -1 : 1) * step;\n                to = scope_Values[handleNumber] + step;\n            }\n            else if (isMax) {\n                // End key\n                to = options.spectrum.xVal[options.spectrum.xVal.length - 1];\n            }\n            else {\n                // Home key\n                to = options.spectrum.xVal[0];\n            }\n            setHandle(handleNumber, scope_Spectrum.toStepping(to), true, true);\n            fireEvent(\"slide\", handleNumber);\n            fireEvent(\"update\", handleNumber);\n            fireEvent(\"change\", handleNumber);\n            fireEvent(\"set\", handleNumber);\n            return false;\n        }\n        // Attach events to several slider parts.\n        function bindSliderEvents(behaviour) {\n            // Attach the standard drag event to the handles.\n            if (!behaviour.fixed) {\n                scope_Handles.forEach(function (handle, index) {\n                    // These events are only bound to the visual handle\n                    // element, not the 'real' origin element.\n                    attachEvent(actions.start, handle.children[0], eventStart, {\n                        handleNumbers: [index],\n                    });\n                });\n            }\n            // Attach the tap event to the slider base.\n            if (behaviour.tap) {\n                attachEvent(actions.start, scope_Base, eventTap, {});\n            }\n            // Fire hover events\n            if (behaviour.hover) {\n                attachEvent(actions.move, scope_Base, eventHover, {\n                    hover: true,\n                });\n            }\n            // Make the range draggable.\n            if (behaviour.drag) {\n                scope_Connects.forEach(function (connect, index) {\n                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {\n                        return;\n                    }\n                    var handleBefore = scope_Handles[index - 1];\n                    var handleAfter = scope_Handles[index];\n                    var eventHolders = [connect];\n                    var handlesToDrag = [handleBefore, handleAfter];\n                    var handleNumbersToDrag = [index - 1, index];\n                    addClass(connect, options.cssClasses.draggable);\n                    // When the range is fixed, the entire range can\n                    // be dragged by the handles. The handle in the first\n                    // origin will propagate the start event upward,\n                    // but it needs to be bound manually on the other.\n                    if (behaviour.fixed) {\n                        eventHolders.push(handleBefore.children[0]);\n                        eventHolders.push(handleAfter.children[0]);\n                    }\n                    if (behaviour.dragAll) {\n                        handlesToDrag = scope_Handles;\n                        handleNumbersToDrag = scope_HandleNumbers;\n                    }\n                    eventHolders.forEach(function (eventHolder) {\n                        attachEvent(actions.start, eventHolder, eventStart, {\n                            handles: handlesToDrag,\n                            handleNumbers: handleNumbersToDrag,\n                            connect: connect,\n                        });\n                    });\n                });\n            }\n        }\n        // Attach an event to this slider, possibly including a namespace\n        function bindEvent(namespacedEvent, callback) {\n            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\n            scope_Events[namespacedEvent].push(callback);\n            // If the event bound is 'update,' fire it immediately for all handles.\n            if (namespacedEvent.split(\".\")[0] === \"update\") {\n                scope_Handles.forEach(function (a, index) {\n                    fireEvent(\"update\", index);\n                });\n            }\n        }\n        function isInternalNamespace(namespace) {\n            return namespace === INTERNAL_EVENT_NS.aria || namespace === INTERNAL_EVENT_NS.tooltips;\n        }\n        // Undo attachment of event\n        function removeEvent(namespacedEvent) {\n            var event = namespacedEvent && namespacedEvent.split(\".\")[0];\n            var namespace = event ? namespacedEvent.substring(event.length) : namespacedEvent;\n            Object.keys(scope_Events).forEach(function (bind) {\n                var tEvent = bind.split(\".\")[0];\n                var tNamespace = bind.substring(tEvent.length);\n                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\n                    // only delete protected internal event if intentional\n                    if (!isInternalNamespace(tNamespace) || namespace === tNamespace) {\n                        delete scope_Events[bind];\n                    }\n                }\n            });\n        }\n        // External event handling\n        function fireEvent(eventName, handleNumber, tap) {\n            Object.keys(scope_Events).forEach(function (targetEvent) {\n                var eventType = targetEvent.split(\".\")[0];\n                if (eventName === eventType) {\n                    scope_Events[targetEvent].forEach(function (callback) {\n                        callback.call(\n                        // Use the slider public API as the scope ('this')\n                        scope_Self, \n                        // Return values as array, so arg_1[arg_2] is always valid.\n                        scope_Values.map(options.format.to), \n                        // Handle index, 0 or 1\n                        handleNumber, \n                        // Un-formatted slider values\n                        scope_Values.slice(), \n                        // Event is fired by tap, true or false\n                        tap || false, \n                        // Left offset of the handle, in relation to the slider\n                        scope_Locations.slice(), \n                        // add the slider public API to an accessible parameter when this is unavailable\n                        scope_Self);\n                    });\n                }\n            });\n        }\n        // Split out the handle positioning logic so the Move event can use it, too\n        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue, smoothSteps) {\n            var distance;\n            // For sliders with multiple handles, limit movement to the other handle.\n            // Apply the margin option by adding it to the handle positions.\n            if (scope_Handles.length > 1 && !options.events.unconstrained) {\n                if (lookBackward && handleNumber > 0) {\n                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.margin, false);\n                    to = Math.max(to, distance);\n                }\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\n                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.margin, true);\n                    to = Math.min(to, distance);\n                }\n            }\n            // The limit option has the opposite effect, limiting handles to a\n            // maximum distance from another. Limit must be > 0, as otherwise\n            // handles would be unmovable.\n            if (scope_Handles.length > 1 && options.limit) {\n                if (lookBackward && handleNumber > 0) {\n                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber - 1], options.limit, false);\n                    to = Math.min(to, distance);\n                }\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\n                    distance = scope_Spectrum.getAbsoluteDistance(reference[handleNumber + 1], options.limit, true);\n                    to = Math.max(to, distance);\n                }\n            }\n            // The padding option keeps the handles a certain distance from the\n            // edges of the slider. Padding must be > 0.\n            if (options.padding) {\n                if (handleNumber === 0) {\n                    distance = scope_Spectrum.getAbsoluteDistance(0, options.padding[0], false);\n                    to = Math.max(to, distance);\n                }\n                if (handleNumber === scope_Handles.length - 1) {\n                    distance = scope_Spectrum.getAbsoluteDistance(100, options.padding[1], true);\n                    to = Math.min(to, distance);\n                }\n            }\n            if (!smoothSteps) {\n                to = scope_Spectrum.getStep(to);\n            }\n            // Limit percentage to the 0 - 100 range\n            to = limit(to);\n            // Return false if handle can't move\n            if (to === reference[handleNumber] && !getValue) {\n                return false;\n            }\n            return to;\n        }\n        // Uses slider orientation to create CSS rules. a = base value;\n        function inRuleOrder(v, a) {\n            var o = options.ort;\n            return (o ? a : v) + \", \" + (o ? v : a);\n        }\n        // Moves handle(s) by a percentage\n        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\n        function moveHandles(upward, proposal, locations, handleNumbers, connect) {\n            var proposals = locations.slice();\n            // Store first handle now, so we still have it in case handleNumbers is reversed\n            var firstHandle = handleNumbers[0];\n            var smoothSteps = options.events.smoothSteps;\n            var b = [!upward, upward];\n            var f = [upward, !upward];\n            // Copy handleNumbers so we don't change the dataset\n            handleNumbers = handleNumbers.slice();\n            // Check to see which handle is 'leading'.\n            // If that one can't move the second can't either.\n            if (upward) {\n                handleNumbers.reverse();\n            }\n            // Step 1: get the maximum percentage that any of the handles can move\n            if (handleNumbers.length > 1) {\n                handleNumbers.forEach(function (handleNumber, o) {\n                    var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false, smoothSteps);\n                    // Stop if one of the handles can't move.\n                    if (to === false) {\n                        proposal = 0;\n                    }\n                    else {\n                        proposal = to - proposals[handleNumber];\n                        proposals[handleNumber] = to;\n                    }\n                });\n            }\n            // If using one handle, check backward AND forward\n            else {\n                b = f = [true];\n            }\n            var state = false;\n            // Step 2: Try to set the handles with the found percentage\n            handleNumbers.forEach(function (handleNumber, o) {\n                state =\n                    setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o], false, smoothSteps) || state;\n            });\n            // Step 3: If a handle moved, fire events\n            if (state) {\n                handleNumbers.forEach(function (handleNumber) {\n                    fireEvent(\"update\", handleNumber);\n                    fireEvent(\"slide\", handleNumber);\n                });\n                // If target is a connect, then fire drag event\n                if (connect != undefined) {\n                    fireEvent(\"drag\", firstHandle);\n                }\n            }\n        }\n        // Takes a base value and an offset. This offset is used for the connect bar size.\n        // In the initial design for this feature, the origin element was 1% wide.\n        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature\n        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223\n        function transformDirection(a, b) {\n            return options.dir ? 100 - a - b : a;\n        }\n        // Updates scope_Locations and scope_Values, updates visual state\n        function updateHandlePosition(handleNumber, to) {\n            // Update locations.\n            scope_Locations[handleNumber] = to;\n            // Convert the value to the slider stepping/range.\n            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\n            var translation = transformDirection(to, 0) - scope_DirOffset;\n            var translateRule = \"translate(\" + inRuleOrder(translation + \"%\", \"0\") + \")\";\n            scope_Handles[handleNumber].style[options.transformRule] = translateRule;\n            updateConnect(handleNumber);\n            updateConnect(handleNumber + 1);\n        }\n        // Handles before the slider middle are stacked later = higher,\n        // Handles after the middle later is lower\n        // [[7] [8] .......... | .......... [5] [4]\n        function setZindex() {\n            scope_HandleNumbers.forEach(function (handleNumber) {\n                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\n                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);\n                scope_Handles[handleNumber].style.zIndex = String(zIndex);\n            });\n        }\n        // Test suggested values and apply margin, step.\n        // if exactInput is true, don't run checkHandlePosition, then the handle can be placed in between steps (#436)\n        function setHandle(handleNumber, to, lookBackward, lookForward, exactInput, smoothSteps) {\n            if (!exactInput) {\n                to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false, smoothSteps);\n            }\n            if (to === false) {\n                return false;\n            }\n            updateHandlePosition(handleNumber, to);\n            return true;\n        }\n        // Updates style attribute for connect nodes\n        function updateConnect(index) {\n            // Skip connects set to false\n            if (!scope_Connects[index]) {\n                return;\n            }\n            var l = 0;\n            var h = 100;\n            if (index !== 0) {\n                l = scope_Locations[index - 1];\n            }\n            if (index !== scope_Connects.length - 1) {\n                h = scope_Locations[index];\n            }\n            // We use two rules:\n            // 'translate' to change the left/top offset;\n            // 'scale' to change the width of the element;\n            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)\n            var connectWidth = h - l;\n            var translateRule = \"translate(\" + inRuleOrder(transformDirection(l, connectWidth) + \"%\", \"0\") + \")\";\n            var scaleRule = \"scale(\" + inRuleOrder(connectWidth / 100, \"1\") + \")\";\n            scope_Connects[index].style[options.transformRule] =\n                translateRule + \" \" + scaleRule;\n        }\n        // Parses value passed to .set method. Returns current value if not parse-able.\n        function resolveToValue(to, handleNumber) {\n            // Setting with null indicates an 'ignore'.\n            // Inputting 'false' is invalid.\n            if (to === null || to === false || to === undefined) {\n                return scope_Locations[handleNumber];\n            }\n            // If a formatted number was passed, attempt to decode it.\n            if (typeof to === \"number\") {\n                to = String(to);\n            }\n            to = options.format.from(to);\n            if (to !== false) {\n                to = scope_Spectrum.toStepping(to);\n            }\n            // If parsing the number failed, use the current value.\n            if (to === false || isNaN(to)) {\n                return scope_Locations[handleNumber];\n            }\n            return to;\n        }\n        // Set the slider value.\n        function valueSet(input, fireSetEvent, exactInput) {\n            var values = asArray(input);\n            var isInit = scope_Locations[0] === undefined;\n            // Event fires by default\n            fireSetEvent = fireSetEvent === undefined ? true : fireSetEvent;\n            // Animation is optional.\n            // Make sure the initial values were set before using animated placement.\n            if (options.animate && !isInit) {\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\n            }\n            // First pass, without lookAhead but with lookBackward. Values are set from left to right.\n            scope_HandleNumbers.forEach(function (handleNumber) {\n                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false, exactInput);\n            });\n            var i = scope_HandleNumbers.length === 1 ? 0 : 1;\n            // Spread handles evenly across the slider if the range has no size (min=max)\n            if (isInit && scope_Spectrum.hasNoSize()) {\n                exactInput = true;\n                scope_Locations[0] = 0;\n                if (scope_HandleNumbers.length > 1) {\n                    var space_1 = 100 / (scope_HandleNumbers.length - 1);\n                    scope_HandleNumbers.forEach(function (handleNumber) {\n                        scope_Locations[handleNumber] = handleNumber * space_1;\n                    });\n                }\n            }\n            // Secondary passes. Now that all base values are set, apply constraints.\n            // Iterate all handles to ensure constraints are applied for the entire slider (Issue #1009)\n            for (; i < scope_HandleNumbers.length; ++i) {\n                scope_HandleNumbers.forEach(function (handleNumber) {\n                    setHandle(handleNumber, scope_Locations[handleNumber], true, true, exactInput);\n                });\n            }\n            setZindex();\n            scope_HandleNumbers.forEach(function (handleNumber) {\n                fireEvent(\"update\", handleNumber);\n                // Fire the event only for handles that received a new value, as per #579\n                if (values[handleNumber] !== null && fireSetEvent) {\n                    fireEvent(\"set\", handleNumber);\n                }\n            });\n        }\n        // Reset slider to initial values\n        function valueReset(fireSetEvent) {\n            valueSet(options.start, fireSetEvent);\n        }\n        // Set value for a single handle\n        function valueSetHandle(handleNumber, value, fireSetEvent, exactInput) {\n            // Ensure numeric input\n            handleNumber = Number(handleNumber);\n            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {\n                throw new Error(\"noUiSlider: invalid handle number, got: \" + handleNumber);\n            }\n            // Look both backward and forward, since we don't want this handle to \"push\" other handles (#960);\n            // The exactInput argument can be used to ignore slider stepping (#436)\n            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true, exactInput);\n            fireEvent(\"update\", handleNumber);\n            if (fireSetEvent) {\n                fireEvent(\"set\", handleNumber);\n            }\n        }\n        // Get the slider value.\n        function valueGet(unencoded) {\n            if (unencoded === void 0) { unencoded = false; }\n            if (unencoded) {\n                // return a copy of the raw values\n                return scope_Values.length === 1 ? scope_Values[0] : scope_Values.slice(0);\n            }\n            var values = scope_Values.map(options.format.to);\n            // If only one handle is used, return a single value.\n            if (values.length === 1) {\n                return values[0];\n            }\n            return values;\n        }\n        // Removes classes from the root and empties it.\n        function destroy() {\n            // remove protected internal listeners\n            removeEvent(INTERNAL_EVENT_NS.aria);\n            removeEvent(INTERNAL_EVENT_NS.tooltips);\n            Object.keys(options.cssClasses).forEach(function (key) {\n                removeClass(scope_Target, options.cssClasses[key]);\n            });\n            while (scope_Target.firstChild) {\n                scope_Target.removeChild(scope_Target.firstChild);\n            }\n            delete scope_Target.noUiSlider;\n        }\n        function getNextStepsForHandle(handleNumber) {\n            var location = scope_Locations[handleNumber];\n            var nearbySteps = scope_Spectrum.getNearbySteps(location);\n            var value = scope_Values[handleNumber];\n            var increment = nearbySteps.thisStep.step;\n            var decrement = null;\n            // If snapped, directly use defined step value\n            if (options.snap) {\n                return [\n                    value - nearbySteps.stepBefore.startValue || null,\n                    nearbySteps.stepAfter.startValue - value || null,\n                ];\n            }\n            // If the next value in this step moves into the next step,\n            // the increment is the start of the next step - the current value\n            if (increment !== false) {\n                if (value + increment > nearbySteps.stepAfter.startValue) {\n                    increment = nearbySteps.stepAfter.startValue - value;\n                }\n            }\n            // If the value is beyond the starting point\n            if (value > nearbySteps.thisStep.startValue) {\n                decrement = nearbySteps.thisStep.step;\n            }\n            else if (nearbySteps.stepBefore.step === false) {\n                decrement = false;\n            }\n            // If a handle is at the start of a step, it always steps back into the previous step first\n            else {\n                decrement = value - nearbySteps.stepBefore.highestStep;\n            }\n            // Now, if at the slider edges, there is no in/decrement\n            if (location === 100) {\n                increment = null;\n            }\n            else if (location === 0) {\n                decrement = null;\n            }\n            // As per #391, the comparison for the decrement step can have some rounding issues.\n            var stepDecimals = scope_Spectrum.countStepDecimals();\n            // Round per #391\n            if (increment !== null && increment !== false) {\n                increment = Number(increment.toFixed(stepDecimals));\n            }\n            if (decrement !== null && decrement !== false) {\n                decrement = Number(decrement.toFixed(stepDecimals));\n            }\n            return [decrement, increment];\n        }\n        // Get the current step size for the slider.\n        function getNextSteps() {\n            return scope_HandleNumbers.map(getNextStepsForHandle);\n        }\n        // Updatable: margin, limit, padding, step, range, animate, snap\n        function updateOptions(optionsToUpdate, fireSetEvent) {\n            // Spectrum is created using the range, snap, direction and step options.\n            // 'snap' and 'step' can be updated.\n            // If 'snap' and 'step' are not passed, they should remain unchanged.\n            var v = valueGet();\n            var updateAble = [\n                \"margin\",\n                \"limit\",\n                \"padding\",\n                \"range\",\n                \"animate\",\n                \"snap\",\n                \"step\",\n                \"format\",\n                \"pips\",\n                \"tooltips\",\n            ];\n            // Only change options that we're actually passed to update.\n            updateAble.forEach(function (name) {\n                // Check for undefined. null removes the value.\n                if (optionsToUpdate[name] !== undefined) {\n                    originalOptions[name] = optionsToUpdate[name];\n                }\n            });\n            var newOptions = testOptions(originalOptions);\n            // Load new options into the slider state\n            updateAble.forEach(function (name) {\n                if (optionsToUpdate[name] !== undefined) {\n                    options[name] = newOptions[name];\n                }\n            });\n            scope_Spectrum = newOptions.spectrum;\n            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\n            options.margin = newOptions.margin;\n            options.limit = newOptions.limit;\n            options.padding = newOptions.padding;\n            // Update pips, removes existing.\n            if (options.pips) {\n                pips(options.pips);\n            }\n            else {\n                removePips();\n            }\n            // Update tooltips, removes existing.\n            if (options.tooltips) {\n                tooltips();\n            }\n            else {\n                removeTooltips();\n            }\n            // Invalidate the current positioning so valueSet forces an update.\n            scope_Locations = [];\n            valueSet(isSet(optionsToUpdate.start) ? optionsToUpdate.start : v, fireSetEvent);\n        }\n        // Initialization steps\n        function setupSlider() {\n            // Create the base element, initialize HTML and set classes.\n            // Add handles and connect elements.\n            scope_Base = addSlider(scope_Target);\n            addElements(options.connect, scope_Base);\n            // Attach user events.\n            bindSliderEvents(options.events);\n            // Use the public value method to set the start values.\n            valueSet(options.start);\n            if (options.pips) {\n                pips(options.pips);\n            }\n            if (options.tooltips) {\n                tooltips();\n            }\n            aria();\n        }\n        setupSlider();\n        var scope_Self = {\n            destroy: destroy,\n            steps: getNextSteps,\n            on: bindEvent,\n            off: removeEvent,\n            get: valueGet,\n            set: valueSet,\n            setHandle: valueSetHandle,\n            reset: valueReset,\n            disable: disable,\n            enable: enable,\n            // Exposed for unit testing, don't use this in your application.\n            __moveHandles: function (upward, proposal, handleNumbers) {\n                moveHandles(upward, proposal, scope_Locations, handleNumbers);\n            },\n            options: originalOptions,\n            updateOptions: updateOptions,\n            target: scope_Target,\n            removePips: removePips,\n            removeTooltips: removeTooltips,\n            getPositions: function () {\n                return scope_Locations.slice();\n            },\n            getTooltips: function () {\n                return scope_Tooltips;\n            },\n            getOrigins: function () {\n                return scope_Handles;\n            },\n            pips: pips, // Issue #594\n        };\n        return scope_Self;\n    }\n    // Run the standard initializer\n    function initialize(target, originalOptions) {\n        if (!target || !target.nodeName) {\n            throw new Error(\"noUiSlider: create requires a single element, got: \" + target);\n        }\n        // Throw an error if the slider was already initialized.\n        if (target.noUiSlider) {\n            throw new Error(\"noUiSlider: Slider was already initialized.\");\n        }\n        // Test the options and create the slider environment;\n        var options = testOptions(originalOptions);\n        var api = scope(target, options, originalOptions);\n        target.noUiSlider = api;\n        return api;\n    }\n    var nouislider = {\n        // Exposed for unit testing, don't use this in your application.\n        __spectrum: Spectrum,\n        // A reference to the default classes, allows global changes.\n        // Use the cssClasses option for changes to one slider.\n        cssClasses: cssClasses,\n        create: initialize,\n    };\n\n    exports.create = initialize;\n    exports.cssClasses = cssClasses;\n    exports[\"default\"] = nouislider;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","/**\n * Swiper 10.0.4\n * Most modern mobile touch slider and framework with hardware accelerated transitions\n * https://swiperjs.com\n *\n * Copyright 2014-2023 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: July 8, 2023\n */\n\nvar Swiper = (function () {\n  'use strict';\n\n  /**\n   * SSR Window 4.0.2\n   * Better handling for window object in SSR environment\n   * https://github.com/nolimits4web/ssr-window\n   *\n   * Copyright 2021, Vladimir Kharlampidi\n   *\n   * Licensed under MIT\n   *\n   * Released on: December 13, 2021\n   */\n  /* eslint-disable no-param-reassign */\n  function isObject$1(obj) {\n    return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;\n  }\n  function extend$1(target, src) {\n    if (target === void 0) {\n      target = {};\n    }\n    if (src === void 0) {\n      src = {};\n    }\n    Object.keys(src).forEach(key => {\n      if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {\n        extend$1(target[key], src[key]);\n      }\n    });\n  }\n  const ssrDocument = {\n    body: {},\n    addEventListener() {},\n    removeEventListener() {},\n    activeElement: {\n      blur() {},\n      nodeName: ''\n    },\n    querySelector() {\n      return null;\n    },\n    querySelectorAll() {\n      return [];\n    },\n    getElementById() {\n      return null;\n    },\n    createEvent() {\n      return {\n        initEvent() {}\n      };\n    },\n    createElement() {\n      return {\n        children: [],\n        childNodes: [],\n        style: {},\n        setAttribute() {},\n        getElementsByTagName() {\n          return [];\n        }\n      };\n    },\n    createElementNS() {\n      return {};\n    },\n    importNode() {\n      return null;\n    },\n    location: {\n      hash: '',\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      pathname: '',\n      protocol: '',\n      search: ''\n    }\n  };\n  function getDocument() {\n    const doc = typeof document !== 'undefined' ? document : {};\n    extend$1(doc, ssrDocument);\n    return doc;\n  }\n  const ssrWindow = {\n    document: ssrDocument,\n    navigator: {\n      userAgent: ''\n    },\n    location: {\n      hash: '',\n      host: '',\n      hostname: '',\n      href: '',\n      origin: '',\n      pathname: '',\n      protocol: '',\n      search: ''\n    },\n    history: {\n      replaceState() {},\n      pushState() {},\n      go() {},\n      back() {}\n    },\n    CustomEvent: function CustomEvent() {\n      return this;\n    },\n    addEventListener() {},\n    removeEventListener() {},\n    getComputedStyle() {\n      return {\n        getPropertyValue() {\n          return '';\n        }\n      };\n    },\n    Image() {},\n    Date() {},\n    screen: {},\n    setTimeout() {},\n    clearTimeout() {},\n    matchMedia() {\n      return {};\n    },\n    requestAnimationFrame(callback) {\n      if (typeof setTimeout === 'undefined') {\n        callback();\n        return null;\n      }\n      return setTimeout(callback, 0);\n    },\n    cancelAnimationFrame(id) {\n      if (typeof setTimeout === 'undefined') {\n        return;\n      }\n      clearTimeout(id);\n    }\n  };\n  function getWindow() {\n    const win = typeof window !== 'undefined' ? window : {};\n    extend$1(win, ssrWindow);\n    return win;\n  }\n\n  function deleteProps(obj) {\n    const object = obj;\n    Object.keys(object).forEach(key => {\n      try {\n        object[key] = null;\n      } catch (e) {\n        // no getter for object\n      }\n      try {\n        delete object[key];\n      } catch (e) {\n        // something got wrong\n      }\n    });\n  }\n  function nextTick(callback, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n    return setTimeout(callback, delay);\n  }\n  function now() {\n    return Date.now();\n  }\n  function getComputedStyle$1(el) {\n    const window = getWindow();\n    let style;\n    if (window.getComputedStyle) {\n      style = window.getComputedStyle(el, null);\n    }\n    if (!style && el.currentStyle) {\n      style = el.currentStyle;\n    }\n    if (!style) {\n      style = el.style;\n    }\n    return style;\n  }\n  function getTranslate(el, axis) {\n    if (axis === void 0) {\n      axis = 'x';\n    }\n    const window = getWindow();\n    let matrix;\n    let curTransform;\n    let transformMatrix;\n    const curStyle = getComputedStyle$1(el);\n    if (window.WebKitCSSMatrix) {\n      curTransform = curStyle.transform || curStyle.webkitTransform;\n      if (curTransform.split(',').length > 6) {\n        curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');\n      }\n      // Some old versions of Webkit choke when 'none' is passed; pass\n      // empty string instead in this case\n      transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);\n    } else {\n      transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');\n      matrix = transformMatrix.toString().split(',');\n    }\n    if (axis === 'x') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[4]);\n    }\n    if (axis === 'y') {\n      // Latest Chrome and webkits Fix\n      if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;\n      // Crazy IE10 Matrix\n      else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);\n      // Normal Browsers\n      else curTransform = parseFloat(matrix[5]);\n    }\n    return curTransform || 0;\n  }\n  function isObject(o) {\n    return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';\n  }\n  function isNode(node) {\n    // eslint-disable-next-line\n    if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {\n      return node instanceof HTMLElement;\n    }\n    return node && (node.nodeType === 1 || node.nodeType === 11);\n  }\n  function extend() {\n    const to = Object(arguments.length <= 0 ? undefined : arguments[0]);\n    const noExtend = ['__proto__', 'constructor', 'prototype'];\n    for (let i = 1; i < arguments.length; i += 1) {\n      const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {\n        const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);\n        for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {\n          const nextKey = keysArray[nextIndex];\n          const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined && desc.enumerable) {\n            if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n              if (nextSource[nextKey].__swiper__) {\n                to[nextKey] = nextSource[nextKey];\n              } else {\n                extend(to[nextKey], nextSource[nextKey]);\n              }\n            } else if (!isObject(to[nextKey]) && isObject(nextSource[nextKey])) {\n              to[nextKey] = {};\n              if (nextSource[nextKey].__swiper__) {\n                to[nextKey] = nextSource[nextKey];\n              } else {\n                extend(to[nextKey], nextSource[nextKey]);\n              }\n            } else {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n    }\n    return to;\n  }\n  function setCSSProperty(el, varName, varValue) {\n    el.style.setProperty(varName, varValue);\n  }\n  function animateCSSModeScroll(_ref) {\n    let {\n      swiper,\n      targetPosition,\n      side\n    } = _ref;\n    const window = getWindow();\n    const startPosition = -swiper.translate;\n    let startTime = null;\n    let time;\n    const duration = swiper.params.speed;\n    swiper.wrapperEl.style.scrollSnapType = 'none';\n    window.cancelAnimationFrame(swiper.cssModeFrameID);\n    const dir = targetPosition > startPosition ? 'next' : 'prev';\n    const isOutOfBound = (current, target) => {\n      return dir === 'next' && current >= target || dir === 'prev' && current <= target;\n    };\n    const animate = () => {\n      time = new Date().getTime();\n      if (startTime === null) {\n        startTime = time;\n      }\n      const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);\n      const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;\n      let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);\n      if (isOutOfBound(currentPosition, targetPosition)) {\n        currentPosition = targetPosition;\n      }\n      swiper.wrapperEl.scrollTo({\n        [side]: currentPosition\n      });\n      if (isOutOfBound(currentPosition, targetPosition)) {\n        swiper.wrapperEl.style.overflow = 'hidden';\n        swiper.wrapperEl.style.scrollSnapType = '';\n        setTimeout(() => {\n          swiper.wrapperEl.style.overflow = '';\n          swiper.wrapperEl.scrollTo({\n            [side]: currentPosition\n          });\n        });\n        window.cancelAnimationFrame(swiper.cssModeFrameID);\n        return;\n      }\n      swiper.cssModeFrameID = window.requestAnimationFrame(animate);\n    };\n    animate();\n  }\n  function getSlideTransformEl(slideEl) {\n    return slideEl.querySelector('.swiper-slide-transform') || slideEl.shadowRoot && slideEl.shadowRoot.querySelector('.swiper-slide-transform') || slideEl;\n  }\n  function elementChildren(element, selector) {\n    if (selector === void 0) {\n      selector = '';\n    }\n    return [...element.children].filter(el => el.matches(selector));\n  }\n  function createElement(tag, classes) {\n    if (classes === void 0) {\n      classes = [];\n    }\n    const el = document.createElement(tag);\n    el.classList.add(...(Array.isArray(classes) ? classes : [classes]));\n    return el;\n  }\n  function elementOffset(el) {\n    const window = getWindow();\n    const document = getDocument();\n    const box = el.getBoundingClientRect();\n    const body = document.body;\n    const clientTop = el.clientTop || body.clientTop || 0;\n    const clientLeft = el.clientLeft || body.clientLeft || 0;\n    const scrollTop = el === window ? window.scrollY : el.scrollTop;\n    const scrollLeft = el === window ? window.scrollX : el.scrollLeft;\n    return {\n      top: box.top + scrollTop - clientTop,\n      left: box.left + scrollLeft - clientLeft\n    };\n  }\n  function elementPrevAll(el, selector) {\n    const prevEls = [];\n    while (el.previousElementSibling) {\n      const prev = el.previousElementSibling; // eslint-disable-line\n      if (selector) {\n        if (prev.matches(selector)) prevEls.push(prev);\n      } else prevEls.push(prev);\n      el = prev;\n    }\n    return prevEls;\n  }\n  function elementNextAll(el, selector) {\n    const nextEls = [];\n    while (el.nextElementSibling) {\n      const next = el.nextElementSibling; // eslint-disable-line\n      if (selector) {\n        if (next.matches(selector)) nextEls.push(next);\n      } else nextEls.push(next);\n      el = next;\n    }\n    return nextEls;\n  }\n  function elementStyle(el, prop) {\n    const window = getWindow();\n    return window.getComputedStyle(el, null).getPropertyValue(prop);\n  }\n  function elementIndex(el) {\n    let child = el;\n    let i;\n    if (child) {\n      i = 0;\n      // eslint-disable-next-line\n      while ((child = child.previousSibling) !== null) {\n        if (child.nodeType === 1) i += 1;\n      }\n      return i;\n    }\n    return undefined;\n  }\n  function elementParents(el, selector) {\n    const parents = []; // eslint-disable-line\n    let parent = el.parentElement; // eslint-disable-line\n    while (parent) {\n      if (selector) {\n        if (parent.matches(selector)) parents.push(parent);\n      } else {\n        parents.push(parent);\n      }\n      parent = parent.parentElement;\n    }\n    return parents;\n  }\n  function elementTransitionEnd(el, callback) {\n    function fireCallBack(e) {\n      if (e.target !== el) return;\n      callback.call(el, e);\n      el.removeEventListener('transitionend', fireCallBack);\n    }\n    if (callback) {\n      el.addEventListener('transitionend', fireCallBack);\n    }\n  }\n  function elementOuterSize(el, size, includeMargins) {\n    const window = getWindow();\n    if (includeMargins) {\n      return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));\n    }\n    return el.offsetWidth;\n  }\n\n  let support;\n  function calcSupport() {\n    const window = getWindow();\n    const document = getDocument();\n    return {\n      smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,\n      touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)\n    };\n  }\n  function getSupport() {\n    if (!support) {\n      support = calcSupport();\n    }\n    return support;\n  }\n\n  let deviceCached;\n  function calcDevice(_temp) {\n    let {\n      userAgent\n    } = _temp === void 0 ? {} : _temp;\n    const support = getSupport();\n    const window = getWindow();\n    const platform = window.navigator.platform;\n    const ua = userAgent || window.navigator.userAgent;\n    const device = {\n      ios: false,\n      android: false\n    };\n    const screenWidth = window.screen.width;\n    const screenHeight = window.screen.height;\n    const android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/); // eslint-disable-line\n    let ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n    const ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n    const iphone = !ipad && ua.match(/(iPhone\\sOS|iOS)\\s([\\d_]+)/);\n    const windows = platform === 'Win32';\n    let macos = platform === 'MacIntel';\n\n    // iPadOs 13 fix\n    const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];\n    if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {\n      ipad = ua.match(/(Version)\\/([\\d.]+)/);\n      if (!ipad) ipad = [0, 1, '13_0_0'];\n      macos = false;\n    }\n\n    // Android\n    if (android && !windows) {\n      device.os = 'android';\n      device.android = true;\n    }\n    if (ipad || iphone || ipod) {\n      device.os = 'ios';\n      device.ios = true;\n    }\n\n    // Export object\n    return device;\n  }\n  function getDevice(overrides) {\n    if (overrides === void 0) {\n      overrides = {};\n    }\n    if (!deviceCached) {\n      deviceCached = calcDevice(overrides);\n    }\n    return deviceCached;\n  }\n\n  let browser;\n  function calcBrowser() {\n    const window = getWindow();\n    let needPerspectiveFix = false;\n    function isSafari() {\n      const ua = window.navigator.userAgent.toLowerCase();\n      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;\n    }\n    if (isSafari()) {\n      const ua = String(window.navigator.userAgent);\n      if (ua.includes('Version/')) {\n        const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));\n        needPerspectiveFix = major < 16 || major === 16 && minor < 2;\n      }\n    }\n    return {\n      isSafari: needPerspectiveFix || isSafari(),\n      needPerspectiveFix,\n      isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)\n    };\n  }\n  function getBrowser() {\n    if (!browser) {\n      browser = calcBrowser();\n    }\n    return browser;\n  }\n\n  function Resize(_ref) {\n    let {\n      swiper,\n      on,\n      emit\n    } = _ref;\n    const window = getWindow();\n    let observer = null;\n    let animationFrame = null;\n    const resizeHandler = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      emit('beforeResize');\n      emit('resize');\n    };\n    const createObserver = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      observer = new ResizeObserver(entries => {\n        animationFrame = window.requestAnimationFrame(() => {\n          const {\n            width,\n            height\n          } = swiper;\n          let newWidth = width;\n          let newHeight = height;\n          entries.forEach(_ref2 => {\n            let {\n              contentBoxSize,\n              contentRect,\n              target\n            } = _ref2;\n            if (target && target !== swiper.el) return;\n            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;\n            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;\n          });\n          if (newWidth !== width || newHeight !== height) {\n            resizeHandler();\n          }\n        });\n      });\n      observer.observe(swiper.el);\n    };\n    const removeObserver = () => {\n      if (animationFrame) {\n        window.cancelAnimationFrame(animationFrame);\n      }\n      if (observer && observer.unobserve && swiper.el) {\n        observer.unobserve(swiper.el);\n        observer = null;\n      }\n    };\n    const orientationChangeHandler = () => {\n      if (!swiper || swiper.destroyed || !swiper.initialized) return;\n      emit('orientationchange');\n    };\n    on('init', () => {\n      if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {\n        createObserver();\n        return;\n      }\n      window.addEventListener('resize', resizeHandler);\n      window.addEventListener('orientationchange', orientationChangeHandler);\n    });\n    on('destroy', () => {\n      removeObserver();\n      window.removeEventListener('resize', resizeHandler);\n      window.removeEventListener('orientationchange', orientationChangeHandler);\n    });\n  }\n\n  function Observer(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const observers = [];\n    const window = getWindow();\n    const attach = function (target, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;\n      const observer = new ObserverFunc(mutations => {\n        // The observerUpdate event should only be triggered\n        // once despite the number of mutations.  Additional\n        // triggers are redundant and are very costly\n        if (swiper.__preventObserver__) return;\n        if (mutations.length === 1) {\n          emit('observerUpdate', mutations[0]);\n          return;\n        }\n        const observerUpdate = function observerUpdate() {\n          emit('observerUpdate', mutations[0]);\n        };\n        if (window.requestAnimationFrame) {\n          window.requestAnimationFrame(observerUpdate);\n        } else {\n          window.setTimeout(observerUpdate, 0);\n        }\n      });\n      observer.observe(target, {\n        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,\n        childList: typeof options.childList === 'undefined' ? true : options.childList,\n        characterData: typeof options.characterData === 'undefined' ? true : options.characterData\n      });\n      observers.push(observer);\n    };\n    const init = () => {\n      if (!swiper.params.observer) return;\n      if (swiper.params.observeParents) {\n        const containerParents = elementParents(swiper.el);\n        for (let i = 0; i < containerParents.length; i += 1) {\n          attach(containerParents[i]);\n        }\n      }\n      // Observe container\n      attach(swiper.el, {\n        childList: swiper.params.observeSlideChildren\n      });\n\n      // Observe wrapper\n      attach(swiper.wrapperEl, {\n        attributes: false\n      });\n    };\n    const destroy = () => {\n      observers.forEach(observer => {\n        observer.disconnect();\n      });\n      observers.splice(0, observers.length);\n    };\n    extendParams({\n      observer: false,\n      observeParents: false,\n      observeSlideChildren: false\n    });\n    on('init', init);\n    on('destroy', destroy);\n  }\n\n  /* eslint-disable no-underscore-dangle */\n\n  var eventsEmitter = {\n    on(events, handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      const method = priority ? 'unshift' : 'push';\n      events.split(' ').forEach(event => {\n        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];\n        self.eventsListeners[event][method](handler);\n      });\n      return self;\n    },\n    once(events, handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      function onceHandler() {\n        self.off(events, onceHandler);\n        if (onceHandler.__emitterProxy) {\n          delete onceHandler.__emitterProxy;\n        }\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        handler.apply(self, args);\n      }\n      onceHandler.__emitterProxy = handler;\n      return self.on(events, onceHandler, priority);\n    },\n    onAny(handler, priority) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (typeof handler !== 'function') return self;\n      const method = priority ? 'unshift' : 'push';\n      if (self.eventsAnyListeners.indexOf(handler) < 0) {\n        self.eventsAnyListeners[method](handler);\n      }\n      return self;\n    },\n    offAny(handler) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsAnyListeners) return self;\n      const index = self.eventsAnyListeners.indexOf(handler);\n      if (index >= 0) {\n        self.eventsAnyListeners.splice(index, 1);\n      }\n      return self;\n    },\n    off(events, handler) {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsListeners) return self;\n      events.split(' ').forEach(event => {\n        if (typeof handler === 'undefined') {\n          self.eventsListeners[event] = [];\n        } else if (self.eventsListeners[event]) {\n          self.eventsListeners[event].forEach((eventHandler, index) => {\n            if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {\n              self.eventsListeners[event].splice(index, 1);\n            }\n          });\n        }\n      });\n      return self;\n    },\n    emit() {\n      const self = this;\n      if (!self.eventsListeners || self.destroyed) return self;\n      if (!self.eventsListeners) return self;\n      let events;\n      let data;\n      let context;\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      if (typeof args[0] === 'string' || Array.isArray(args[0])) {\n        events = args[0];\n        data = args.slice(1, args.length);\n        context = self;\n      } else {\n        events = args[0].events;\n        data = args[0].data;\n        context = args[0].context || self;\n      }\n      data.unshift(context);\n      const eventsArray = Array.isArray(events) ? events : events.split(' ');\n      eventsArray.forEach(event => {\n        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {\n          self.eventsAnyListeners.forEach(eventHandler => {\n            eventHandler.apply(context, [event, ...data]);\n          });\n        }\n        if (self.eventsListeners && self.eventsListeners[event]) {\n          self.eventsListeners[event].forEach(eventHandler => {\n            eventHandler.apply(context, data);\n          });\n        }\n      });\n      return self;\n    }\n  };\n\n  function updateSize() {\n    const swiper = this;\n    let width;\n    let height;\n    const el = swiper.el;\n    if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {\n      width = swiper.params.width;\n    } else {\n      width = el.clientWidth;\n    }\n    if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {\n      height = swiper.params.height;\n    } else {\n      height = el.clientHeight;\n    }\n    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {\n      return;\n    }\n\n    // Subtract paddings\n    width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);\n    height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);\n    if (Number.isNaN(width)) width = 0;\n    if (Number.isNaN(height)) height = 0;\n    Object.assign(swiper, {\n      width,\n      height,\n      size: swiper.isHorizontal() ? width : height\n    });\n  }\n\n  function updateSlides() {\n    const swiper = this;\n    function getDirectionLabel(property) {\n      if (swiper.isHorizontal()) {\n        return property;\n      }\n      // prettier-ignore\n      return {\n        'width': 'height',\n        'margin-top': 'margin-left',\n        'margin-bottom ': 'margin-right',\n        'margin-left': 'margin-top',\n        'margin-right': 'margin-bottom',\n        'padding-left': 'padding-top',\n        'padding-right': 'padding-bottom',\n        'marginRight': 'marginBottom'\n      }[property];\n    }\n    function getDirectionPropertyValue(node, label) {\n      return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);\n    }\n    const params = swiper.params;\n    const {\n      wrapperEl,\n      slidesEl,\n      size: swiperSize,\n      rtlTranslate: rtl,\n      wrongRTL\n    } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;\n    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);\n    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;\n    let snapGrid = [];\n    const slidesGrid = [];\n    const slidesSizesGrid = [];\n    let offsetBefore = params.slidesOffsetBefore;\n    if (typeof offsetBefore === 'function') {\n      offsetBefore = params.slidesOffsetBefore.call(swiper);\n    }\n    let offsetAfter = params.slidesOffsetAfter;\n    if (typeof offsetAfter === 'function') {\n      offsetAfter = params.slidesOffsetAfter.call(swiper);\n    }\n    const previousSnapGridLength = swiper.snapGrid.length;\n    const previousSlidesGridLength = swiper.slidesGrid.length;\n    let spaceBetween = params.spaceBetween;\n    let slidePosition = -offsetBefore;\n    let prevSlideSize = 0;\n    let index = 0;\n    if (typeof swiperSize === 'undefined') {\n      return;\n    }\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    swiper.virtualSize = -spaceBetween;\n\n    // reset margins\n    slides.forEach(slideEl => {\n      if (rtl) {\n        slideEl.style.marginLeft = '';\n      } else {\n        slideEl.style.marginRight = '';\n      }\n      slideEl.style.marginBottom = '';\n      slideEl.style.marginTop = '';\n    });\n\n    // reset cssMode offsets\n    if (params.centeredSlides && params.cssMode) {\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');\n    }\n    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;\n    if (gridEnabled) {\n      swiper.grid.initSlides(slidesLength);\n    }\n\n    // Calc slides\n    let slideSize;\n    const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {\n      return typeof params.breakpoints[key].slidesPerView !== 'undefined';\n    }).length > 0;\n    for (let i = 0; i < slidesLength; i += 1) {\n      slideSize = 0;\n      let slide;\n      if (slides[i]) slide = slides[i];\n      if (gridEnabled) {\n        swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);\n      }\n      if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line\n\n      if (params.slidesPerView === 'auto') {\n        if (shouldResetSlideSize) {\n          slides[i].style[getDirectionLabel('width')] = ``;\n        }\n        const slideStyles = getComputedStyle(slide);\n        const currentTransform = slide.style.transform;\n        const currentWebKitTransform = slide.style.webkitTransform;\n        if (currentTransform) {\n          slide.style.transform = 'none';\n        }\n        if (currentWebKitTransform) {\n          slide.style.webkitTransform = 'none';\n        }\n        if (params.roundLengths) {\n          slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width', true) : elementOuterSize(slide, 'height', true);\n        } else {\n          // eslint-disable-next-line\n          const width = getDirectionPropertyValue(slideStyles, 'width');\n          const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');\n          const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');\n          const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');\n          const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');\n          const boxSizing = slideStyles.getPropertyValue('box-sizing');\n          if (boxSizing && boxSizing === 'border-box') {\n            slideSize = width + marginLeft + marginRight;\n          } else {\n            const {\n              clientWidth,\n              offsetWidth\n            } = slide;\n            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);\n          }\n        }\n        if (currentTransform) {\n          slide.style.transform = currentTransform;\n        }\n        if (currentWebKitTransform) {\n          slide.style.webkitTransform = currentWebKitTransform;\n        }\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n      } else {\n        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;\n        if (params.roundLengths) slideSize = Math.floor(slideSize);\n        if (slides[i]) {\n          slides[i].style[getDirectionLabel('width')] = `${slideSize}px`;\n        }\n      }\n      if (slides[i]) {\n        slides[i].swiperSlideSize = slideSize;\n      }\n      slidesSizesGrid.push(slideSize);\n      if (params.centeredSlides) {\n        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;\n        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n        if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;\n        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;\n        if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n        if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n        slidesGrid.push(slidePosition);\n      } else {\n        if (params.roundLengths) slidePosition = Math.floor(slidePosition);\n        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);\n        slidesGrid.push(slidePosition);\n        slidePosition = slidePosition + slideSize + spaceBetween;\n      }\n      swiper.virtualSize += slideSize + spaceBetween;\n      prevSlideSize = slideSize;\n      index += 1;\n    }\n    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;\n    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {\n      wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (params.setWrapperSize) {\n      wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n    }\n    if (gridEnabled) {\n      swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);\n    }\n\n    // Remove last grid elements depending on width\n    if (!params.centeredSlides) {\n      const newSlidesGrid = [];\n      for (let i = 0; i < snapGrid.length; i += 1) {\n        let slidesGridItem = snapGrid[i];\n        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {\n          newSlidesGrid.push(slidesGridItem);\n        }\n      }\n      snapGrid = newSlidesGrid;\n      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {\n        snapGrid.push(swiper.virtualSize - swiperSize);\n      }\n    }\n    if (isVirtual && params.loop) {\n      const size = slidesSizesGrid[0] + spaceBetween;\n      if (params.slidesPerGroup > 1) {\n        const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);\n        const groupSize = size * params.slidesPerGroup;\n        for (let i = 0; i < groups; i += 1) {\n          snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);\n        }\n      }\n      for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {\n        if (params.slidesPerGroup === 1) {\n          snapGrid.push(snapGrid[snapGrid.length - 1] + size);\n        }\n        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);\n        swiper.virtualSize += size;\n      }\n    }\n    if (snapGrid.length === 0) snapGrid = [0];\n    if (spaceBetween !== 0) {\n      const key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');\n      slides.filter((_, slideIndex) => {\n        if (!params.cssMode || params.loop) return true;\n        if (slideIndex === slides.length - 1) {\n          return false;\n        }\n        return true;\n      }).forEach(slideEl => {\n        slideEl.style[key] = `${spaceBetween}px`;\n      });\n    }\n    if (params.centeredSlides && params.centeredSlidesBounds) {\n      let allSlidesSize = 0;\n      slidesSizesGrid.forEach(slideSizeValue => {\n        allSlidesSize += slideSizeValue + (spaceBetween || 0);\n      });\n      allSlidesSize -= spaceBetween;\n      const maxSnap = allSlidesSize - swiperSize;\n      snapGrid = snapGrid.map(snap => {\n        if (snap <= 0) return -offsetBefore;\n        if (snap > maxSnap) return maxSnap + offsetAfter;\n        return snap;\n      });\n    }\n    if (params.centerInsufficientSlides) {\n      let allSlidesSize = 0;\n      slidesSizesGrid.forEach(slideSizeValue => {\n        allSlidesSize += slideSizeValue + (spaceBetween || 0);\n      });\n      allSlidesSize -= spaceBetween;\n      if (allSlidesSize < swiperSize) {\n        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;\n        snapGrid.forEach((snap, snapIndex) => {\n          snapGrid[snapIndex] = snap - allSlidesOffset;\n        });\n        slidesGrid.forEach((snap, snapIndex) => {\n          slidesGrid[snapIndex] = snap + allSlidesOffset;\n        });\n      }\n    }\n    Object.assign(swiper, {\n      slides,\n      snapGrid,\n      slidesGrid,\n      slidesSizesGrid\n    });\n    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);\n      setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);\n      const addToSnapGrid = -swiper.snapGrid[0];\n      const addToSlidesGrid = -swiper.slidesGrid[0];\n      swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);\n      swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);\n    }\n    if (slidesLength !== previousSlidesLength) {\n      swiper.emit('slidesLengthChange');\n    }\n    if (snapGrid.length !== previousSnapGridLength) {\n      if (swiper.params.watchOverflow) swiper.checkOverflow();\n      swiper.emit('snapGridLengthChange');\n    }\n    if (slidesGrid.length !== previousSlidesGridLength) {\n      swiper.emit('slidesGridLengthChange');\n    }\n    if (params.watchSlidesProgress) {\n      swiper.updateSlidesOffset();\n    }\n    if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {\n      const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;\n      const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);\n      if (slidesLength <= params.maxBackfaceHiddenSlides) {\n        if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);\n      } else if (hasClassBackfaceClassAdded) {\n        swiper.el.classList.remove(backFaceHiddenClass);\n      }\n    }\n  }\n\n  function updateAutoHeight(speed) {\n    const swiper = this;\n    const activeSlides = [];\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n    let newHeight = 0;\n    let i;\n    if (typeof speed === 'number') {\n      swiper.setTransition(speed);\n    } else if (speed === true) {\n      swiper.setTransition(swiper.params.speed);\n    }\n    const getSlideByIndex = index => {\n      if (isVirtual) {\n        return swiper.slides[swiper.getSlideIndexByData(index)];\n      }\n      return swiper.slides[index];\n    };\n    // Find slides currently in view\n    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {\n      if (swiper.params.centeredSlides) {\n        (swiper.visibleSlides || []).forEach(slide => {\n          activeSlides.push(slide);\n        });\n      } else {\n        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {\n          const index = swiper.activeIndex + i;\n          if (index > swiper.slides.length && !isVirtual) break;\n          activeSlides.push(getSlideByIndex(index));\n        }\n      }\n    } else {\n      activeSlides.push(getSlideByIndex(swiper.activeIndex));\n    }\n\n    // Find new height from highest slide in view\n    for (i = 0; i < activeSlides.length; i += 1) {\n      if (typeof activeSlides[i] !== 'undefined') {\n        const height = activeSlides[i].offsetHeight;\n        newHeight = height > newHeight ? height : newHeight;\n      }\n    }\n\n    // Update Height\n    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;\n  }\n\n  function updateSlidesOffset() {\n    const swiper = this;\n    const slides = swiper.slides;\n    // eslint-disable-next-line\n    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;\n    for (let i = 0; i < slides.length; i += 1) {\n      slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();\n    }\n  }\n\n  function updateSlidesProgress(translate) {\n    if (translate === void 0) {\n      translate = this && this.translate || 0;\n    }\n    const swiper = this;\n    const params = swiper.params;\n    const {\n      slides,\n      rtlTranslate: rtl,\n      snapGrid\n    } = swiper;\n    if (slides.length === 0) return;\n    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();\n    let offsetCenter = -translate;\n    if (rtl) offsetCenter = translate;\n\n    // Visible Slides\n    slides.forEach(slideEl => {\n      slideEl.classList.remove(params.slideVisibleClass);\n    });\n    swiper.visibleSlidesIndexes = [];\n    swiper.visibleSlides = [];\n    let spaceBetween = params.spaceBetween;\n    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n    } else if (typeof spaceBetween === 'string') {\n      spaceBetween = parseFloat(spaceBetween);\n    }\n    for (let i = 0; i < slides.length; i += 1) {\n      const slide = slides[i];\n      let slideOffset = slide.swiperSlideOffset;\n      if (params.cssMode && params.centeredSlides) {\n        slideOffset -= slides[0].swiperSlideOffset;\n      }\n      const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n      const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);\n      const slideBefore = -(offsetCenter - slideOffset);\n      const slideAfter = slideBefore + swiper.slidesSizesGrid[i];\n      const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;\n      if (isVisible) {\n        swiper.visibleSlides.push(slide);\n        swiper.visibleSlidesIndexes.push(i);\n        slides[i].classList.add(params.slideVisibleClass);\n      }\n      slide.progress = rtl ? -slideProgress : slideProgress;\n      slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;\n    }\n  }\n\n  function updateProgress(translate) {\n    const swiper = this;\n    if (typeof translate === 'undefined') {\n      const multiplier = swiper.rtlTranslate ? -1 : 1;\n      // eslint-disable-next-line\n      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;\n    }\n    const params = swiper.params;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    let {\n      progress,\n      isBeginning,\n      isEnd,\n      progressLoop\n    } = swiper;\n    const wasBeginning = isBeginning;\n    const wasEnd = isEnd;\n    if (translatesDiff === 0) {\n      progress = 0;\n      isBeginning = true;\n      isEnd = true;\n    } else {\n      progress = (translate - swiper.minTranslate()) / translatesDiff;\n      const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;\n      const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;\n      isBeginning = isBeginningRounded || progress <= 0;\n      isEnd = isEndRounded || progress >= 1;\n      if (isBeginningRounded) progress = 0;\n      if (isEndRounded) progress = 1;\n    }\n    if (params.loop) {\n      const firstSlideIndex = swiper.getSlideIndexByData(0);\n      const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);\n      const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];\n      const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];\n      const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];\n      const translateAbs = Math.abs(translate);\n      if (translateAbs >= firstSlideTranslate) {\n        progressLoop = (translateAbs - firstSlideTranslate) / translateMax;\n      } else {\n        progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;\n      }\n      if (progressLoop > 1) progressLoop -= 1;\n    }\n    Object.assign(swiper, {\n      progress,\n      progressLoop,\n      isBeginning,\n      isEnd\n    });\n    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);\n    if (isBeginning && !wasBeginning) {\n      swiper.emit('reachBeginning toEdge');\n    }\n    if (isEnd && !wasEnd) {\n      swiper.emit('reachEnd toEdge');\n    }\n    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {\n      swiper.emit('fromEdge');\n    }\n    swiper.emit('progress', progress);\n  }\n\n  function updateSlidesClasses() {\n    const swiper = this;\n    const {\n      slides,\n      params,\n      slidesEl,\n      activeIndex\n    } = swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    const getFilteredSlide = selector => {\n      return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];\n    };\n    slides.forEach(slideEl => {\n      slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n    });\n    let activeSlide;\n    if (isVirtual) {\n      if (params.loop) {\n        let slideIndex = activeIndex - swiper.virtual.slidesBefore;\n        if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;\n        if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;\n        activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${slideIndex}\"]`);\n      } else {\n        activeSlide = getFilteredSlide(`[data-swiper-slide-index=\"${activeIndex}\"]`);\n      }\n    } else {\n      activeSlide = slides[activeIndex];\n    }\n    if (activeSlide) {\n      // Active classes\n      activeSlide.classList.add(params.slideActiveClass);\n\n      // Next Slide\n      let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !nextSlide) {\n        nextSlide = slides[0];\n      }\n      if (nextSlide) {\n        nextSlide.classList.add(params.slideNextClass);\n      }\n      // Prev Slide\n      let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];\n      if (params.loop && !prevSlide === 0) {\n        prevSlide = slides[slides.length - 1];\n      }\n      if (prevSlide) {\n        prevSlide.classList.add(params.slidePrevClass);\n      }\n    }\n    swiper.emitSlidesClasses();\n  }\n\n  const processLazyPreloader = (swiper, imageEl) => {\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n    const slideEl = imageEl.closest(slideSelector());\n    if (slideEl) {\n      const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);\n      if (lazyEl) lazyEl.remove();\n    }\n  };\n  const unlazy = (swiper, index) => {\n    if (!swiper.slides[index]) return;\n    const imageEl = swiper.slides[index].querySelector('[loading=\"lazy\"]');\n    if (imageEl) imageEl.removeAttribute('loading');\n  };\n  const preload = swiper => {\n    if (!swiper || swiper.destroyed || !swiper.params) return;\n    let amount = swiper.params.lazyPreloadPrevNext;\n    const len = swiper.slides.length;\n    if (!len || !amount || amount < 0) return;\n    amount = Math.min(amount, len);\n    const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);\n    const activeIndex = swiper.activeIndex;\n    if (swiper.params.grid && swiper.params.grid.rows > 1) {\n      const activeColumn = activeIndex;\n      const preloadColumns = [activeColumn - amount];\n      preloadColumns.push(...Array.from({\n        length: amount\n      }).map((_, i) => {\n        return activeColumn + slidesPerView + i;\n      }));\n      swiper.slides.forEach((slideEl, i) => {\n        if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);\n      });\n      return;\n    }\n    const slideIndexLastInView = activeIndex + slidesPerView - 1;\n    if (swiper.params.rewind || swiper.params.loop) {\n      for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {\n        const realIndex = (i % len + len) % len;\n        if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);\n      }\n    } else {\n      for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {\n        if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {\n          unlazy(swiper, i);\n        }\n      }\n    }\n  };\n\n  function getActiveIndexByTranslate(swiper) {\n    const {\n      slidesGrid,\n      params\n    } = swiper;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    let activeIndex;\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {\n          activeIndex = i;\n        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {\n          activeIndex = i + 1;\n        }\n      } else if (translate >= slidesGrid[i]) {\n        activeIndex = i;\n      }\n    }\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;\n    }\n    return activeIndex;\n  }\n  function updateActiveIndex(newActiveIndex) {\n    const swiper = this;\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    const {\n      snapGrid,\n      params,\n      activeIndex: previousIndex,\n      realIndex: previousRealIndex,\n      snapIndex: previousSnapIndex\n    } = swiper;\n    let activeIndex = newActiveIndex;\n    let snapIndex;\n    const getVirtualRealIndex = aIndex => {\n      let realIndex = aIndex - swiper.virtual.slidesBefore;\n      if (realIndex < 0) {\n        realIndex = swiper.virtual.slides.length + realIndex;\n      }\n      if (realIndex >= swiper.virtual.slides.length) {\n        realIndex -= swiper.virtual.slides.length;\n      }\n      return realIndex;\n    };\n    if (typeof activeIndex === 'undefined') {\n      activeIndex = getActiveIndexByTranslate(swiper);\n    }\n    if (snapGrid.indexOf(translate) >= 0) {\n      snapIndex = snapGrid.indexOf(translate);\n    } else {\n      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);\n      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);\n    }\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    if (activeIndex === previousIndex) {\n      if (snapIndex !== previousSnapIndex) {\n        swiper.snapIndex = snapIndex;\n        swiper.emit('snapIndexChange');\n      }\n      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.realIndex = getVirtualRealIndex(activeIndex);\n      }\n      return;\n    }\n    // Get real index\n    let realIndex;\n    if (swiper.virtual && params.virtual.enabled && params.loop) {\n      realIndex = getVirtualRealIndex(activeIndex);\n    } else if (swiper.slides[activeIndex]) {\n      realIndex = parseInt(swiper.slides[activeIndex].getAttribute('data-swiper-slide-index') || activeIndex, 10);\n    } else {\n      realIndex = activeIndex;\n    }\n    Object.assign(swiper, {\n      previousSnapIndex,\n      snapIndex,\n      previousRealIndex,\n      realIndex,\n      previousIndex,\n      activeIndex\n    });\n    if (swiper.initialized) {\n      preload(swiper);\n    }\n    swiper.emit('activeIndexChange');\n    swiper.emit('snapIndexChange');\n    if (previousRealIndex !== realIndex) {\n      swiper.emit('realIndexChange');\n    }\n    if (swiper.initialized || swiper.params.runCallbacksOnInit) {\n      swiper.emit('slideChange');\n    }\n  }\n\n  function updateClickedSlide(e) {\n    const swiper = this;\n    const params = swiper.params;\n    const slide = e.closest(`.${params.slideClass}, swiper-slide`);\n    let slideFound = false;\n    let slideIndex;\n    if (slide) {\n      for (let i = 0; i < swiper.slides.length; i += 1) {\n        if (swiper.slides[i] === slide) {\n          slideFound = true;\n          slideIndex = i;\n          break;\n        }\n      }\n    }\n    if (slide && slideFound) {\n      swiper.clickedSlide = slide;\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);\n      } else {\n        swiper.clickedIndex = slideIndex;\n      }\n    } else {\n      swiper.clickedSlide = undefined;\n      swiper.clickedIndex = undefined;\n      return;\n    }\n    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {\n      swiper.slideToClickedSlide();\n    }\n  }\n\n  var update = {\n    updateSize,\n    updateSlides,\n    updateAutoHeight,\n    updateSlidesOffset,\n    updateSlidesProgress,\n    updateProgress,\n    updateSlidesClasses,\n    updateActiveIndex,\n    updateClickedSlide\n  };\n\n  function getSwiperTranslate(axis) {\n    if (axis === void 0) {\n      axis = this.isHorizontal() ? 'x' : 'y';\n    }\n    const swiper = this;\n    const {\n      params,\n      rtlTranslate: rtl,\n      translate,\n      wrapperEl\n    } = swiper;\n    if (params.virtualTranslate) {\n      return rtl ? -translate : translate;\n    }\n    if (params.cssMode) {\n      return translate;\n    }\n    let currentTranslate = getTranslate(wrapperEl, axis);\n    currentTranslate += swiper.cssOverflowAdjustment();\n    if (rtl) currentTranslate = -currentTranslate;\n    return currentTranslate || 0;\n  }\n\n  function setTranslate(translate, byController) {\n    const swiper = this;\n    const {\n      rtlTranslate: rtl,\n      params,\n      wrapperEl,\n      progress\n    } = swiper;\n    let x = 0;\n    let y = 0;\n    const z = 0;\n    if (swiper.isHorizontal()) {\n      x = rtl ? -translate : translate;\n    } else {\n      y = translate;\n    }\n    if (params.roundLengths) {\n      x = Math.floor(x);\n      y = Math.floor(y);\n    }\n    swiper.previousTranslate = swiper.translate;\n    swiper.translate = swiper.isHorizontal() ? x : y;\n    if (params.cssMode) {\n      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;\n    } else if (!params.virtualTranslate) {\n      if (swiper.isHorizontal()) {\n        x -= swiper.cssOverflowAdjustment();\n      } else {\n        y -= swiper.cssOverflowAdjustment();\n      }\n      wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;\n    }\n\n    // Check if we need to update progress\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n      newProgress = 0;\n    } else {\n      newProgress = (translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== progress) {\n      swiper.updateProgress(translate);\n    }\n    swiper.emit('setTranslate', swiper.translate, byController);\n  }\n\n  function minTranslate() {\n    return -this.snapGrid[0];\n  }\n\n  function maxTranslate() {\n    return -this.snapGrid[this.snapGrid.length - 1];\n  }\n\n  function translateTo(translate, speed, runCallbacks, translateBounds, internal) {\n    if (translate === void 0) {\n      translate = 0;\n    }\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (translateBounds === void 0) {\n      translateBounds = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      wrapperEl\n    } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n      return false;\n    }\n    const minTranslate = swiper.minTranslate();\n    const maxTranslate = swiper.maxTranslate();\n    let newTranslate;\n    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;\n\n    // Update progress\n    swiper.updateProgress(newTranslate);\n    if (params.cssMode) {\n      const isH = swiper.isHorizontal();\n      if (speed === 0) {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;\n      } else {\n        if (!swiper.support.smoothScroll) {\n          animateCSSModeScroll({\n            swiper,\n            targetPosition: -newTranslate,\n            side: isH ? 'left' : 'top'\n          });\n          return true;\n        }\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: -newTranslate,\n          behavior: 'smooth'\n        });\n      }\n      return true;\n    }\n    if (speed === 0) {\n      swiper.setTransition(0);\n      swiper.setTranslate(newTranslate);\n      if (runCallbacks) {\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.emit('transitionEnd');\n      }\n    } else {\n      swiper.setTransition(speed);\n      swiper.setTranslate(newTranslate);\n      if (runCallbacks) {\n        swiper.emit('beforeTransitionStart', speed, internal);\n        swiper.emit('transitionStart');\n      }\n      if (!swiper.animating) {\n        swiper.animating = true;\n        if (!swiper.onTranslateToWrapperTransitionEnd) {\n          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {\n            if (!swiper || swiper.destroyed) return;\n            if (e.target !== this) return;\n            swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n            swiper.onTranslateToWrapperTransitionEnd = null;\n            delete swiper.onTranslateToWrapperTransitionEnd;\n            if (runCallbacks) {\n              swiper.emit('transitionEnd');\n            }\n          };\n        }\n        swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);\n      }\n    }\n    return true;\n  }\n\n  var translate = {\n    getTranslate: getSwiperTranslate,\n    setTranslate,\n    minTranslate,\n    maxTranslate,\n    translateTo\n  };\n\n  function setTransition(duration, byController) {\n    const swiper = this;\n    if (!swiper.params.cssMode) {\n      swiper.wrapperEl.style.transitionDuration = `${duration}ms`;\n    }\n    swiper.emit('setTransition', duration, byController);\n  }\n\n  function transitionEmit(_ref) {\n    let {\n      swiper,\n      runCallbacks,\n      direction,\n      step\n    } = _ref;\n    const {\n      activeIndex,\n      previousIndex\n    } = swiper;\n    let dir = direction;\n    if (!dir) {\n      if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';\n    }\n    swiper.emit(`transition${step}`);\n    if (runCallbacks && activeIndex !== previousIndex) {\n      if (dir === 'reset') {\n        swiper.emit(`slideResetTransition${step}`);\n        return;\n      }\n      swiper.emit(`slideChangeTransition${step}`);\n      if (dir === 'next') {\n        swiper.emit(`slideNextTransition${step}`);\n      } else {\n        swiper.emit(`slidePrevTransition${step}`);\n      }\n    }\n  }\n\n  function transitionStart(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      params\n    } = swiper;\n    if (params.cssMode) return;\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step: 'Start'\n    });\n  }\n\n  function transitionEnd(runCallbacks, direction) {\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      params\n    } = swiper;\n    swiper.animating = false;\n    if (params.cssMode) return;\n    swiper.setTransition(0);\n    transitionEmit({\n      swiper,\n      runCallbacks,\n      direction,\n      step: 'End'\n    });\n  }\n\n  var transition = {\n    setTransition,\n    transitionStart,\n    transitionEnd\n  };\n\n  function slideTo(index, speed, runCallbacks, internal, initial) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (typeof index === 'string') {\n      index = parseInt(index, 10);\n    }\n    const swiper = this;\n    let slideIndex = index;\n    if (slideIndex < 0) slideIndex = 0;\n    const {\n      params,\n      snapGrid,\n      slidesGrid,\n      previousIndex,\n      activeIndex,\n      rtlTranslate: rtl,\n      wrapperEl,\n      enabled\n    } = swiper;\n    if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n      return false;\n    }\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n    const translate = -snapGrid[snapIndex];\n    // Normalize slideIndex\n    if (params.normalizeSlideIndex) {\n      for (let i = 0; i < slidesGrid.length; i += 1) {\n        const normalizedTranslate = -Math.floor(translate * 100);\n        const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n        if (typeof slidesGrid[i + 1] !== 'undefined') {\n          if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n            slideIndex = i;\n          } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n            slideIndex = i + 1;\n          }\n        } else if (normalizedTranslate >= normalizedGrid) {\n          slideIndex = i;\n        }\n      }\n    }\n    // Directions locks\n    if (swiper.initialized && slideIndex !== activeIndex) {\n      if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n        return false;\n      }\n      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n        if ((activeIndex || 0) !== slideIndex) {\n          return false;\n        }\n      }\n    }\n    if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n      swiper.emit('beforeSlideChangeStart');\n    }\n\n    // Update progress\n    swiper.updateProgress(translate);\n    let direction;\n    if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n    // Update Index\n    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n      swiper.updateActiveIndex(slideIndex);\n      // Update Height\n      if (params.autoHeight) {\n        swiper.updateAutoHeight();\n      }\n      swiper.updateSlidesClasses();\n      if (params.effect !== 'slide') {\n        swiper.setTranslate(translate);\n      }\n      if (direction !== 'reset') {\n        swiper.transitionStart(runCallbacks, direction);\n        swiper.transitionEnd(runCallbacks, direction);\n      }\n      return false;\n    }\n    if (params.cssMode) {\n      const isH = swiper.isHorizontal();\n      const t = rtl ? translate : -translate;\n      if (speed === 0) {\n        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n        if (isVirtual) {\n          swiper.wrapperEl.style.scrollSnapType = 'none';\n          swiper._immediateVirtual = true;\n        }\n        if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n          swiper._cssModeVirtualInitialSet = true;\n          requestAnimationFrame(() => {\n            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n          });\n        } else {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        }\n        if (isVirtual) {\n          requestAnimationFrame(() => {\n            swiper.wrapperEl.style.scrollSnapType = '';\n            swiper._immediateVirtual = false;\n          });\n        }\n      } else {\n        if (!swiper.support.smoothScroll) {\n          animateCSSModeScroll({\n            swiper,\n            targetPosition: t,\n            side: isH ? 'left' : 'top'\n          });\n          return true;\n        }\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: t,\n          behavior: 'smooth'\n        });\n      }\n      return true;\n    }\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (speed === 0) {\n      swiper.transitionEnd(runCallbacks, direction);\n    } else if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n      swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n    }\n    return true;\n  }\n\n  function slideToLoop(index, speed, runCallbacks, internal) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (typeof index === 'string') {\n      const indexAsNumber = parseInt(index, 10);\n      index = indexAsNumber;\n    }\n    const swiper = this;\n    let newIndex = index;\n    if (swiper.params.loop) {\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        // eslint-disable-next-line\n        newIndex = newIndex + swiper.virtual.slidesBefore;\n      } else {\n        newIndex = swiper.getSlideIndexByData(newIndex);\n      }\n    }\n    return swiper.slideTo(newIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideNext(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      enabled,\n      params,\n      animating\n    } = swiper;\n    if (!enabled) return swiper;\n    let perGroup = params.slidesPerGroup;\n    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n      perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);\n    }\n    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n      if (animating && !isVirtual && params.loopPreventsSliding) return false;\n      swiper.loopFix({\n        direction: 'next'\n      });\n      // eslint-disable-next-line\n      swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    if (params.rewind && swiper.isEnd) {\n      return swiper.slideTo(0, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slidePrev(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    const {\n      params,\n      snapGrid,\n      slidesGrid,\n      rtlTranslate,\n      enabled,\n      animating\n    } = swiper;\n    if (!enabled) return swiper;\n    const isVirtual = swiper.virtual && params.virtual.enabled;\n    if (params.loop) {\n      if (animating && !isVirtual && params.loopPreventsSliding) return false;\n      swiper.loopFix({\n        direction: 'prev'\n      });\n      // eslint-disable-next-line\n      swiper._clientLeft = swiper.wrapperEl.clientLeft;\n    }\n    const translate = rtlTranslate ? swiper.translate : -swiper.translate;\n    function normalize(val) {\n      if (val < 0) return -Math.floor(Math.abs(val));\n      return Math.floor(val);\n    }\n    const normalizedTranslate = normalize(translate);\n    const normalizedSnapGrid = snapGrid.map(val => normalize(val));\n    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];\n    if (typeof prevSnap === 'undefined' && params.cssMode) {\n      let prevSnapIndex;\n      snapGrid.forEach((snap, snapIndex) => {\n        if (normalizedTranslate >= snap) {\n          // prevSnap = snap;\n          prevSnapIndex = snapIndex;\n        }\n      });\n      if (typeof prevSnapIndex !== 'undefined') {\n        prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];\n      }\n    }\n    let prevIndex = 0;\n    if (typeof prevSnap !== 'undefined') {\n      prevIndex = slidesGrid.indexOf(prevSnap);\n      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;\n      if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {\n        prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;\n        prevIndex = Math.max(prevIndex, 0);\n      }\n    }\n    if (params.rewind && swiper.isBeginning) {\n      const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n      return swiper.slideTo(lastIndex, speed, runCallbacks, internal);\n    }\n    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideReset(speed, runCallbacks, internal) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    const swiper = this;\n    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);\n  }\n\n  /* eslint no-unused-vars: \"off\" */\n  function slideToClosest(speed, runCallbacks, internal, threshold) {\n    if (speed === void 0) {\n      speed = this.params.speed;\n    }\n    if (runCallbacks === void 0) {\n      runCallbacks = true;\n    }\n    if (threshold === void 0) {\n      threshold = 0.5;\n    }\n    const swiper = this;\n    let index = swiper.activeIndex;\n    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);\n    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);\n    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;\n    if (translate >= swiper.snapGrid[snapIndex]) {\n      // The current translate is on or after the current snap index, so the choice\n      // is between the current index and the one after it.\n      const currentSnap = swiper.snapGrid[snapIndex];\n      const nextSnap = swiper.snapGrid[snapIndex + 1];\n      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {\n        index += swiper.params.slidesPerGroup;\n      }\n    } else {\n      // The current translate is before the current snap index, so the choice\n      // is between the current index and the one before it.\n      const prevSnap = swiper.snapGrid[snapIndex - 1];\n      const currentSnap = swiper.snapGrid[snapIndex];\n      if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {\n        index -= swiper.params.slidesPerGroup;\n      }\n    }\n    index = Math.max(index, 0);\n    index = Math.min(index, swiper.slidesGrid.length - 1);\n    return swiper.slideTo(index, speed, runCallbacks, internal);\n  }\n\n  function slideToClickedSlide() {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;\n    let slideToIndex = swiper.clickedIndex;\n    let realIndex;\n    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;\n    if (params.loop) {\n      if (swiper.animating) return;\n      realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n      if (params.centeredSlides) {\n        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {\n          swiper.loopFix();\n          slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n          nextTick(() => {\n            swiper.slideTo(slideToIndex);\n          });\n        } else {\n          swiper.slideTo(slideToIndex);\n        }\n      } else if (slideToIndex > swiper.slides.length - slidesPerView) {\n        swiper.loopFix();\n        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index=\"${realIndex}\"]`)[0]);\n        nextTick(() => {\n          swiper.slideTo(slideToIndex);\n        });\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    } else {\n      swiper.slideTo(slideToIndex);\n    }\n  }\n\n  var slide = {\n    slideTo,\n    slideToLoop,\n    slideNext,\n    slidePrev,\n    slideReset,\n    slideToClosest,\n    slideToClickedSlide\n  };\n\n  function loopCreate(slideRealIndex) {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    slides.forEach((el, index) => {\n      el.setAttribute('data-swiper-slide-index', index);\n    });\n    swiper.loopFix({\n      slideRealIndex,\n      direction: params.centeredSlides ? undefined : 'next'\n    });\n  }\n\n  function loopFix(_temp) {\n    let {\n      slideRealIndex,\n      slideTo = true,\n      direction,\n      setTranslate,\n      activeSlideIndex,\n      byController,\n      byMousewheel\n    } = _temp === void 0 ? {} : _temp;\n    const swiper = this;\n    if (!swiper.params.loop) return;\n    swiper.emit('beforeLoopFix');\n    const {\n      slides,\n      allowSlidePrev,\n      allowSlideNext,\n      slidesEl,\n      params\n    } = swiper;\n    swiper.allowSlidePrev = true;\n    swiper.allowSlideNext = true;\n    if (swiper.virtual && params.virtual.enabled) {\n      if (slideTo) {\n        if (!params.centeredSlides && swiper.snapIndex === 0) {\n          swiper.slideTo(swiper.virtual.slides.length, 0, false, true);\n        } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {\n          swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);\n        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {\n          swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);\n        }\n      }\n      swiper.allowSlidePrev = allowSlidePrev;\n      swiper.allowSlideNext = allowSlideNext;\n      swiper.emit('loopFix');\n      return;\n    }\n    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));\n    let loopedSlides = params.loopedSlides || slidesPerView;\n    if (loopedSlides % params.slidesPerGroup !== 0) {\n      loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;\n    }\n    swiper.loopedSlides = loopedSlides;\n    const prependSlidesIndexes = [];\n    const appendSlidesIndexes = [];\n    let activeIndex = swiper.activeIndex;\n    if (typeof activeSlideIndex === 'undefined') {\n      activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);\n    } else {\n      activeIndex = activeSlideIndex;\n    }\n    const isNext = direction === 'next' || !direction;\n    const isPrev = direction === 'prev' || !direction;\n    let slidesPrepended = 0;\n    let slidesAppended = 0;\n    // prepend last slides before start\n    if (activeSlideIndex < loopedSlides) {\n      slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);\n      for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {\n        const index = i - Math.floor(i / slides.length) * slides.length;\n        prependSlidesIndexes.push(slides.length - index - 1);\n      }\n    } else if (activeSlideIndex /* + slidesPerView */ > swiper.slides.length - loopedSlides * 2) {\n      slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);\n      for (let i = 0; i < slidesAppended; i += 1) {\n        const index = i - Math.floor(i / slides.length) * slides.length;\n        appendSlidesIndexes.push(index);\n      }\n    }\n    if (isPrev) {\n      prependSlidesIndexes.forEach(index => {\n        swiper.slides[index].swiperLoopMoveDOM = true;\n        slidesEl.prepend(swiper.slides[index]);\n        swiper.slides[index].swiperLoopMoveDOM = false;\n      });\n    }\n    if (isNext) {\n      appendSlidesIndexes.forEach(index => {\n        swiper.slides[index].swiperLoopMoveDOM = true;\n        slidesEl.append(swiper.slides[index]);\n        swiper.slides[index].swiperLoopMoveDOM = false;\n      });\n    }\n    swiper.recalcSlides();\n    if (params.slidesPerView === 'auto') {\n      swiper.updateSlides();\n    }\n    if (params.watchSlidesProgress) {\n      swiper.updateSlidesOffset();\n    }\n    if (slideTo) {\n      if (prependSlidesIndexes.length > 0 && isPrev) {\n        if (typeof slideRealIndex === 'undefined') {\n          const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n          const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];\n          const diff = newSlideTranslate - currentSlideTranslate;\n          if (byMousewheel) {\n            swiper.setTranslate(swiper.translate - diff);\n          } else {\n            swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);\n            if (setTranslate) {\n              swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n            }\n          }\n        } else {\n          if (setTranslate) {\n            swiper.slideToLoop(slideRealIndex, 0, false, true);\n          }\n        }\n      } else if (appendSlidesIndexes.length > 0 && isNext) {\n        if (typeof slideRealIndex === 'undefined') {\n          const currentSlideTranslate = swiper.slidesGrid[activeIndex];\n          const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];\n          const diff = newSlideTranslate - currentSlideTranslate;\n          if (byMousewheel) {\n            swiper.setTranslate(swiper.translate - diff);\n          } else {\n            swiper.slideTo(activeIndex - slidesAppended, 0, false, true);\n            if (setTranslate) {\n              swiper.touches[swiper.isHorizontal() ? 'startX' : 'startY'] += diff;\n            }\n          }\n        } else {\n          swiper.slideToLoop(slideRealIndex, 0, false, true);\n        }\n      }\n    }\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.controller && swiper.controller.control && !byController) {\n      const loopParams = {\n        slideRealIndex,\n        slideTo: false,\n        direction,\n        setTranslate,\n        activeSlideIndex,\n        byController: true\n      };\n      if (Array.isArray(swiper.controller.control)) {\n        swiper.controller.control.forEach(c => {\n          if (!c.destroyed && c.params.loop) c.loopFix(loopParams);\n        });\n      } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {\n        swiper.controller.control.loopFix(loopParams);\n      }\n    }\n    swiper.emit('loopFix');\n  }\n\n  function loopDestroy() {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;\n    swiper.recalcSlides();\n    const newSlidesOrder = [];\n    swiper.slides.forEach(slideEl => {\n      const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;\n      newSlidesOrder[index] = slideEl;\n    });\n    swiper.slides.forEach(slideEl => {\n      slideEl.removeAttribute('data-swiper-slide-index');\n    });\n    newSlidesOrder.forEach(slideEl => {\n      slidesEl.append(slideEl);\n    });\n    swiper.recalcSlides();\n    swiper.slideTo(swiper.realIndex, 0);\n  }\n\n  var loop = {\n    loopCreate,\n    loopFix,\n    loopDestroy\n  };\n\n  function setGrabCursor(moving) {\n    const swiper = this;\n    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;\n    const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;\n    if (swiper.isElement) {\n      swiper.__preventObserver__ = true;\n    }\n    el.style.cursor = 'move';\n    el.style.cursor = moving ? 'grabbing' : 'grab';\n    if (swiper.isElement) {\n      requestAnimationFrame(() => {\n        swiper.__preventObserver__ = false;\n      });\n    }\n  }\n\n  function unsetGrabCursor() {\n    const swiper = this;\n    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {\n      return;\n    }\n    if (swiper.isElement) {\n      swiper.__preventObserver__ = true;\n    }\n    swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';\n    if (swiper.isElement) {\n      requestAnimationFrame(() => {\n        swiper.__preventObserver__ = false;\n      });\n    }\n  }\n\n  var grabCursor = {\n    setGrabCursor,\n    unsetGrabCursor\n  };\n\n  // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd\n  function closestElement(selector, base) {\n    if (base === void 0) {\n      base = this;\n    }\n    function __closestFrom(el) {\n      if (!el || el === getDocument() || el === getWindow()) return null;\n      if (el.assignedSlot) el = el.assignedSlot;\n      const found = el.closest(selector);\n      if (!found && !el.getRootNode) {\n        return null;\n      }\n      return found || __closestFrom(el.getRootNode().host);\n    }\n    return __closestFrom(base);\n  }\n  function onTouchStart(event) {\n    const swiper = this;\n    const document = getDocument();\n    const window = getWindow();\n    const data = swiper.touchEventsData;\n    data.evCache.push(event);\n    const {\n      params,\n      touches,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === 'mouse') return;\n    if (swiper.animating && params.preventInteractionOnTransition) {\n      return;\n    }\n    if (!swiper.animating && params.cssMode && params.loop) {\n      swiper.loopFix();\n    }\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    let targetEl = e.target;\n    if (params.touchEventsTarget === 'wrapper') {\n      if (!swiper.wrapperEl.contains(targetEl)) return;\n    }\n    if ('which' in e && e.which === 3) return;\n    if ('button' in e && e.button > 0) return;\n    if (data.isTouched && data.isMoved) return;\n\n    // change target el for shadow root component\n    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';\n    // eslint-disable-next-line\n    const eventPath = event.composedPath ? event.composedPath() : event.path;\n    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {\n      targetEl = eventPath[0];\n    }\n    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;\n    const isTargetShadow = !!(e.target && e.target.shadowRoot);\n\n    // use closestElement for shadow root element to get the actual closest for nested shadow root element\n    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {\n      swiper.allowClick = true;\n      return;\n    }\n    if (params.swipeHandler) {\n      if (!targetEl.closest(params.swipeHandler)) return;\n    }\n    touches.currentX = e.pageX;\n    touches.currentY = e.pageY;\n    const startX = touches.currentX;\n    const startY = touches.currentY;\n\n    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore\n\n    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;\n    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;\n    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {\n      if (edgeSwipeDetection === 'prevent') {\n        event.preventDefault();\n      } else {\n        return;\n      }\n    }\n    Object.assign(data, {\n      isTouched: true,\n      isMoved: false,\n      allowTouchCallbacks: true,\n      isScrolling: undefined,\n      startMoving: undefined\n    });\n    touches.startX = startX;\n    touches.startY = startY;\n    data.touchStartTime = now();\n    swiper.allowClick = true;\n    swiper.updateSize();\n    swiper.swipeDirection = undefined;\n    if (params.threshold > 0) data.allowThresholdMove = false;\n    let preventDefault = true;\n    if (targetEl.matches(data.focusableElements)) {\n      preventDefault = false;\n      if (targetEl.nodeName === 'SELECT') {\n        data.isTouched = false;\n      }\n    }\n    if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {\n      document.activeElement.blur();\n    }\n    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;\n    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {\n      e.preventDefault();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {\n      swiper.freeMode.onTouchStart();\n    }\n    swiper.emit('touchStart', e);\n  }\n\n  function onTouchMove(event) {\n    const document = getDocument();\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const {\n      params,\n      touches,\n      rtlTranslate: rtl,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === 'mouse') return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (!data.isTouched) {\n      if (data.startMoving && data.isScrolling) {\n        swiper.emit('touchMoveOpposite', e);\n      }\n      return;\n    }\n    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n    if (pointerIndex >= 0) data.evCache[pointerIndex] = e;\n    const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;\n    const pageX = targetTouch.pageX;\n    const pageY = targetTouch.pageY;\n    if (e.preventedByNestedSwiper) {\n      touches.startX = pageX;\n      touches.startY = pageY;\n      return;\n    }\n    if (!swiper.allowTouchMove) {\n      if (!e.target.matches(data.focusableElements)) {\n        swiper.allowClick = false;\n      }\n      if (data.isTouched) {\n        Object.assign(touches, {\n          startX: pageX,\n          startY: pageY,\n          prevX: swiper.touches.currentX,\n          prevY: swiper.touches.currentY,\n          currentX: pageX,\n          currentY: pageY\n        });\n        data.touchStartTime = now();\n      }\n      return;\n    }\n    if (params.touchReleaseOnEdges && !params.loop) {\n      if (swiper.isVertical()) {\n        // Vertical\n        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {\n          data.isTouched = false;\n          data.isMoved = false;\n          return;\n        }\n      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {\n        return;\n      }\n    }\n    if (document.activeElement) {\n      if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {\n        data.isMoved = true;\n        swiper.allowClick = false;\n        return;\n      }\n    }\n    if (data.allowTouchCallbacks) {\n      swiper.emit('touchMove', e);\n    }\n    if (e.targetTouches && e.targetTouches.length > 1) return;\n    touches.currentX = pageX;\n    touches.currentY = pageY;\n    const diffX = touches.currentX - touches.startX;\n    const diffY = touches.currentY - touches.startY;\n    if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;\n    if (typeof data.isScrolling === 'undefined') {\n      let touchAngle;\n      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {\n        data.isScrolling = false;\n      } else {\n        // eslint-disable-next-line\n        if (diffX * diffX + diffY * diffY >= 25) {\n          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;\n          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;\n        }\n      }\n    }\n    if (data.isScrolling) {\n      swiper.emit('touchMoveOpposite', e);\n    }\n    if (typeof data.startMoving === 'undefined') {\n      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {\n        data.startMoving = true;\n      }\n    }\n    if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {\n      data.isTouched = false;\n      return;\n    }\n    if (!data.startMoving) {\n      return;\n    }\n    swiper.allowClick = false;\n    if (!params.cssMode && e.cancelable) {\n      e.preventDefault();\n    }\n    if (params.touchMoveStopPropagation && !params.nested) {\n      e.stopPropagation();\n    }\n    let diff = swiper.isHorizontal() ? diffX : diffY;\n    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;\n    if (params.oneWayMovement) {\n      diff = Math.abs(diff) * (rtl ? 1 : -1);\n      touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);\n    }\n    touches.diff = diff;\n    diff *= params.touchRatio;\n    if (rtl) {\n      diff = -diff;\n      touchesDiff = -touchesDiff;\n    }\n    const prevTouchesDirection = swiper.touchesDirection;\n    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';\n    swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';\n    const isLoop = swiper.params.loop && !params.cssMode;\n    if (!data.isMoved) {\n      if (isLoop) {\n        swiper.loopFix({\n          direction: swiper.swipeDirection\n        });\n      }\n      data.startTranslate = swiper.getTranslate();\n      swiper.setTransition(0);\n      if (swiper.animating) {\n        const evt = new window.CustomEvent('transitionend', {\n          bubbles: true,\n          cancelable: true\n        });\n        swiper.wrapperEl.dispatchEvent(evt);\n      }\n      data.allowMomentumBounce = false;\n      // Grab Cursor\n      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n        swiper.setGrabCursor(true);\n      }\n      swiper.emit('sliderFirstMove', e);\n    }\n    let loopFixed;\n    if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {\n      // need another loop fix\n      swiper.loopFix({\n        direction: swiper.swipeDirection,\n        setTranslate: true\n      });\n      loopFixed = true;\n    }\n    swiper.emit('sliderMove', e);\n    data.isMoved = true;\n    data.currentTranslate = diff + data.startTranslate;\n    let disableParentSwiper = true;\n    let resistanceRatio = params.resistanceRatio;\n    if (params.touchReleaseOnEdges) {\n      resistanceRatio = 0;\n    }\n    if (diff > 0) {\n      if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) {\n        swiper.loopFix({\n          direction: 'prev',\n          setTranslate: true,\n          activeSlideIndex: 0\n        });\n      }\n      if (data.currentTranslate > swiper.minTranslate()) {\n        disableParentSwiper = false;\n        if (params.resistance) {\n          data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;\n        }\n      }\n    } else if (diff < 0) {\n      if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) {\n        swiper.loopFix({\n          direction: 'next',\n          setTranslate: true,\n          activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))\n        });\n      }\n      if (data.currentTranslate < swiper.maxTranslate()) {\n        disableParentSwiper = false;\n        if (params.resistance) {\n          data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;\n        }\n      }\n    }\n    if (disableParentSwiper) {\n      e.preventedByNestedSwiper = true;\n    }\n\n    // Directions locks\n    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {\n      data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {\n      data.currentTranslate = data.startTranslate;\n    }\n    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {\n      data.currentTranslate = data.startTranslate;\n    }\n\n    // Threshold\n    if (params.threshold > 0) {\n      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {\n        if (!data.allowThresholdMove) {\n          data.allowThresholdMove = true;\n          touches.startX = touches.currentX;\n          touches.startY = touches.currentY;\n          data.currentTranslate = data.startTranslate;\n          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;\n          return;\n        }\n      } else {\n        data.currentTranslate = data.startTranslate;\n        return;\n      }\n    }\n    if (!params.followFinger || params.cssMode) return;\n\n    // Update active index in free mode\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {\n      swiper.freeMode.onTouchMove();\n    }\n    // Update progress\n    swiper.updateProgress(data.currentTranslate);\n    // Update translate\n    swiper.setTranslate(data.currentTranslate);\n  }\n\n  function onTouchEnd(event) {\n    const swiper = this;\n    const data = swiper.touchEventsData;\n    const pointerIndex = data.evCache.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n    if (pointerIndex >= 0) {\n      data.evCache.splice(pointerIndex, 1);\n    }\n    if (['pointercancel', 'pointerout', 'pointerleave'].includes(event.type)) {\n      const proceed = event.type === 'pointercancel' && (swiper.browser.isSafari || swiper.browser.isWebView);\n      if (!proceed) {\n        return;\n      }\n    }\n    const {\n      params,\n      touches,\n      rtlTranslate: rtl,\n      slidesGrid,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    if (!params.simulateTouch && event.pointerType === 'mouse') return;\n    let e = event;\n    if (e.originalEvent) e = e.originalEvent;\n    if (data.allowTouchCallbacks) {\n      swiper.emit('touchEnd', e);\n    }\n    data.allowTouchCallbacks = false;\n    if (!data.isTouched) {\n      if (data.isMoved && params.grabCursor) {\n        swiper.setGrabCursor(false);\n      }\n      data.isMoved = false;\n      data.startMoving = false;\n      return;\n    }\n    // Return Grab Cursor\n    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n      swiper.setGrabCursor(false);\n    }\n\n    // Time diff\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n\n    // Tap, doubleTap, Click\n    if (swiper.allowClick) {\n      const pathTree = e.path || e.composedPath && e.composedPath();\n      swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);\n      swiper.emit('tap click', e);\n      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n        swiper.emit('doubleTap doubleClick', e);\n      }\n    }\n    data.lastClickTime = now();\n    nextTick(() => {\n      if (!swiper.destroyed) swiper.allowClick = true;\n    });\n    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n      data.isTouched = false;\n      data.isMoved = false;\n      data.startMoving = false;\n      return;\n    }\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    let currentPos;\n    if (params.followFinger) {\n      currentPos = rtl ? swiper.translate : -swiper.translate;\n    } else {\n      currentPos = -data.currentTranslate;\n    }\n    if (params.cssMode) {\n      return;\n    }\n    if (params.freeMode && params.freeMode.enabled) {\n      swiper.freeMode.onTouchEnd({\n        currentPos\n      });\n      return;\n    }\n\n    // Find current slide\n    let stopIndex = 0;\n    let groupSize = swiper.slidesSizesGrid[0];\n    for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n      const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n      if (typeof slidesGrid[i + increment] !== 'undefined') {\n        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n          stopIndex = i;\n          groupSize = slidesGrid[i + increment] - slidesGrid[i];\n        }\n      } else if (currentPos >= slidesGrid[i]) {\n        stopIndex = i;\n        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n      }\n    }\n    let rewindFirstIndex = null;\n    let rewindLastIndex = null;\n    if (params.rewind) {\n      if (swiper.isBeginning) {\n        rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;\n      } else if (swiper.isEnd) {\n        rewindFirstIndex = 0;\n      }\n    }\n    // Find current slide size\n    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n    if (timeDiff > params.longSwipesMs) {\n      // Long touches\n      if (!params.longSwipes) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n      if (swiper.swipeDirection === 'next') {\n        if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        if (ratio > 1 - params.longSwipesRatio) {\n          swiper.slideTo(stopIndex + increment);\n        } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {\n          swiper.slideTo(rewindLastIndex);\n        } else {\n          swiper.slideTo(stopIndex);\n        }\n      }\n    } else {\n      // Short swipes\n      if (!params.shortSwipes) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n      if (!isNavButtonTarget) {\n        if (swiper.swipeDirection === 'next') {\n          swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);\n        }\n        if (swiper.swipeDirection === 'prev') {\n          swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);\n        }\n      } else if (e.target === swiper.navigation.nextEl) {\n        swiper.slideTo(stopIndex + increment);\n      } else {\n        swiper.slideTo(stopIndex);\n      }\n    }\n  }\n\n  function onResize() {\n    const swiper = this;\n    const {\n      params,\n      el\n    } = swiper;\n    if (el && el.offsetWidth === 0) return;\n\n    // Breakpoints\n    if (params.breakpoints) {\n      swiper.setBreakpoint();\n    }\n\n    // Save locks\n    const {\n      allowSlideNext,\n      allowSlidePrev,\n      snapGrid\n    } = swiper;\n    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n    // Disable locks on resize\n    swiper.allowSlideNext = true;\n    swiper.allowSlidePrev = true;\n    swiper.updateSize();\n    swiper.updateSlides();\n    swiper.updateSlidesClasses();\n    const isVirtualLoop = isVirtual && params.loop;\n    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {\n      swiper.slideTo(swiper.slides.length - 1, 0, false, true);\n    } else {\n      if (swiper.params.loop && !isVirtual) {\n        swiper.slideToLoop(swiper.realIndex, 0, false, true);\n      } else {\n        swiper.slideTo(swiper.activeIndex, 0, false, true);\n      }\n    }\n    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n      clearTimeout(swiper.autoplay.resizeTimeout);\n      swiper.autoplay.resizeTimeout = setTimeout(() => {\n        if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {\n          swiper.autoplay.resume();\n        }\n      }, 500);\n    }\n    // Return locks after resize\n    swiper.allowSlidePrev = allowSlidePrev;\n    swiper.allowSlideNext = allowSlideNext;\n    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {\n      swiper.checkOverflow();\n    }\n  }\n\n  function onClick(e) {\n    const swiper = this;\n    if (!swiper.enabled) return;\n    if (!swiper.allowClick) {\n      if (swiper.params.preventClicks) e.preventDefault();\n      if (swiper.params.preventClicksPropagation && swiper.animating) {\n        e.stopPropagation();\n        e.stopImmediatePropagation();\n      }\n    }\n  }\n\n  function onScroll() {\n    const swiper = this;\n    const {\n      wrapperEl,\n      rtlTranslate,\n      enabled\n    } = swiper;\n    if (!enabled) return;\n    swiper.previousTranslate = swiper.translate;\n    if (swiper.isHorizontal()) {\n      swiper.translate = -wrapperEl.scrollLeft;\n    } else {\n      swiper.translate = -wrapperEl.scrollTop;\n    }\n    // eslint-disable-next-line\n    if (swiper.translate === 0) swiper.translate = 0;\n    swiper.updateActiveIndex();\n    swiper.updateSlidesClasses();\n    let newProgress;\n    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();\n    if (translatesDiff === 0) {\n      newProgress = 0;\n    } else {\n      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;\n    }\n    if (newProgress !== swiper.progress) {\n      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);\n    }\n    swiper.emit('setTranslate', swiper.translate, false);\n  }\n\n  function onLoad(e) {\n    const swiper = this;\n    processLazyPreloader(swiper, e.target);\n    if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {\n      return;\n    }\n    swiper.update();\n  }\n\n  let dummyEventAttached = false;\n  function dummyEventListener() {}\n  const events = (swiper, method) => {\n    const document = getDocument();\n    const {\n      params,\n      el,\n      wrapperEl,\n      device\n    } = swiper;\n    const capture = !!params.nested;\n    const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n    const swiperMethod = method;\n\n    // Touch Events\n    el[domMethod]('pointerdown', swiper.onTouchStart, {\n      passive: false\n    });\n    document[domMethod]('pointermove', swiper.onTouchMove, {\n      passive: false,\n      capture\n    });\n    document[domMethod]('pointerup', swiper.onTouchEnd, {\n      passive: true\n    });\n    document[domMethod]('pointercancel', swiper.onTouchEnd, {\n      passive: true\n    });\n    document[domMethod]('pointerout', swiper.onTouchEnd, {\n      passive: true\n    });\n    document[domMethod]('pointerleave', swiper.onTouchEnd, {\n      passive: true\n    });\n\n    // Prevent Links Clicks\n    if (params.preventClicks || params.preventClicksPropagation) {\n      el[domMethod]('click', swiper.onClick, true);\n    }\n    if (params.cssMode) {\n      wrapperEl[domMethod]('scroll', swiper.onScroll);\n    }\n\n    // Resize handler\n    if (params.updateOnWindowResize) {\n      swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);\n    } else {\n      swiper[swiperMethod]('observerUpdate', onResize, true);\n    }\n\n    // Images loader\n    el[domMethod]('load', swiper.onLoad, {\n      capture: true\n    });\n  };\n  function attachEvents() {\n    const swiper = this;\n    const document = getDocument();\n    const {\n      params\n    } = swiper;\n    swiper.onTouchStart = onTouchStart.bind(swiper);\n    swiper.onTouchMove = onTouchMove.bind(swiper);\n    swiper.onTouchEnd = onTouchEnd.bind(swiper);\n    if (params.cssMode) {\n      swiper.onScroll = onScroll.bind(swiper);\n    }\n    swiper.onClick = onClick.bind(swiper);\n    swiper.onLoad = onLoad.bind(swiper);\n    if (!dummyEventAttached) {\n      document.addEventListener('touchstart', dummyEventListener);\n      dummyEventAttached = true;\n    }\n    events(swiper, 'on');\n  }\n  function detachEvents() {\n    const swiper = this;\n    events(swiper, 'off');\n  }\n  var events$1 = {\n    attachEvents,\n    detachEvents\n  };\n\n  const isGridEnabled = (swiper, params) => {\n    return swiper.grid && params.grid && params.grid.rows > 1;\n  };\n  function setBreakpoint() {\n    const swiper = this;\n    const {\n      realIndex,\n      initialized,\n      params,\n      el\n    } = swiper;\n    const breakpoints = params.breakpoints;\n    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;\n\n    // Get breakpoint for window width and update parameters\n    const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);\n    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;\n    const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;\n    const breakpointParams = breakpointOnlyParams || swiper.originalParams;\n    const wasMultiRow = isGridEnabled(swiper, params);\n    const isMultiRow = isGridEnabled(swiper, breakpointParams);\n    const wasEnabled = params.enabled;\n    if (wasMultiRow && !isMultiRow) {\n      el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);\n      swiper.emitContainerClasses();\n    } else if (!wasMultiRow && isMultiRow) {\n      el.classList.add(`${params.containerModifierClass}grid`);\n      if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {\n        el.classList.add(`${params.containerModifierClass}grid-column`);\n      }\n      swiper.emitContainerClasses();\n    }\n\n    // Toggle navigation, pagination, scrollbar\n    ['navigation', 'pagination', 'scrollbar'].forEach(prop => {\n      if (typeof breakpointParams[prop] === 'undefined') return;\n      const wasModuleEnabled = params[prop] && params[prop].enabled;\n      const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;\n      if (wasModuleEnabled && !isModuleEnabled) {\n        swiper[prop].disable();\n      }\n      if (!wasModuleEnabled && isModuleEnabled) {\n        swiper[prop].enable();\n      }\n    });\n    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;\n    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);\n    if (directionChanged && initialized) {\n      swiper.changeDirection();\n    }\n    extend(swiper.params, breakpointParams);\n    const isEnabled = swiper.params.enabled;\n    Object.assign(swiper, {\n      allowTouchMove: swiper.params.allowTouchMove,\n      allowSlideNext: swiper.params.allowSlideNext,\n      allowSlidePrev: swiper.params.allowSlidePrev\n    });\n    if (wasEnabled && !isEnabled) {\n      swiper.disable();\n    } else if (!wasEnabled && isEnabled) {\n      swiper.enable();\n    }\n    swiper.currentBreakpoint = breakpoint;\n    swiper.emit('_beforeBreakpoint', breakpointParams);\n    if (needsReLoop && initialized) {\n      swiper.loopDestroy();\n      swiper.loopCreate(realIndex);\n      swiper.updateSlides();\n    }\n    swiper.emit('breakpoint', breakpointParams);\n  }\n\n  function getBreakpoint(breakpoints, base, containerEl) {\n    if (base === void 0) {\n      base = 'window';\n    }\n    if (!breakpoints || base === 'container' && !containerEl) return undefined;\n    let breakpoint = false;\n    const window = getWindow();\n    const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;\n    const points = Object.keys(breakpoints).map(point => {\n      if (typeof point === 'string' && point.indexOf('@') === 0) {\n        const minRatio = parseFloat(point.substr(1));\n        const value = currentHeight * minRatio;\n        return {\n          value,\n          point\n        };\n      }\n      return {\n        value: point,\n        point\n      };\n    });\n    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));\n    for (let i = 0; i < points.length; i += 1) {\n      const {\n        point,\n        value\n      } = points[i];\n      if (base === 'window') {\n        if (window.matchMedia(`(min-width: ${value}px)`).matches) {\n          breakpoint = point;\n        }\n      } else if (value <= containerEl.clientWidth) {\n        breakpoint = point;\n      }\n    }\n    return breakpoint || 'max';\n  }\n\n  var breakpoints = {\n    setBreakpoint,\n    getBreakpoint\n  };\n\n  function prepareClasses(entries, prefix) {\n    const resultClasses = [];\n    entries.forEach(item => {\n      if (typeof item === 'object') {\n        Object.keys(item).forEach(classNames => {\n          if (item[classNames]) {\n            resultClasses.push(prefix + classNames);\n          }\n        });\n      } else if (typeof item === 'string') {\n        resultClasses.push(prefix + item);\n      }\n    });\n    return resultClasses;\n  }\n  function addClasses() {\n    const swiper = this;\n    const {\n      classNames,\n      params,\n      rtl,\n      el,\n      device\n    } = swiper;\n    // prettier-ignore\n    const suffixes = prepareClasses(['initialized', params.direction, {\n      'free-mode': swiper.params.freeMode && params.freeMode.enabled\n    }, {\n      'autoheight': params.autoHeight\n    }, {\n      'rtl': rtl\n    }, {\n      'grid': params.grid && params.grid.rows > 1\n    }, {\n      'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'\n    }, {\n      'android': device.android\n    }, {\n      'ios': device.ios\n    }, {\n      'css-mode': params.cssMode\n    }, {\n      'centered': params.cssMode && params.centeredSlides\n    }, {\n      'watch-progress': params.watchSlidesProgress\n    }], params.containerModifierClass);\n    classNames.push(...suffixes);\n    el.classList.add(...classNames);\n    swiper.emitContainerClasses();\n  }\n\n  function removeClasses() {\n    const swiper = this;\n    const {\n      el,\n      classNames\n    } = swiper;\n    el.classList.remove(...classNames);\n    swiper.emitContainerClasses();\n  }\n\n  var classes = {\n    addClasses,\n    removeClasses\n  };\n\n  function checkOverflow() {\n    const swiper = this;\n    const {\n      isLocked: wasLocked,\n      params\n    } = swiper;\n    const {\n      slidesOffsetBefore\n    } = params;\n    if (slidesOffsetBefore) {\n      const lastSlideIndex = swiper.slides.length - 1;\n      const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;\n      swiper.isLocked = swiper.size > lastSlideRightEdge;\n    } else {\n      swiper.isLocked = swiper.snapGrid.length === 1;\n    }\n    if (params.allowSlideNext === true) {\n      swiper.allowSlideNext = !swiper.isLocked;\n    }\n    if (params.allowSlidePrev === true) {\n      swiper.allowSlidePrev = !swiper.isLocked;\n    }\n    if (wasLocked && wasLocked !== swiper.isLocked) {\n      swiper.isEnd = false;\n    }\n    if (wasLocked !== swiper.isLocked) {\n      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');\n    }\n  }\n  var checkOverflow$1 = {\n    checkOverflow\n  };\n\n  var defaults = {\n    init: true,\n    direction: 'horizontal',\n    oneWayMovement: false,\n    touchEventsTarget: 'wrapper',\n    initialSlide: 0,\n    speed: 300,\n    cssMode: false,\n    updateOnWindowResize: true,\n    resizeObserver: true,\n    nested: false,\n    createElements: false,\n    enabled: true,\n    focusableElements: 'input, select, option, textarea, button, video, label',\n    // Overrides\n    width: null,\n    height: null,\n    //\n    preventInteractionOnTransition: false,\n    // ssr\n    userAgent: null,\n    url: null,\n    // To support iOS's swipe-to-go-back gesture (when being used in-app).\n    edgeSwipeDetection: false,\n    edgeSwipeThreshold: 20,\n    // Autoheight\n    autoHeight: false,\n    // Set wrapper width\n    setWrapperSize: false,\n    // Virtual Translate\n    virtualTranslate: false,\n    // Effects\n    effect: 'slide',\n    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'\n\n    // Breakpoints\n    breakpoints: undefined,\n    breakpointsBase: 'window',\n    // Slides grid\n    spaceBetween: 0,\n    slidesPerView: 1,\n    slidesPerGroup: 1,\n    slidesPerGroupSkip: 0,\n    slidesPerGroupAuto: false,\n    centeredSlides: false,\n    centeredSlidesBounds: false,\n    slidesOffsetBefore: 0,\n    // in px\n    slidesOffsetAfter: 0,\n    // in px\n    normalizeSlideIndex: true,\n    centerInsufficientSlides: false,\n    // Disable swiper and hide navigation when container not overflow\n    watchOverflow: true,\n    // Round length\n    roundLengths: false,\n    // Touches\n    touchRatio: 1,\n    touchAngle: 45,\n    simulateTouch: true,\n    shortSwipes: true,\n    longSwipes: true,\n    longSwipesRatio: 0.5,\n    longSwipesMs: 300,\n    followFinger: true,\n    allowTouchMove: true,\n    threshold: 5,\n    touchMoveStopPropagation: false,\n    touchStartPreventDefault: true,\n    touchStartForcePreventDefault: false,\n    touchReleaseOnEdges: false,\n    // Unique Navigation Elements\n    uniqueNavElements: true,\n    // Resistance\n    resistance: true,\n    resistanceRatio: 0.85,\n    // Progress\n    watchSlidesProgress: false,\n    // Cursor\n    grabCursor: false,\n    // Clicks\n    preventClicks: true,\n    preventClicksPropagation: true,\n    slideToClickedSlide: false,\n    // loop\n    loop: false,\n    loopedSlides: null,\n    loopPreventsSliding: true,\n    // rewind\n    rewind: false,\n    // Swiping/no swiping\n    allowSlidePrev: true,\n    allowSlideNext: true,\n    swipeHandler: null,\n    // '.swipe-handler',\n    noSwiping: true,\n    noSwipingClass: 'swiper-no-swiping',\n    noSwipingSelector: null,\n    // Passive Listeners\n    passiveListeners: true,\n    maxBackfaceHiddenSlides: 10,\n    // NS\n    containerModifierClass: 'swiper-',\n    // NEW\n    slideClass: 'swiper-slide',\n    slideActiveClass: 'swiper-slide-active',\n    slideVisibleClass: 'swiper-slide-visible',\n    slideNextClass: 'swiper-slide-next',\n    slidePrevClass: 'swiper-slide-prev',\n    wrapperClass: 'swiper-wrapper',\n    lazyPreloaderClass: 'swiper-lazy-preloader',\n    lazyPreloadPrevNext: 0,\n    // Callbacks\n    runCallbacksOnInit: true,\n    // Internals\n    _emitClasses: false\n  };\n\n  function moduleExtendParams(params, allModulesParams) {\n    return function extendParams(obj) {\n      if (obj === void 0) {\n        obj = {};\n      }\n      const moduleParamName = Object.keys(obj)[0];\n      const moduleParams = obj[moduleParamName];\n      if (typeof moduleParams !== 'object' || moduleParams === null) {\n        extend(allModulesParams, obj);\n        return;\n      }\n      if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {\n        params[moduleParamName] = {\n          auto: true\n        };\n      }\n      if (!(moduleParamName in params && 'enabled' in moduleParams)) {\n        extend(allModulesParams, obj);\n        return;\n      }\n      if (params[moduleParamName] === true) {\n        params[moduleParamName] = {\n          enabled: true\n        };\n      }\n      if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {\n        params[moduleParamName].enabled = true;\n      }\n      if (!params[moduleParamName]) params[moduleParamName] = {\n        enabled: false\n      };\n      extend(allModulesParams, obj);\n    };\n  }\n\n  /* eslint no-param-reassign: \"off\" */\n  const prototypes = {\n    eventsEmitter,\n    update,\n    translate,\n    transition,\n    slide,\n    loop,\n    grabCursor,\n    events: events$1,\n    breakpoints,\n    checkOverflow: checkOverflow$1,\n    classes\n  };\n  const extendedDefaults = {};\n  class Swiper {\n    constructor() {\n      let el;\n      let params;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {\n        params = args[0];\n      } else {\n        [el, params] = args;\n      }\n      if (!params) params = {};\n      params = extend({}, params);\n      if (el && !params.el) params.el = el;\n      const document = getDocument();\n      if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {\n        const swipers = [];\n        document.querySelectorAll(params.el).forEach(containerEl => {\n          const newParams = extend({}, params, {\n            el: containerEl\n          });\n          swipers.push(new Swiper(newParams));\n        });\n        // eslint-disable-next-line no-constructor-return\n        return swipers;\n      }\n\n      // Swiper Instance\n      const swiper = this;\n      swiper.__swiper__ = true;\n      swiper.support = getSupport();\n      swiper.device = getDevice({\n        userAgent: params.userAgent\n      });\n      swiper.browser = getBrowser();\n      swiper.eventsListeners = {};\n      swiper.eventsAnyListeners = [];\n      swiper.modules = [...swiper.__modules__];\n      if (params.modules && Array.isArray(params.modules)) {\n        swiper.modules.push(...params.modules);\n      }\n      const allModulesParams = {};\n      swiper.modules.forEach(mod => {\n        mod({\n          params,\n          swiper,\n          extendParams: moduleExtendParams(params, allModulesParams),\n          on: swiper.on.bind(swiper),\n          once: swiper.once.bind(swiper),\n          off: swiper.off.bind(swiper),\n          emit: swiper.emit.bind(swiper)\n        });\n      });\n\n      // Extend defaults with modules params\n      const swiperParams = extend({}, defaults, allModulesParams);\n\n      // Extend defaults with passed params\n      swiper.params = extend({}, swiperParams, extendedDefaults, params);\n      swiper.originalParams = extend({}, swiper.params);\n      swiper.passedParams = extend({}, params);\n\n      // add event listeners\n      if (swiper.params && swiper.params.on) {\n        Object.keys(swiper.params.on).forEach(eventName => {\n          swiper.on(eventName, swiper.params.on[eventName]);\n        });\n      }\n      if (swiper.params && swiper.params.onAny) {\n        swiper.onAny(swiper.params.onAny);\n      }\n\n      // Extend Swiper\n      Object.assign(swiper, {\n        enabled: swiper.params.enabled,\n        el,\n        // Classes\n        classNames: [],\n        // Slides\n        slides: [],\n        slidesGrid: [],\n        snapGrid: [],\n        slidesSizesGrid: [],\n        // isDirection\n        isHorizontal() {\n          return swiper.params.direction === 'horizontal';\n        },\n        isVertical() {\n          return swiper.params.direction === 'vertical';\n        },\n        // Indexes\n        activeIndex: 0,\n        realIndex: 0,\n        //\n        isBeginning: true,\n        isEnd: false,\n        // Props\n        translate: 0,\n        previousTranslate: 0,\n        progress: 0,\n        velocity: 0,\n        animating: false,\n        cssOverflowAdjustment() {\n          // Returns 0 unless `translate` is > 2**23\n          // Should be subtracted from css values to prevent overflow\n          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;\n        },\n        // Locks\n        allowSlideNext: swiper.params.allowSlideNext,\n        allowSlidePrev: swiper.params.allowSlidePrev,\n        // Touch Events\n        touchEventsData: {\n          isTouched: undefined,\n          isMoved: undefined,\n          allowTouchCallbacks: undefined,\n          touchStartTime: undefined,\n          isScrolling: undefined,\n          currentTranslate: undefined,\n          startTranslate: undefined,\n          allowThresholdMove: undefined,\n          // Form elements to match\n          focusableElements: swiper.params.focusableElements,\n          // Last click time\n          lastClickTime: 0,\n          clickTimeout: undefined,\n          // Velocities\n          velocities: [],\n          allowMomentumBounce: undefined,\n          startMoving: undefined,\n          evCache: []\n        },\n        // Clicks\n        allowClick: true,\n        // Touches\n        allowTouchMove: swiper.params.allowTouchMove,\n        touches: {\n          startX: 0,\n          startY: 0,\n          currentX: 0,\n          currentY: 0,\n          diff: 0\n        },\n        // Images\n        imagesToLoad: [],\n        imagesLoaded: 0\n      });\n      swiper.emit('_swiper');\n\n      // Init\n      if (swiper.params.init) {\n        swiper.init();\n      }\n\n      // Return app instance\n      // eslint-disable-next-line no-constructor-return\n      return swiper;\n    }\n    getSlideIndex(slideEl) {\n      const {\n        slidesEl,\n        params\n      } = this;\n      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n      const firstSlideIndex = elementIndex(slides[0]);\n      return elementIndex(slideEl) - firstSlideIndex;\n    }\n    getSlideIndexByData(index) {\n      return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);\n    }\n    recalcSlides() {\n      const swiper = this;\n      const {\n        slidesEl,\n        params\n      } = swiper;\n      swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);\n    }\n    enable() {\n      const swiper = this;\n      if (swiper.enabled) return;\n      swiper.enabled = true;\n      if (swiper.params.grabCursor) {\n        swiper.setGrabCursor();\n      }\n      swiper.emit('enable');\n    }\n    disable() {\n      const swiper = this;\n      if (!swiper.enabled) return;\n      swiper.enabled = false;\n      if (swiper.params.grabCursor) {\n        swiper.unsetGrabCursor();\n      }\n      swiper.emit('disable');\n    }\n    setProgress(progress, speed) {\n      const swiper = this;\n      progress = Math.min(Math.max(progress, 0), 1);\n      const min = swiper.minTranslate();\n      const max = swiper.maxTranslate();\n      const current = (max - min) * progress + min;\n      swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    emitContainerClasses() {\n      const swiper = this;\n      if (!swiper.params._emitClasses || !swiper.el) return;\n      const cls = swiper.el.className.split(' ').filter(className => {\n        return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;\n      });\n      swiper.emit('_containerClasses', cls.join(' '));\n    }\n    getSlideClasses(slideEl) {\n      const swiper = this;\n      if (swiper.destroyed) return '';\n      return slideEl.className.split(' ').filter(className => {\n        return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;\n      }).join(' ');\n    }\n    emitSlidesClasses() {\n      const swiper = this;\n      if (!swiper.params._emitClasses || !swiper.el) return;\n      const updates = [];\n      swiper.slides.forEach(slideEl => {\n        const classNames = swiper.getSlideClasses(slideEl);\n        updates.push({\n          slideEl,\n          classNames\n        });\n        swiper.emit('_slideClass', slideEl, classNames);\n      });\n      swiper.emit('_slideClasses', updates);\n    }\n    slidesPerViewDynamic(view, exact) {\n      if (view === void 0) {\n        view = 'current';\n      }\n      if (exact === void 0) {\n        exact = false;\n      }\n      const swiper = this;\n      const {\n        params,\n        slides,\n        slidesGrid,\n        slidesSizesGrid,\n        size: swiperSize,\n        activeIndex\n      } = swiper;\n      let spv = 1;\n      if (params.centeredSlides) {\n        let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;\n        let breakLoop;\n        for (let i = activeIndex + 1; i < slides.length; i += 1) {\n          if (slides[i] && !breakLoop) {\n            slideSize += slides[i].swiperSlideSize;\n            spv += 1;\n            if (slideSize > swiperSize) breakLoop = true;\n          }\n        }\n        for (let i = activeIndex - 1; i >= 0; i -= 1) {\n          if (slides[i] && !breakLoop) {\n            slideSize += slides[i].swiperSlideSize;\n            spv += 1;\n            if (slideSize > swiperSize) breakLoop = true;\n          }\n        }\n      } else {\n        // eslint-disable-next-line\n        if (view === 'current') {\n          for (let i = activeIndex + 1; i < slides.length; i += 1) {\n            const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;\n            if (slideInView) {\n              spv += 1;\n            }\n          }\n        } else {\n          // previous\n          for (let i = activeIndex - 1; i >= 0; i -= 1) {\n            const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;\n            if (slideInView) {\n              spv += 1;\n            }\n          }\n        }\n      }\n      return spv;\n    }\n    update() {\n      const swiper = this;\n      if (!swiper || swiper.destroyed) return;\n      const {\n        snapGrid,\n        params\n      } = swiper;\n      // Breakpoints\n      if (params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n      [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n        if (imageEl.complete) {\n          processLazyPreloader(swiper, imageEl);\n        }\n      });\n      swiper.updateSize();\n      swiper.updateSlides();\n      swiper.updateProgress();\n      swiper.updateSlidesClasses();\n      function setTranslate() {\n        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;\n        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());\n        swiper.setTranslate(newTranslate);\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n      let translated;\n      if (params.freeMode && params.freeMode.enabled && !params.cssMode) {\n        setTranslate();\n        if (params.autoHeight) {\n          swiper.updateAutoHeight();\n        }\n      } else {\n        if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {\n          const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;\n          translated = swiper.slideTo(slides.length - 1, 0, false, true);\n        } else {\n          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);\n        }\n        if (!translated) {\n          setTranslate();\n        }\n      }\n      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {\n        swiper.checkOverflow();\n      }\n      swiper.emit('update');\n    }\n    changeDirection(newDirection, needUpdate) {\n      if (needUpdate === void 0) {\n        needUpdate = true;\n      }\n      const swiper = this;\n      const currentDirection = swiper.params.direction;\n      if (!newDirection) {\n        // eslint-disable-next-line\n        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';\n      }\n      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {\n        return swiper;\n      }\n      swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);\n      swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);\n      swiper.emitContainerClasses();\n      swiper.params.direction = newDirection;\n      swiper.slides.forEach(slideEl => {\n        if (newDirection === 'vertical') {\n          slideEl.style.width = '';\n        } else {\n          slideEl.style.height = '';\n        }\n      });\n      swiper.emit('changeDirection');\n      if (needUpdate) swiper.update();\n      return swiper;\n    }\n    changeLanguageDirection(direction) {\n      const swiper = this;\n      if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;\n      swiper.rtl = direction === 'rtl';\n      swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;\n      if (swiper.rtl) {\n        swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);\n        swiper.el.dir = 'rtl';\n      } else {\n        swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);\n        swiper.el.dir = 'ltr';\n      }\n      swiper.update();\n    }\n    mount(element) {\n      const swiper = this;\n      if (swiper.mounted) return true;\n\n      // Find el\n      let el = element || swiper.params.el;\n      if (typeof el === 'string') {\n        el = document.querySelector(el);\n      }\n      if (!el) {\n        return false;\n      }\n      el.swiper = swiper;\n      if (el.parentNode && el.parentNode.host) {\n        swiper.isElement = true;\n      }\n      const getWrapperSelector = () => {\n        return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;\n      };\n      const getWrapper = () => {\n        if (el && el.shadowRoot && el.shadowRoot.querySelector) {\n          const res = el.shadowRoot.querySelector(getWrapperSelector());\n          // Children needs to return slot items\n          return res;\n        }\n        return elementChildren(el, getWrapperSelector())[0];\n      };\n      // Find Wrapper\n      let wrapperEl = getWrapper();\n      if (!wrapperEl && swiper.params.createElements) {\n        wrapperEl = createElement('div', swiper.params.wrapperClass);\n        el.append(wrapperEl);\n        elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {\n          wrapperEl.append(slideEl);\n        });\n      }\n      Object.assign(swiper, {\n        el,\n        wrapperEl,\n        slidesEl: swiper.isElement ? el.parentNode.host : wrapperEl,\n        hostEl: swiper.isElement ? el.parentNode.host : el,\n        mounted: true,\n        // RTL\n        rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',\n        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),\n        wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'\n      });\n      return true;\n    }\n    init(el) {\n      const swiper = this;\n      if (swiper.initialized) return swiper;\n      const mounted = swiper.mount(el);\n      if (mounted === false) return swiper;\n      swiper.emit('beforeInit');\n\n      // Set breakpoint\n      if (swiper.params.breakpoints) {\n        swiper.setBreakpoint();\n      }\n\n      // Add Classes\n      swiper.addClasses();\n\n      // Update size\n      swiper.updateSize();\n\n      // Update slides\n      swiper.updateSlides();\n      if (swiper.params.watchOverflow) {\n        swiper.checkOverflow();\n      }\n\n      // Set Grab Cursor\n      if (swiper.params.grabCursor && swiper.enabled) {\n        swiper.setGrabCursor();\n      }\n\n      // Slide To Initial Slide\n      if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {\n        swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);\n      } else {\n        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);\n      }\n\n      // Create loop\n      if (swiper.params.loop) {\n        swiper.loopCreate();\n      }\n\n      // Attach events\n      swiper.attachEvents();\n      [...swiper.el.querySelectorAll('[loading=\"lazy\"]')].forEach(imageEl => {\n        if (imageEl.complete) {\n          processLazyPreloader(swiper, imageEl);\n        } else {\n          imageEl.addEventListener('load', e => {\n            processLazyPreloader(swiper, e.target);\n          });\n        }\n      });\n      preload(swiper);\n\n      // Init Flag\n      swiper.initialized = true;\n      preload(swiper);\n\n      // Emit\n      swiper.emit('init');\n      swiper.emit('afterInit');\n      return swiper;\n    }\n    destroy(deleteInstance, cleanStyles) {\n      if (deleteInstance === void 0) {\n        deleteInstance = true;\n      }\n      if (cleanStyles === void 0) {\n        cleanStyles = true;\n      }\n      const swiper = this;\n      const {\n        params,\n        el,\n        wrapperEl,\n        slides\n      } = swiper;\n      if (typeof swiper.params === 'undefined' || swiper.destroyed) {\n        return null;\n      }\n      swiper.emit('beforeDestroy');\n\n      // Init Flag\n      swiper.initialized = false;\n\n      // Detach events\n      swiper.detachEvents();\n\n      // Destroy loop\n      if (params.loop) {\n        swiper.loopDestroy();\n      }\n\n      // Cleanup styles\n      if (cleanStyles) {\n        swiper.removeClasses();\n        el.removeAttribute('style');\n        wrapperEl.removeAttribute('style');\n        if (slides && slides.length) {\n          slides.forEach(slideEl => {\n            slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);\n            slideEl.removeAttribute('style');\n            slideEl.removeAttribute('data-swiper-slide-index');\n          });\n        }\n      }\n      swiper.emit('destroy');\n\n      // Detach emitter events\n      Object.keys(swiper.eventsListeners).forEach(eventName => {\n        swiper.off(eventName);\n      });\n      if (deleteInstance !== false) {\n        swiper.el.swiper = null;\n        deleteProps(swiper);\n      }\n      swiper.destroyed = true;\n      return null;\n    }\n    static extendDefaults(newDefaults) {\n      extend(extendedDefaults, newDefaults);\n    }\n    static get extendedDefaults() {\n      return extendedDefaults;\n    }\n    static get defaults() {\n      return defaults;\n    }\n    static installModule(mod) {\n      if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];\n      const modules = Swiper.prototype.__modules__;\n      if (typeof mod === 'function' && modules.indexOf(mod) < 0) {\n        modules.push(mod);\n      }\n    }\n    static use(module) {\n      if (Array.isArray(module)) {\n        module.forEach(m => Swiper.installModule(m));\n        return Swiper;\n      }\n      Swiper.installModule(module);\n      return Swiper;\n    }\n  }\n  Object.keys(prototypes).forEach(prototypeGroup => {\n    Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {\n      Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];\n    });\n  });\n  Swiper.use([Resize, Observer]);\n\n  function Virtual(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    extendParams({\n      virtual: {\n        enabled: false,\n        slides: [],\n        cache: true,\n        renderSlide: null,\n        renderExternal: null,\n        renderExternalUpdate: true,\n        addSlidesBefore: 0,\n        addSlidesAfter: 0\n      }\n    });\n    let cssModeTimeout;\n    const document = getDocument();\n    swiper.virtual = {\n      cache: {},\n      from: undefined,\n      to: undefined,\n      slides: [],\n      offset: 0,\n      slidesGrid: []\n    };\n    const tempDOM = document.createElement('div');\n    function renderSlide(slide, index) {\n      const params = swiper.params.virtual;\n      if (params.cache && swiper.virtual.cache[index]) {\n        return swiper.virtual.cache[index];\n      }\n      // eslint-disable-next-line\n      let slideEl;\n      if (params.renderSlide) {\n        slideEl = params.renderSlide.call(swiper, slide, index);\n        if (typeof slideEl === 'string') {\n          tempDOM.innerHTML = slideEl;\n          slideEl = tempDOM.children[0];\n        }\n      } else if (swiper.isElement) {\n        slideEl = createElement('swiper-slide');\n      } else {\n        slideEl = createElement('div', swiper.params.slideClass);\n      }\n      slideEl.setAttribute('data-swiper-slide-index', index);\n      if (!params.renderSlide) {\n        slideEl.innerHTML = slide;\n      }\n      if (params.cache) swiper.virtual.cache[index] = slideEl;\n      return slideEl;\n    }\n    function update(force) {\n      const {\n        slidesPerView,\n        slidesPerGroup,\n        centeredSlides,\n        loop: isLoop\n      } = swiper.params;\n      const {\n        addSlidesBefore,\n        addSlidesAfter\n      } = swiper.params.virtual;\n      const {\n        from: previousFrom,\n        to: previousTo,\n        slides,\n        slidesGrid: previousSlidesGrid,\n        offset: previousOffset\n      } = swiper.virtual;\n      if (!swiper.params.cssMode) {\n        swiper.updateActiveIndex();\n      }\n      const activeIndex = swiper.activeIndex || 0;\n      let offsetProp;\n      if (swiper.rtlTranslate) offsetProp = 'right';else offsetProp = swiper.isHorizontal() ? 'left' : 'top';\n      let slidesAfter;\n      let slidesBefore;\n      if (centeredSlides) {\n        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;\n        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;\n      } else {\n        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;\n        slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;\n      }\n      let from = activeIndex - slidesBefore;\n      let to = activeIndex + slidesAfter;\n      if (!isLoop) {\n        from = Math.max(from, 0);\n        to = Math.min(to, slides.length - 1);\n      }\n      let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);\n      if (isLoop && activeIndex >= slidesBefore) {\n        from -= slidesBefore;\n        if (!centeredSlides) offset += swiper.slidesGrid[0];\n      } else if (isLoop && activeIndex < slidesBefore) {\n        from = -slidesBefore;\n        if (centeredSlides) offset += swiper.slidesGrid[0];\n      }\n      Object.assign(swiper.virtual, {\n        from,\n        to,\n        offset,\n        slidesGrid: swiper.slidesGrid,\n        slidesBefore,\n        slidesAfter\n      });\n      function onRendered() {\n        swiper.updateSlides();\n        swiper.updateProgress();\n        swiper.updateSlidesClasses();\n        emit('virtualUpdate');\n      }\n      if (previousFrom === from && previousTo === to && !force) {\n        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {\n          swiper.slides.forEach(slideEl => {\n            slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n          });\n        }\n        swiper.updateProgress();\n        emit('virtualUpdate');\n        return;\n      }\n      if (swiper.params.virtual.renderExternal) {\n        swiper.params.virtual.renderExternal.call(swiper, {\n          offset,\n          from,\n          to,\n          slides: function getSlides() {\n            const slidesToRender = [];\n            for (let i = from; i <= to; i += 1) {\n              slidesToRender.push(slides[i]);\n            }\n            return slidesToRender;\n          }()\n        });\n        if (swiper.params.virtual.renderExternalUpdate) {\n          onRendered();\n        } else {\n          emit('virtualUpdate');\n        }\n        return;\n      }\n      const prependIndexes = [];\n      const appendIndexes = [];\n      const getSlideIndex = index => {\n        let slideIndex = index;\n        if (index < 0) {\n          slideIndex = slides.length + index;\n        } else if (slideIndex >= slides.length) {\n          // eslint-disable-next-line\n          slideIndex = slideIndex - slides.length;\n        }\n        return slideIndex;\n      };\n      if (force) {\n        swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`).forEach(slideEl => {\n          slideEl.remove();\n        });\n      } else {\n        for (let i = previousFrom; i <= previousTo; i += 1) {\n          if (i < from || i > to) {\n            const slideIndex = getSlideIndex(i);\n            swiper.slidesEl.querySelectorAll(`.${swiper.params.slideClass}[data-swiper-slide-index=\"${slideIndex}\"], swiper-slide[data-swiper-slide-index=\"${slideIndex}\"]`).forEach(slideEl => {\n              slideEl.remove();\n            });\n          }\n        }\n      }\n      const loopFrom = isLoop ? -slides.length : 0;\n      const loopTo = isLoop ? slides.length * 2 : slides.length;\n      for (let i = loopFrom; i < loopTo; i += 1) {\n        if (i >= from && i <= to) {\n          const slideIndex = getSlideIndex(i);\n          if (typeof previousTo === 'undefined' || force) {\n            appendIndexes.push(slideIndex);\n          } else {\n            if (i > previousTo) appendIndexes.push(slideIndex);\n            if (i < previousFrom) prependIndexes.push(slideIndex);\n          }\n        }\n      }\n      appendIndexes.forEach(index => {\n        swiper.slidesEl.append(renderSlide(slides[index], index));\n      });\n      if (isLoop) {\n        for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {\n          const index = prependIndexes[i];\n          swiper.slidesEl.prepend(renderSlide(slides[index], index));\n        }\n      } else {\n        prependIndexes.sort((a, b) => b - a);\n        prependIndexes.forEach(index => {\n          swiper.slidesEl.prepend(renderSlide(slides[index], index));\n        });\n      }\n      elementChildren(swiper.slidesEl, '.swiper-slide, swiper-slide').forEach(slideEl => {\n        slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;\n      });\n      onRendered();\n    }\n    function appendSlide(slides) {\n      if (typeof slides === 'object' && 'length' in slides) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) swiper.virtual.slides.push(slides[i]);\n        }\n      } else {\n        swiper.virtual.slides.push(slides);\n      }\n      update(true);\n    }\n    function prependSlide(slides) {\n      const activeIndex = swiper.activeIndex;\n      let newActiveIndex = activeIndex + 1;\n      let numberOfNewSlides = 1;\n      if (Array.isArray(slides)) {\n        for (let i = 0; i < slides.length; i += 1) {\n          if (slides[i]) swiper.virtual.slides.unshift(slides[i]);\n        }\n        newActiveIndex = activeIndex + slides.length;\n        numberOfNewSlides = slides.length;\n      } else {\n        swiper.virtual.slides.unshift(slides);\n      }\n      if (swiper.params.virtual.cache) {\n        const cache = swiper.virtual.cache;\n        const newCache = {};\n        Object.keys(cache).forEach(cachedIndex => {\n          const cachedEl = cache[cachedIndex];\n          const cachedElIndex = cachedEl.getAttribute('data-swiper-slide-index');\n          if (cachedElIndex) {\n            cachedEl.setAttribute('data-swiper-slide-index', parseInt(cachedElIndex, 10) + numberOfNewSlides);\n          }\n          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;\n        });\n        swiper.virtual.cache = newCache;\n      }\n      update(true);\n      swiper.slideTo(newActiveIndex, 0);\n    }\n    function removeSlide(slidesIndexes) {\n      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;\n      let activeIndex = swiper.activeIndex;\n      if (Array.isArray(slidesIndexes)) {\n        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {\n          swiper.virtual.slides.splice(slidesIndexes[i], 1);\n          if (swiper.params.virtual.cache) {\n            delete swiper.virtual.cache[slidesIndexes[i]];\n          }\n          if (slidesIndexes[i] < activeIndex) activeIndex -= 1;\n          activeIndex = Math.max(activeIndex, 0);\n        }\n      } else {\n        swiper.virtual.slides.splice(slidesIndexes, 1);\n        if (swiper.params.virtual.cache) {\n          delete swiper.virtual.cache[slidesIndexes];\n        }\n        if (slidesIndexes < activeIndex) activeIndex -= 1;\n        activeIndex = Math.max(activeIndex, 0);\n      }\n      update(true);\n      swiper.slideTo(activeIndex, 0);\n    }\n    function removeAllSlides() {\n      swiper.virtual.slides = [];\n      if (swiper.params.virtual.cache) {\n        swiper.virtual.cache = {};\n      }\n      update(true);\n      swiper.slideTo(0, 0);\n    }\n    on('beforeInit', () => {\n      if (!swiper.params.virtual.enabled) return;\n      let domSlidesAssigned;\n      if (typeof swiper.passedParams.virtual.slides === 'undefined') {\n        const slides = [...swiper.slidesEl.children].filter(el => el.matches(`.${swiper.params.slideClass}, swiper-slide`));\n        if (slides && slides.length) {\n          swiper.virtual.slides = [...slides];\n          domSlidesAssigned = true;\n          slides.forEach((slideEl, slideIndex) => {\n            slideEl.setAttribute('data-swiper-slide-index', slideIndex);\n            swiper.virtual.cache[slideIndex] = slideEl;\n            slideEl.remove();\n          });\n        }\n      }\n      if (!domSlidesAssigned) {\n        swiper.virtual.slides = swiper.params.virtual.slides;\n      }\n      swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n      if (!swiper.params.initialSlide) {\n        update();\n      }\n    });\n    on('setTranslate', () => {\n      if (!swiper.params.virtual.enabled) return;\n      if (swiper.params.cssMode && !swiper._immediateVirtual) {\n        clearTimeout(cssModeTimeout);\n        cssModeTimeout = setTimeout(() => {\n          update();\n        }, 100);\n      } else {\n        update();\n      }\n    });\n    on('init update resize', () => {\n      if (!swiper.params.virtual.enabled) return;\n      if (swiper.params.cssMode) {\n        setCSSProperty(swiper.wrapperEl, '--swiper-virtual-size', `${swiper.virtualSize}px`);\n      }\n    });\n    Object.assign(swiper.virtual, {\n      appendSlide,\n      prependSlide,\n      removeSlide,\n      removeAllSlides,\n      update\n    });\n  }\n\n  /* eslint-disable consistent-return */\n  function Keyboard(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const document = getDocument();\n    const window = getWindow();\n    swiper.keyboard = {\n      enabled: false\n    };\n    extendParams({\n      keyboard: {\n        enabled: false,\n        onlyInViewport: true,\n        pageUpDown: true\n      }\n    });\n    function handle(event) {\n      if (!swiper.enabled) return;\n      const {\n        rtlTranslate: rtl\n      } = swiper;\n      let e = event;\n      if (e.originalEvent) e = e.originalEvent; // jquery fix\n      const kc = e.keyCode || e.charCode;\n      const pageUpDown = swiper.params.keyboard.pageUpDown;\n      const isPageUp = pageUpDown && kc === 33;\n      const isPageDown = pageUpDown && kc === 34;\n      const isArrowLeft = kc === 37;\n      const isArrowRight = kc === 39;\n      const isArrowUp = kc === 38;\n      const isArrowDown = kc === 40;\n      // Directions locks\n      if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {\n        return false;\n      }\n      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {\n        return false;\n      }\n      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\n        return undefined;\n      }\n      if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {\n        return undefined;\n      }\n      if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {\n        let inView = false;\n        // Check that swiper should be inside of visible area of window\n        if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {\n          return undefined;\n        }\n        const el = swiper.el;\n        const swiperWidth = el.clientWidth;\n        const swiperHeight = el.clientHeight;\n        const windowWidth = window.innerWidth;\n        const windowHeight = window.innerHeight;\n        const swiperOffset = elementOffset(el);\n        if (rtl) swiperOffset.left -= el.scrollLeft;\n        const swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiperWidth, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiperHeight], [swiperOffset.left + swiperWidth, swiperOffset.top + swiperHeight]];\n        for (let i = 0; i < swiperCoord.length; i += 1) {\n          const point = swiperCoord[i];\n          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {\n            if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line\n            inView = true;\n          }\n        }\n        if (!inView) return undefined;\n      }\n      if (swiper.isHorizontal()) {\n        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {\n          if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        }\n        if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();\n        if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();\n      } else {\n        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {\n          if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n        }\n        if (isPageDown || isArrowDown) swiper.slideNext();\n        if (isPageUp || isArrowUp) swiper.slidePrev();\n      }\n      emit('keyPress', kc);\n      return undefined;\n    }\n    function enable() {\n      if (swiper.keyboard.enabled) return;\n      document.addEventListener('keydown', handle);\n      swiper.keyboard.enabled = true;\n    }\n    function disable() {\n      if (!swiper.keyboard.enabled) return;\n      document.removeEventListener('keydown', handle);\n      swiper.keyboard.enabled = false;\n    }\n    on('init', () => {\n      if (swiper.params.keyboard.enabled) {\n        enable();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.keyboard.enabled) {\n        disable();\n      }\n    });\n    Object.assign(swiper.keyboard, {\n      enable,\n      disable\n    });\n  }\n\n  /* eslint-disable consistent-return */\n  function Mousewheel(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const window = getWindow();\n    extendParams({\n      mousewheel: {\n        enabled: false,\n        releaseOnEdges: false,\n        invert: false,\n        forceToAxis: false,\n        sensitivity: 1,\n        eventsTarget: 'container',\n        thresholdDelta: null,\n        thresholdTime: null,\n        noMousewheelClass: 'swiper-no-mousewheel'\n      }\n    });\n    swiper.mousewheel = {\n      enabled: false\n    };\n    let timeout;\n    let lastScrollTime = now();\n    let lastEventBeforeSnap;\n    const recentWheelEvents = [];\n    function normalize(e) {\n      // Reasonable defaults\n      const PIXEL_STEP = 10;\n      const LINE_HEIGHT = 40;\n      const PAGE_HEIGHT = 800;\n      let sX = 0;\n      let sY = 0; // spinX, spinY\n      let pX = 0;\n      let pY = 0; // pixelX, pixelY\n\n      // Legacy\n      if ('detail' in e) {\n        sY = e.detail;\n      }\n      if ('wheelDelta' in e) {\n        sY = -e.wheelDelta / 120;\n      }\n      if ('wheelDeltaY' in e) {\n        sY = -e.wheelDeltaY / 120;\n      }\n      if ('wheelDeltaX' in e) {\n        sX = -e.wheelDeltaX / 120;\n      }\n\n      // side scrolling on FF with DOMMouseScroll\n      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n        sX = sY;\n        sY = 0;\n      }\n      pX = sX * PIXEL_STEP;\n      pY = sY * PIXEL_STEP;\n      if ('deltaY' in e) {\n        pY = e.deltaY;\n      }\n      if ('deltaX' in e) {\n        pX = e.deltaX;\n      }\n      if (e.shiftKey && !pX) {\n        // if user scrolls with shift he wants horizontal scroll\n        pX = pY;\n        pY = 0;\n      }\n      if ((pX || pY) && e.deltaMode) {\n        if (e.deltaMode === 1) {\n          // delta in LINE units\n          pX *= LINE_HEIGHT;\n          pY *= LINE_HEIGHT;\n        } else {\n          // delta in PAGE units\n          pX *= PAGE_HEIGHT;\n          pY *= PAGE_HEIGHT;\n        }\n      }\n\n      // Fall-back if spin cannot be determined\n      if (pX && !sX) {\n        sX = pX < 1 ? -1 : 1;\n      }\n      if (pY && !sY) {\n        sY = pY < 1 ? -1 : 1;\n      }\n      return {\n        spinX: sX,\n        spinY: sY,\n        pixelX: pX,\n        pixelY: pY\n      };\n    }\n    function handleMouseEnter() {\n      if (!swiper.enabled) return;\n      swiper.mouseEntered = true;\n    }\n    function handleMouseLeave() {\n      if (!swiper.enabled) return;\n      swiper.mouseEntered = false;\n    }\n    function animateSlider(newEvent) {\n      if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n        // Prevent if delta of wheel scroll delta is below configured threshold\n        return false;\n      }\n      if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n        // Prevent if time between scrolls is below configured threshold\n        return false;\n      }\n\n      // If the movement is NOT big enough and\n      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n      //   Don't go any further (avoid insignificant scroll movement).\n      if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n        // Return false as a default\n        return true;\n      }\n      // If user is scrolling towards the end:\n      //   If the slider hasn't hit the latest slide or\n      //   if the slider is a loop and\n      //   if the slider isn't moving right now:\n      //     Go to next slide and\n      //     emit a scroll event.\n      // Else (the user is scrolling towards the beginning) and\n      // if the slider hasn't hit the first slide or\n      // if the slider is a loop and\n      // if the slider isn't moving right now:\n      //   Go to prev slide and\n      //   emit a scroll event.\n      if (newEvent.direction < 0) {\n        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n          swiper.slideNext();\n          emit('scroll', newEvent.raw);\n        }\n      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n        swiper.slidePrev();\n        emit('scroll', newEvent.raw);\n      }\n      // If you got here is because an animation has been triggered so store the current time\n      lastScrollTime = new window.Date().getTime();\n      // Return false as a default\n      return false;\n    }\n    function releaseScroll(newEvent) {\n      const params = swiper.params.mousewheel;\n      if (newEvent.direction < 0) {\n        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n          // Return true to animate scroll on edges\n          return true;\n        }\n      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n      return false;\n    }\n    function handle(event) {\n      let e = event;\n      let disableParentSwiper = true;\n      if (!swiper.enabled) return;\n\n      // Ignore event if the target or its parents have the swiper-no-mousewheel class\n      if (event.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;\n      const params = swiper.params.mousewheel;\n      if (swiper.params.cssMode) {\n        e.preventDefault();\n      }\n      let targetEl = swiper.el;\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\n        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n      }\n      const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n      if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n      if (e.originalEvent) e = e.originalEvent; // jquery fix\n      let delta = 0;\n      const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n      const data = normalize(e);\n      if (params.forceToAxis) {\n        if (swiper.isHorizontal()) {\n          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n      } else {\n        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n      }\n      if (delta === 0) return true;\n      if (params.invert) delta = -delta;\n\n      // Get the scroll positions\n      let positions = swiper.getTranslate() + delta * params.sensitivity;\n      if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n      if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n      // When loop is true:\n      //     the disableParentSwiper will be true.\n      // When loop is false:\n      //     if the scroll positions is not on edge,\n      //     then the disableParentSwiper will be true.\n      //     if the scroll on edge positions,\n      //     then the disableParentSwiper will be false.\n      disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n      if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n      if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n        // Register the new event in a variable which stores the relevant data\n        const newEvent = {\n          time: now(),\n          delta: Math.abs(delta),\n          direction: Math.sign(delta),\n          raw: event\n        };\n\n        // Keep the most recent events\n        if (recentWheelEvents.length >= 2) {\n          recentWheelEvents.shift(); // only store the last N events\n        }\n\n        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n        recentWheelEvents.push(newEvent);\n\n        // If there is at least one previous recorded event:\n        //   If direction has changed or\n        //   if the scroll is quicker than the previous one:\n        //     Animate the slider.\n        // Else (this is the first time the wheel is moved):\n        //     Animate the slider.\n        if (prevEvent) {\n          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n            animateSlider(newEvent);\n          }\n        } else {\n          animateSlider(newEvent);\n        }\n\n        // If it's time to release the scroll:\n        //   Return now so you don't hit the preventDefault.\n        if (releaseScroll(newEvent)) {\n          return true;\n        }\n      } else {\n        // Freemode or scrollContainer:\n\n        // If we recently snapped after a momentum scroll, then ignore wheel events\n        // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n        // or if it's a new scroll (larger delta or inverse sign as last event before\n        // an end-of-momentum snap).\n        const newEvent = {\n          time: now(),\n          delta: Math.abs(delta),\n          direction: Math.sign(delta)\n        };\n        const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n        if (!ignoreWheelEvents) {\n          lastEventBeforeSnap = undefined;\n          let position = swiper.getTranslate() + delta * params.sensitivity;\n          const wasBeginning = swiper.isBeginning;\n          const wasEnd = swiper.isEnd;\n          if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n          if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n          swiper.setTransition(0);\n          swiper.setTranslate(position);\n          swiper.updateProgress();\n          swiper.updateActiveIndex();\n          swiper.updateSlidesClasses();\n          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n            swiper.updateSlidesClasses();\n          }\n          if (swiper.params.loop) {\n            swiper.loopFix({\n              direction: newEvent.direction < 0 ? 'next' : 'prev',\n              byMousewheel: true\n            });\n          }\n          if (swiper.params.freeMode.sticky) {\n            // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n            // the end of a momentum scroll by storing recent (N=15?) wheel events.\n            // 1. do all N events have decreasing or same (absolute value) delta?\n            // 2. did all N events arrive in the last M (M=500?) msecs?\n            // 3. does the earliest event have an (absolute value) delta that's\n            //    at least P (P=1?) larger than the most recent event's delta?\n            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n            // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n            // Snap immediately and ignore remaining wheel events in this scroll.\n            // See comment above for \"remaining wheel events in this scroll\" determination.\n            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n            clearTimeout(timeout);\n            timeout = undefined;\n            if (recentWheelEvents.length >= 15) {\n              recentWheelEvents.shift(); // only store the last N events\n            }\n\n            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n            const firstEvent = recentWheelEvents[0];\n            recentWheelEvents.push(newEvent);\n            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n              recentWheelEvents.splice(0);\n            } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n              // We're at the end of the deceleration of a momentum scroll, so there's no need\n              // to wait for more events. Snap ASAP on the next tick.\n              // Also, because there's some remaining momentum we'll bias the snap in the\n              // direction of the ongoing scroll because it's better UX for the scroll to snap\n              // in the same direction as the scroll instead of reversing to snap.  Therefore,\n              // if it's already scrolled more than 20% in the current direction, keep going.\n              const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              timeout = nextTick(() => {\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n              }, 0); // no delay; move on next tick\n            }\n\n            if (!timeout) {\n              // if we get here, then we haven't detected the end of a momentum scroll, so\n              // we'll consider a scroll \"complete\" when there haven't been any wheel events\n              // for 500ms.\n              timeout = nextTick(() => {\n                const snapToThreshold = 0.5;\n                lastEventBeforeSnap = newEvent;\n                recentWheelEvents.splice(0);\n                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n              }, 500);\n            }\n          }\n\n          // Emit event\n          if (!ignoreWheelEvents) emit('scroll', e);\n\n          // Stop autoplay\n          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n          // Return page scroll on edge positions\n          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n        }\n      }\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      return false;\n    }\n    function events(method) {\n      let targetEl = swiper.el;\n      if (swiper.params.mousewheel.eventsTarget !== 'container') {\n        targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n      }\n      targetEl[method]('mouseenter', handleMouseEnter);\n      targetEl[method]('mouseleave', handleMouseLeave);\n      targetEl[method]('wheel', handle);\n    }\n    function enable() {\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.removeEventListener('wheel', handle);\n        return true;\n      }\n      if (swiper.mousewheel.enabled) return false;\n      events('addEventListener');\n      swiper.mousewheel.enabled = true;\n      return true;\n    }\n    function disable() {\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.addEventListener(event, handle);\n        return true;\n      }\n      if (!swiper.mousewheel.enabled) return false;\n      events('removeEventListener');\n      swiper.mousewheel.enabled = false;\n      return true;\n    }\n    on('init', () => {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        disable();\n      }\n      if (swiper.params.mousewheel.enabled) enable();\n    });\n    on('destroy', () => {\n      if (swiper.params.cssMode) {\n        enable();\n      }\n      if (swiper.mousewheel.enabled) disable();\n    });\n    Object.assign(swiper.mousewheel, {\n      enable,\n      disable\n    });\n  }\n\n  function createElementIfNotDefined(swiper, originalParams, params, checkProps) {\n    if (swiper.params.createElements) {\n      Object.keys(checkProps).forEach(key => {\n        if (!params[key] && params.auto === true) {\n          let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];\n          if (!element) {\n            element = createElement('div', checkProps[key]);\n            element.className = checkProps[key];\n            swiper.el.append(element);\n          }\n          params[key] = element;\n          originalParams[key] = element;\n        }\n      });\n    }\n    return params;\n  }\n\n  function Navigation(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    extendParams({\n      navigation: {\n        nextEl: null,\n        prevEl: null,\n        hideOnClick: false,\n        disabledClass: 'swiper-button-disabled',\n        hiddenClass: 'swiper-button-hidden',\n        lockClass: 'swiper-button-lock',\n        navigationDisabledClass: 'swiper-navigation-disabled'\n      }\n    });\n    swiper.navigation = {\n      nextEl: null,\n      prevEl: null\n    };\n    const makeElementsArray = el => {\n      if (!Array.isArray(el)) el = [el].filter(e => !!e);\n      return el;\n    };\n    function getEl(el) {\n      let res;\n      if (el && typeof el === 'string' && swiper.isElement) {\n        res = swiper.el.querySelector(el);\n        if (res) return res;\n      }\n      if (el) {\n        if (typeof el === 'string') res = [...document.querySelectorAll(el)];\n        if (swiper.params.uniqueNavElements && typeof el === 'string' && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {\n          res = swiper.el.querySelector(el);\n        }\n      }\n      if (el && !res) return el;\n      // if (Array.isArray(res) && res.length === 1) res = res[0];\n      return res;\n    }\n    function toggleEl(el, disabled) {\n      const params = swiper.params.navigation;\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        if (subEl) {\n          subEl.classList[disabled ? 'add' : 'remove'](...params.disabledClass.split(' '));\n          if (subEl.tagName === 'BUTTON') subEl.disabled = disabled;\n          if (swiper.params.watchOverflow && swiper.enabled) {\n            subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n          }\n        }\n      });\n    }\n    function update() {\n      // Update Navigation Buttons\n      const {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      if (swiper.params.loop) {\n        toggleEl(prevEl, false);\n        toggleEl(nextEl, false);\n        return;\n      }\n      toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);\n      toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);\n    }\n    function onPrevClick(e) {\n      e.preventDefault();\n      if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;\n      swiper.slidePrev();\n      emit('navigationPrev');\n    }\n    function onNextClick(e) {\n      e.preventDefault();\n      if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;\n      swiper.slideNext();\n      emit('navigationNext');\n    }\n    function init() {\n      const params = swiper.params.navigation;\n      swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {\n        nextEl: 'swiper-button-next',\n        prevEl: 'swiper-button-prev'\n      });\n      if (!(params.nextEl || params.prevEl)) return;\n      let nextEl = getEl(params.nextEl);\n      let prevEl = getEl(params.prevEl);\n      Object.assign(swiper.navigation, {\n        nextEl,\n        prevEl\n      });\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      const initButton = (el, dir) => {\n        if (el) {\n          el.addEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n        }\n        if (!swiper.enabled && el) {\n          el.classList.add(...params.lockClass.split(' '));\n        }\n      };\n      nextEl.forEach(el => initButton(el, 'next'));\n      prevEl.forEach(el => initButton(el, 'prev'));\n    }\n    function destroy() {\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      const destroyButton = (el, dir) => {\n        el.removeEventListener('click', dir === 'next' ? onNextClick : onPrevClick);\n        el.classList.remove(...swiper.params.navigation.disabledClass.split(' '));\n      };\n      nextEl.forEach(el => destroyButton(el, 'next'));\n      prevEl.forEach(el => destroyButton(el, 'prev'));\n    }\n    on('init', () => {\n      if (swiper.params.navigation.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        update();\n      }\n    });\n    on('toEdge fromEdge lock unlock', () => {\n      update();\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    on('enable disable', () => {\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.navigation.lockClass));\n    });\n    on('click', (_s, e) => {\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      const targetEl = e.target;\n      if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {\n        if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;\n        let isHidden;\n        if (nextEl.length) {\n          isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n        } else if (prevEl.length) {\n          isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);\n        }\n        if (isHidden === true) {\n          emit('navigationShow');\n        } else {\n          emit('navigationHide');\n        }\n        [...nextEl, ...prevEl].filter(el => !!el).forEach(el => el.classList.toggle(swiper.params.navigation.hiddenClass));\n      }\n    });\n    const enable = () => {\n      swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(' '));\n      init();\n      update();\n    };\n    const disable = () => {\n      swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(' '));\n      destroy();\n    };\n    Object.assign(swiper.navigation, {\n      enable,\n      disable,\n      update,\n      init,\n      destroy\n    });\n  }\n\n  function classesToSelector(classes) {\n    if (classes === void 0) {\n      classes = '';\n    }\n    return `.${classes.trim().replace(/([\\.:!+\\/])/g, '\\\\$1') // eslint-disable-line\n  .replace(/ /g, '.')}`;\n  }\n\n  function Pagination(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const pfx = 'swiper-pagination';\n    extendParams({\n      pagination: {\n        el: null,\n        bulletElement: 'span',\n        clickable: false,\n        hideOnClick: false,\n        renderBullet: null,\n        renderProgressbar: null,\n        renderFraction: null,\n        renderCustom: null,\n        progressbarOpposite: false,\n        type: 'bullets',\n        // 'bullets' or 'progressbar' or 'fraction' or 'custom'\n        dynamicBullets: false,\n        dynamicMainBullets: 1,\n        formatFractionCurrent: number => number,\n        formatFractionTotal: number => number,\n        bulletClass: `${pfx}-bullet`,\n        bulletActiveClass: `${pfx}-bullet-active`,\n        modifierClass: `${pfx}-`,\n        currentClass: `${pfx}-current`,\n        totalClass: `${pfx}-total`,\n        hiddenClass: `${pfx}-hidden`,\n        progressbarFillClass: `${pfx}-progressbar-fill`,\n        progressbarOppositeClass: `${pfx}-progressbar-opposite`,\n        clickableClass: `${pfx}-clickable`,\n        lockClass: `${pfx}-lock`,\n        horizontalClass: `${pfx}-horizontal`,\n        verticalClass: `${pfx}-vertical`,\n        paginationDisabledClass: `${pfx}-disabled`\n      }\n    });\n    swiper.pagination = {\n      el: null,\n      bullets: []\n    };\n    let bulletSize;\n    let dynamicBulletIndex = 0;\n    const makeElementsArray = el => {\n      if (!Array.isArray(el)) el = [el].filter(e => !!e);\n      return el;\n    };\n    function isPaginationDisabled() {\n      return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;\n    }\n    function setSideBullets(bulletEl, position) {\n      const {\n        bulletActiveClass\n      } = swiper.params.pagination;\n      if (!bulletEl) return;\n      bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n      if (bulletEl) {\n        bulletEl.classList.add(`${bulletActiveClass}-${position}`);\n        bulletEl = bulletEl[`${position === 'prev' ? 'previous' : 'next'}ElementSibling`];\n        if (bulletEl) {\n          bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);\n        }\n      }\n    }\n    function onBulletClick(e) {\n      const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));\n      if (!bulletEl) {\n        return;\n      }\n      e.preventDefault();\n      const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;\n      if (swiper.params.loop) {\n        if (swiper.realIndex === index) return;\n        const newSlideIndex = swiper.getSlideIndexByData(index);\n        const currentSlideIndex = swiper.getSlideIndexByData(swiper.realIndex);\n        if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {\n          swiper.loopFix({\n            direction: newSlideIndex > currentSlideIndex ? 'next' : 'prev',\n            activeSlideIndex: newSlideIndex,\n            slideTo: false\n          });\n        }\n        swiper.slideToLoop(index);\n      } else {\n        swiper.slideTo(index);\n      }\n    }\n    function update() {\n      // Render || Update Pagination bullets/items\n      const rtl = swiper.rtl;\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      let el = swiper.pagination.el;\n      el = makeElementsArray(el);\n      // Current/Total\n      let current;\n      let previousIndex;\n      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n      const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n      if (swiper.params.loop) {\n        previousIndex = swiper.previousRealIndex || 0;\n        current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;\n      } else if (typeof swiper.snapIndex !== 'undefined') {\n        current = swiper.snapIndex;\n        previousIndex = swiper.previousSnapIndex;\n      } else {\n        previousIndex = swiper.previousIndex || 0;\n        current = swiper.activeIndex || 0;\n      }\n      // Types\n      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {\n        const bullets = swiper.pagination.bullets;\n        let firstIndex;\n        let lastIndex;\n        let midIndex;\n        if (params.dynamicBullets) {\n          bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? 'width' : 'height', true);\n          el.forEach(subEl => {\n            subEl.style[swiper.isHorizontal() ? 'width' : 'height'] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;\n          });\n          if (params.dynamicMainBullets > 1 && previousIndex !== undefined) {\n            dynamicBulletIndex += current - (previousIndex || 0);\n            if (dynamicBulletIndex > params.dynamicMainBullets - 1) {\n              dynamicBulletIndex = params.dynamicMainBullets - 1;\n            } else if (dynamicBulletIndex < 0) {\n              dynamicBulletIndex = 0;\n            }\n          }\n          firstIndex = Math.max(current - dynamicBulletIndex, 0);\n          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);\n          midIndex = (lastIndex + firstIndex) / 2;\n        }\n        bullets.forEach(bulletEl => {\n          const classesToRemove = [...['', '-next', '-next-next', '-prev', '-prev-prev', '-main'].map(suffix => `${params.bulletActiveClass}${suffix}`)].map(s => typeof s === 'string' && s.includes(' ') ? s.split(' ') : s).flat();\n          bulletEl.classList.remove(...classesToRemove);\n        });\n        if (el.length > 1) {\n          bullets.forEach(bullet => {\n            const bulletIndex = elementIndex(bullet);\n            if (bulletIndex === current) {\n              bullet.classList.add(...params.bulletActiveClass.split(' '));\n            } else if (swiper.isElement) {\n              bullet.setAttribute('part', 'bullet');\n            }\n            if (params.dynamicBullets) {\n              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {\n                bullet.classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n              }\n              if (bulletIndex === firstIndex) {\n                setSideBullets(bullet, 'prev');\n              }\n              if (bulletIndex === lastIndex) {\n                setSideBullets(bullet, 'next');\n              }\n            }\n          });\n        } else {\n          const bullet = bullets[current];\n          if (bullet) {\n            bullet.classList.add(...params.bulletActiveClass.split(' '));\n          }\n          if (swiper.isElement) {\n            bullets.forEach((bulletEl, bulletIndex) => {\n              bulletEl.setAttribute('part', bulletIndex === current ? 'bullet-active' : 'bullet');\n            });\n          }\n          if (params.dynamicBullets) {\n            const firstDisplayedBullet = bullets[firstIndex];\n            const lastDisplayedBullet = bullets[lastIndex];\n            for (let i = firstIndex; i <= lastIndex; i += 1) {\n              if (bullets[i]) {\n                bullets[i].classList.add(...`${params.bulletActiveClass}-main`.split(' '));\n              }\n            }\n            setSideBullets(firstDisplayedBullet, 'prev');\n            setSideBullets(lastDisplayedBullet, 'next');\n          }\n        }\n        if (params.dynamicBullets) {\n          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);\n          const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;\n          const offsetProp = rtl ? 'right' : 'left';\n          bullets.forEach(bullet => {\n            bullet.style[swiper.isHorizontal() ? offsetProp : 'top'] = `${bulletsOffset}px`;\n          });\n        }\n      }\n      el.forEach((subEl, subElIndex) => {\n        if (params.type === 'fraction') {\n          subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach(fractionEl => {\n            fractionEl.textContent = params.formatFractionCurrent(current + 1);\n          });\n          subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach(totalEl => {\n            totalEl.textContent = params.formatFractionTotal(total);\n          });\n        }\n        if (params.type === 'progressbar') {\n          let progressbarDirection;\n          if (params.progressbarOpposite) {\n            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';\n          } else {\n            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';\n          }\n          const scale = (current + 1) / total;\n          let scaleX = 1;\n          let scaleY = 1;\n          if (progressbarDirection === 'horizontal') {\n            scaleX = scale;\n          } else {\n            scaleY = scale;\n          }\n          subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach(progressEl => {\n            progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;\n            progressEl.style.transitionDuration = `${swiper.params.speed}ms`;\n          });\n        }\n        if (params.type === 'custom' && params.renderCustom) {\n          subEl.innerHTML = params.renderCustom(swiper, current + 1, total);\n          if (subElIndex === 0) emit('paginationRender', subEl);\n        } else {\n          if (subElIndex === 0) emit('paginationRender', subEl);\n          emit('paginationUpdate', subEl);\n        }\n        if (swiper.params.watchOverflow && swiper.enabled) {\n          subEl.classList[swiper.isLocked ? 'add' : 'remove'](params.lockClass);\n        }\n      });\n    }\n    function render() {\n      // Render Container\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;\n      let el = swiper.pagination.el;\n      el = makeElementsArray(el);\n      let paginationHTML = '';\n      if (params.type === 'bullets') {\n        let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;\n        if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {\n          numberOfBullets = slidesLength;\n        }\n        for (let i = 0; i < numberOfBullets; i += 1) {\n          if (params.renderBullet) {\n            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);\n          } else {\n            // prettier-ignore\n            paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part=\"bullet\"' : ''} class=\"${params.bulletClass}\"></${params.bulletElement}>`;\n          }\n        }\n      }\n      if (params.type === 'fraction') {\n        if (params.renderFraction) {\n          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);\n        } else {\n          paginationHTML = `<span class=\"${params.currentClass}\"></span>` + ' / ' + `<span class=\"${params.totalClass}\"></span>`;\n        }\n      }\n      if (params.type === 'progressbar') {\n        if (params.renderProgressbar) {\n          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);\n        } else {\n          paginationHTML = `<span class=\"${params.progressbarFillClass}\"></span>`;\n        }\n      }\n      swiper.pagination.bullets = [];\n      el.forEach(subEl => {\n        if (params.type !== 'custom') {\n          subEl.innerHTML = paginationHTML || '';\n        }\n        if (params.type === 'bullets') {\n          swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));\n        }\n      });\n      if (params.type !== 'custom') {\n        emit('paginationRender', el[0]);\n      }\n    }\n    function init() {\n      swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {\n        el: 'swiper-pagination'\n      });\n      const params = swiper.params.pagination;\n      if (!params.el) return;\n      let el;\n      if (typeof params.el === 'string' && swiper.isElement) {\n        el = swiper.el.querySelector(params.el);\n      }\n      if (!el && typeof params.el === 'string') {\n        el = [...document.querySelectorAll(params.el)];\n      }\n      if (!el) {\n        el = params.el;\n      }\n      if (!el || el.length === 0) return;\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && Array.isArray(el) && el.length > 1) {\n        el = [...swiper.el.querySelectorAll(params.el)];\n        // check if it belongs to another nested Swiper\n        if (el.length > 1) {\n          el = el.filter(subEl => {\n            if (elementParents(subEl, '.swiper')[0] !== swiper.el) return false;\n            return true;\n          })[0];\n        }\n      }\n      if (Array.isArray(el) && el.length === 1) el = el[0];\n      Object.assign(swiper.pagination, {\n        el\n      });\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        if (params.type === 'bullets' && params.clickable) {\n          subEl.classList.add(params.clickableClass);\n        }\n        subEl.classList.add(params.modifierClass + params.type);\n        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n        if (params.type === 'bullets' && params.dynamicBullets) {\n          subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);\n          dynamicBulletIndex = 0;\n          if (params.dynamicMainBullets < 1) {\n            params.dynamicMainBullets = 1;\n          }\n        }\n        if (params.type === 'progressbar' && params.progressbarOpposite) {\n          subEl.classList.add(params.progressbarOppositeClass);\n        }\n        if (params.clickable) {\n          subEl.addEventListener('click', onBulletClick);\n        }\n        if (!swiper.enabled) {\n          subEl.classList.add(params.lockClass);\n        }\n      });\n    }\n    function destroy() {\n      const params = swiper.params.pagination;\n      if (isPaginationDisabled()) return;\n      let el = swiper.pagination.el;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => {\n          subEl.classList.remove(params.hiddenClass);\n          subEl.classList.remove(params.modifierClass + params.type);\n          subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n          if (params.clickable) {\n            subEl.removeEventListener('click', onBulletClick);\n          }\n        });\n      }\n      if (swiper.pagination.bullets) swiper.pagination.bullets.forEach(subEl => subEl.classList.remove(...params.bulletActiveClass.split(' ')));\n    }\n    on('changeDirection', () => {\n      if (!swiper.pagination || !swiper.pagination.el) return;\n      const params = swiper.params.pagination;\n      let {\n        el\n      } = swiper.pagination;\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.classList.remove(params.horizontalClass, params.verticalClass);\n        subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      });\n    });\n    on('init', () => {\n      if (swiper.params.pagination.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        render();\n        update();\n      }\n    });\n    on('activeIndexChange', () => {\n      if (typeof swiper.snapIndex === 'undefined') {\n        update();\n      }\n    });\n    on('snapIndexChange', () => {\n      update();\n    });\n    on('snapGridLengthChange', () => {\n      render();\n      update();\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    on('enable disable', () => {\n      let {\n        el\n      } = swiper.pagination;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => subEl.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.pagination.lockClass));\n      }\n    });\n    on('lock unlock', () => {\n      update();\n    });\n    on('click', (_s, e) => {\n      const targetEl = e.target;\n      const el = makeElementsArray(swiper.pagination.el);\n      if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {\n        if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;\n        const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);\n        if (isHidden === true) {\n          emit('paginationShow');\n        } else {\n          emit('paginationHide');\n        }\n        el.forEach(subEl => subEl.classList.toggle(swiper.params.pagination.hiddenClass));\n      }\n    });\n    const enable = () => {\n      swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);\n      let {\n        el\n      } = swiper.pagination;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));\n      }\n      init();\n      render();\n      update();\n    };\n    const disable = () => {\n      swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);\n      let {\n        el\n      } = swiper.pagination;\n      if (el) {\n        el = makeElementsArray(el);\n        el.forEach(subEl => subEl.classList.add(swiper.params.pagination.paginationDisabledClass));\n      }\n      destroy();\n    };\n    Object.assign(swiper.pagination, {\n      enable,\n      disable,\n      render,\n      update,\n      init,\n      destroy\n    });\n  }\n\n  function Scrollbar(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const document = getDocument();\n    let isTouched = false;\n    let timeout = null;\n    let dragTimeout = null;\n    let dragStartPos;\n    let dragSize;\n    let trackSize;\n    let divider;\n    extendParams({\n      scrollbar: {\n        el: null,\n        dragSize: 'auto',\n        hide: false,\n        draggable: false,\n        snapOnRelease: true,\n        lockClass: 'swiper-scrollbar-lock',\n        dragClass: 'swiper-scrollbar-drag',\n        scrollbarDisabledClass: 'swiper-scrollbar-disabled',\n        horizontalClass: `swiper-scrollbar-horizontal`,\n        verticalClass: `swiper-scrollbar-vertical`\n      }\n    });\n    swiper.scrollbar = {\n      el: null,\n      dragEl: null\n    };\n    function setTranslate() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      const {\n        scrollbar,\n        rtlTranslate: rtl\n      } = swiper;\n      const {\n        dragEl,\n        el\n      } = scrollbar;\n      const params = swiper.params.scrollbar;\n      const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;\n      let newSize = dragSize;\n      let newPos = (trackSize - dragSize) * progress;\n      if (rtl) {\n        newPos = -newPos;\n        if (newPos > 0) {\n          newSize = dragSize - newPos;\n          newPos = 0;\n        } else if (-newPos + dragSize > trackSize) {\n          newSize = trackSize + newPos;\n        }\n      } else if (newPos < 0) {\n        newSize = dragSize + newPos;\n        newPos = 0;\n      } else if (newPos + dragSize > trackSize) {\n        newSize = trackSize - newPos;\n      }\n      if (swiper.isHorizontal()) {\n        dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;\n        dragEl.style.width = `${newSize}px`;\n      } else {\n        dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;\n        dragEl.style.height = `${newSize}px`;\n      }\n      if (params.hide) {\n        clearTimeout(timeout);\n        el.style.opacity = 1;\n        timeout = setTimeout(() => {\n          el.style.opacity = 0;\n          el.style.transitionDuration = '400ms';\n        }, 1000);\n      }\n    }\n    function setTransition(duration) {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;\n    }\n    function updateSize() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      const {\n        scrollbar\n      } = swiper;\n      const {\n        dragEl,\n        el\n      } = scrollbar;\n      dragEl.style.width = '';\n      dragEl.style.height = '';\n      trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;\n      divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));\n      if (swiper.params.scrollbar.dragSize === 'auto') {\n        dragSize = trackSize * divider;\n      } else {\n        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);\n      }\n      if (swiper.isHorizontal()) {\n        dragEl.style.width = `${dragSize}px`;\n      } else {\n        dragEl.style.height = `${dragSize}px`;\n      }\n      if (divider >= 1) {\n        el.style.display = 'none';\n      } else {\n        el.style.display = '';\n      }\n      if (swiper.params.scrollbar.hide) {\n        el.style.opacity = 0;\n      }\n      if (swiper.params.watchOverflow && swiper.enabled) {\n        scrollbar.el.classList[swiper.isLocked ? 'add' : 'remove'](swiper.params.scrollbar.lockClass);\n      }\n    }\n    function getPointerPosition(e) {\n      return swiper.isHorizontal() ? e.clientX : e.clientY;\n    }\n    function setDragPosition(e) {\n      const {\n        scrollbar,\n        rtlTranslate: rtl\n      } = swiper;\n      const {\n        el\n      } = scrollbar;\n      let positionRatio;\n      positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);\n      positionRatio = Math.max(Math.min(positionRatio, 1), 0);\n      if (rtl) {\n        positionRatio = 1 - positionRatio;\n      }\n      const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;\n      swiper.updateProgress(position);\n      swiper.setTranslate(position);\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    function onDragStart(e) {\n      const params = swiper.params.scrollbar;\n      const {\n        scrollbar,\n        wrapperEl\n      } = swiper;\n      const {\n        el,\n        dragEl\n      } = scrollbar;\n      isTouched = true;\n      dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;\n      e.preventDefault();\n      e.stopPropagation();\n      wrapperEl.style.transitionDuration = '100ms';\n      dragEl.style.transitionDuration = '100ms';\n      setDragPosition(e);\n      clearTimeout(dragTimeout);\n      el.style.transitionDuration = '0ms';\n      if (params.hide) {\n        el.style.opacity = 1;\n      }\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style['scroll-snap-type'] = 'none';\n      }\n      emit('scrollbarDragStart', e);\n    }\n    function onDragMove(e) {\n      const {\n        scrollbar,\n        wrapperEl\n      } = swiper;\n      const {\n        el,\n        dragEl\n      } = scrollbar;\n      if (!isTouched) return;\n      if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n      setDragPosition(e);\n      wrapperEl.style.transitionDuration = '0ms';\n      el.style.transitionDuration = '0ms';\n      dragEl.style.transitionDuration = '0ms';\n      emit('scrollbarDragMove', e);\n    }\n    function onDragEnd(e) {\n      const params = swiper.params.scrollbar;\n      const {\n        scrollbar,\n        wrapperEl\n      } = swiper;\n      const {\n        el\n      } = scrollbar;\n      if (!isTouched) return;\n      isTouched = false;\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style['scroll-snap-type'] = '';\n        wrapperEl.style.transitionDuration = '';\n      }\n      if (params.hide) {\n        clearTimeout(dragTimeout);\n        dragTimeout = nextTick(() => {\n          el.style.opacity = 0;\n          el.style.transitionDuration = '400ms';\n        }, 1000);\n      }\n      emit('scrollbarDragEnd', e);\n      if (params.snapOnRelease) {\n        swiper.slideToClosest();\n      }\n    }\n    function events(method) {\n      const {\n        scrollbar,\n        params\n      } = swiper;\n      const el = scrollbar.el;\n      if (!el) return;\n      const target = el;\n      const activeListener = params.passiveListeners ? {\n        passive: false,\n        capture: false\n      } : false;\n      const passiveListener = params.passiveListeners ? {\n        passive: true,\n        capture: false\n      } : false;\n      if (!target) return;\n      const eventMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';\n      target[eventMethod]('pointerdown', onDragStart, activeListener);\n      document[eventMethod]('pointermove', onDragMove, activeListener);\n      document[eventMethod]('pointerup', onDragEnd, passiveListener);\n    }\n    function enableDraggable() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      events('on');\n    }\n    function disableDraggable() {\n      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;\n      events('off');\n    }\n    function init() {\n      const {\n        scrollbar,\n        el: swiperEl\n      } = swiper;\n      swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {\n        el: 'swiper-scrollbar'\n      });\n      const params = swiper.params.scrollbar;\n      if (!params.el) return;\n      let el;\n      if (typeof params.el === 'string' && swiper.isElement) {\n        el = swiper.el.querySelector(params.el);\n      }\n      if (!el && typeof params.el === 'string') {\n        el = document.querySelectorAll(params.el);\n      } else if (!el) {\n        el = params.el;\n      }\n      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {\n        el = swiperEl.querySelector(params.el);\n      }\n      if (el.length > 0) el = el[0];\n      el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      let dragEl;\n      if (el) {\n        dragEl = el.querySelector(`.${swiper.params.scrollbar.dragClass}`);\n        if (!dragEl) {\n          dragEl = createElement('div', swiper.params.scrollbar.dragClass);\n          el.append(dragEl);\n        }\n      }\n      Object.assign(scrollbar, {\n        el,\n        dragEl\n      });\n      if (params.draggable) {\n        enableDraggable();\n      }\n      if (el) {\n        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n      }\n    }\n    function destroy() {\n      const params = swiper.params.scrollbar;\n      const el = swiper.scrollbar.el;\n      if (el) {\n        el.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);\n      }\n      disableDraggable();\n    }\n    on('init', () => {\n      if (swiper.params.scrollbar.enabled === false) {\n        // eslint-disable-next-line\n        disable();\n      } else {\n        init();\n        updateSize();\n        setTranslate();\n      }\n    });\n    on('update resize observerUpdate lock unlock', () => {\n      updateSize();\n    });\n    on('setTranslate', () => {\n      setTranslate();\n    });\n    on('setTransition', (_s, duration) => {\n      setTransition(duration);\n    });\n    on('enable disable', () => {\n      const {\n        el\n      } = swiper.scrollbar;\n      if (el) {\n        el.classList[swiper.enabled ? 'remove' : 'add'](swiper.params.scrollbar.lockClass);\n      }\n    });\n    on('destroy', () => {\n      destroy();\n    });\n    const enable = () => {\n      swiper.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n      if (swiper.scrollbar.el) {\n        swiper.scrollbar.el.classList.remove(swiper.params.scrollbar.scrollbarDisabledClass);\n      }\n      init();\n      updateSize();\n      setTranslate();\n    };\n    const disable = () => {\n      swiper.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n      if (swiper.scrollbar.el) {\n        swiper.scrollbar.el.classList.add(swiper.params.scrollbar.scrollbarDisabledClass);\n      }\n      destroy();\n    };\n    Object.assign(swiper.scrollbar, {\n      enable,\n      disable,\n      updateSize,\n      setTranslate,\n      init,\n      destroy\n    });\n  }\n\n  function Parallax(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      parallax: {\n        enabled: false\n      }\n    });\n    const setTransform = (el, progress) => {\n      const {\n        rtl\n      } = swiper;\n      const rtlFactor = rtl ? -1 : 1;\n      const p = el.getAttribute('data-swiper-parallax') || '0';\n      let x = el.getAttribute('data-swiper-parallax-x');\n      let y = el.getAttribute('data-swiper-parallax-y');\n      const scale = el.getAttribute('data-swiper-parallax-scale');\n      const opacity = el.getAttribute('data-swiper-parallax-opacity');\n      const rotate = el.getAttribute('data-swiper-parallax-rotate');\n      if (x || y) {\n        x = x || '0';\n        y = y || '0';\n      } else if (swiper.isHorizontal()) {\n        x = p;\n        y = '0';\n      } else {\n        y = p;\n        x = '0';\n      }\n      if (x.indexOf('%') >= 0) {\n        x = `${parseInt(x, 10) * progress * rtlFactor}%`;\n      } else {\n        x = `${x * progress * rtlFactor}px`;\n      }\n      if (y.indexOf('%') >= 0) {\n        y = `${parseInt(y, 10) * progress}%`;\n      } else {\n        y = `${y * progress}px`;\n      }\n      if (typeof opacity !== 'undefined' && opacity !== null) {\n        const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));\n        el.style.opacity = currentOpacity;\n      }\n      let transform = `translate3d(${x}, ${y}, 0px)`;\n      if (typeof scale !== 'undefined' && scale !== null) {\n        const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));\n        transform += ` scale(${currentScale})`;\n      }\n      if (rotate && typeof rotate !== 'undefined' && rotate !== null) {\n        const currentRotate = rotate * progress * -1;\n        transform += ` rotate(${currentRotate}deg)`;\n      }\n      el.style.transform = transform;\n    };\n    const setTranslate = () => {\n      const {\n        el,\n        slides,\n        progress,\n        snapGrid\n      } = swiper;\n      elementChildren(el, '[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(subEl => {\n        setTransform(subEl, progress);\n      });\n      slides.forEach((slideEl, slideIndex) => {\n        let slideProgress = slideEl.progress;\n        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {\n          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);\n        }\n        slideProgress = Math.min(Math.max(slideProgress, -1), 1);\n        slideEl.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]').forEach(subEl => {\n          setTransform(subEl, slideProgress);\n        });\n      });\n    };\n    const setTransition = function (duration) {\n      if (duration === void 0) {\n        duration = swiper.params.speed;\n      }\n      const {\n        el\n      } = swiper;\n      el.querySelectorAll('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').forEach(parallaxEl => {\n        let parallaxDuration = parseInt(parallaxEl.getAttribute('data-swiper-parallax-duration'), 10) || duration;\n        if (duration === 0) parallaxDuration = 0;\n        parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;\n      });\n    };\n    on('beforeInit', () => {\n      if (!swiper.params.parallax.enabled) return;\n      swiper.params.watchSlidesProgress = true;\n      swiper.originalParams.watchSlidesProgress = true;\n    });\n    on('init', () => {\n      if (!swiper.params.parallax.enabled) return;\n      setTranslate();\n    });\n    on('setTranslate', () => {\n      if (!swiper.params.parallax.enabled) return;\n      setTranslate();\n    });\n    on('setTransition', (_swiper, duration) => {\n      if (!swiper.params.parallax.enabled) return;\n      setTransition(duration);\n    });\n  }\n\n  function Zoom(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit\n    } = _ref;\n    const window = getWindow();\n    extendParams({\n      zoom: {\n        enabled: false,\n        maxRatio: 3,\n        minRatio: 1,\n        toggle: true,\n        containerClass: 'swiper-zoom-container',\n        zoomedSlideClass: 'swiper-slide-zoomed'\n      }\n    });\n    swiper.zoom = {\n      enabled: false\n    };\n    let currentScale = 1;\n    let isScaling = false;\n    let fakeGestureTouched;\n    let fakeGestureMoved;\n    const evCache = [];\n    const gesture = {\n      originX: 0,\n      originY: 0,\n      slideEl: undefined,\n      slideWidth: undefined,\n      slideHeight: undefined,\n      imageEl: undefined,\n      imageWrapEl: undefined,\n      maxRatio: 3\n    };\n    const image = {\n      isTouched: undefined,\n      isMoved: undefined,\n      currentX: undefined,\n      currentY: undefined,\n      minX: undefined,\n      minY: undefined,\n      maxX: undefined,\n      maxY: undefined,\n      width: undefined,\n      height: undefined,\n      startX: undefined,\n      startY: undefined,\n      touchesStart: {},\n      touchesCurrent: {}\n    };\n    const velocity = {\n      x: undefined,\n      y: undefined,\n      prevPositionX: undefined,\n      prevPositionY: undefined,\n      prevTime: undefined\n    };\n    let scale = 1;\n    Object.defineProperty(swiper.zoom, 'scale', {\n      get() {\n        return scale;\n      },\n      set(value) {\n        if (scale !== value) {\n          const imageEl = gesture.imageEl;\n          const slideEl = gesture.slideEl;\n          emit('zoomChange', value, imageEl, slideEl);\n        }\n        scale = value;\n      }\n    });\n    function getDistanceBetweenTouches() {\n      if (evCache.length < 2) return 1;\n      const x1 = evCache[0].pageX;\n      const y1 = evCache[0].pageY;\n      const x2 = evCache[1].pageX;\n      const y2 = evCache[1].pageY;\n      const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n      return distance;\n    }\n    function getScaleOrigin() {\n      if (evCache.length < 2) return {\n        x: null,\n        y: null\n      };\n      const box = gesture.imageEl.getBoundingClientRect();\n      return [(evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x) / currentScale, (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y) / currentScale];\n    }\n    function getSlideSelector() {\n      return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;\n    }\n    function eventWithinSlide(e) {\n      const slideSelector = getSlideSelector();\n      if (e.target.matches(slideSelector)) return true;\n      if (swiper.slides.filter(slideEl => slideEl.contains(e.target)).length > 0) return true;\n      return false;\n    }\n    function eventWithinZoomContainer(e) {\n      const selector = `.${swiper.params.zoom.containerClass}`;\n      if (e.target.matches(selector)) return true;\n      if ([...swiper.el.querySelectorAll(selector)].filter(containerEl => containerEl.contains(e.target)).length > 0) return true;\n      return false;\n    }\n\n    // Events\n    function onGestureStart(e) {\n      if (e.pointerType === 'mouse') {\n        evCache.splice(0, evCache.length);\n      }\n      if (!eventWithinSlide(e)) return;\n      const params = swiper.params.zoom;\n      fakeGestureTouched = false;\n      fakeGestureMoved = false;\n      evCache.push(e);\n      if (evCache.length < 2) {\n        return;\n      }\n      fakeGestureTouched = true;\n      gesture.scaleStart = getDistanceBetweenTouches();\n      if (!gesture.slideEl) {\n        gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];\n        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n        if (imageEl) {\n          imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n        }\n        gesture.imageEl = imageEl;\n        if (imageEl) {\n          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n        } else {\n          gesture.imageWrapEl = undefined;\n        }\n        if (!gesture.imageWrapEl) {\n          gesture.imageEl = undefined;\n          return;\n        }\n        gesture.maxRatio = gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n      }\n      if (gesture.imageEl) {\n        const [originX, originY] = getScaleOrigin();\n        gesture.originX = originX;\n        gesture.originY = originY;\n        gesture.imageEl.style.transitionDuration = '0ms';\n      }\n      isScaling = true;\n    }\n    function onGestureChange(e) {\n      if (!eventWithinSlide(e)) return;\n      const params = swiper.params.zoom;\n      const zoom = swiper.zoom;\n      const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0) evCache[pointerIndex] = e;\n      if (evCache.length < 2) {\n        return;\n      }\n      fakeGestureMoved = true;\n      gesture.scaleMove = getDistanceBetweenTouches();\n      if (!gesture.imageEl) {\n        return;\n      }\n      zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;\n      if (zoom.scale > gesture.maxRatio) {\n        zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;\n      }\n      if (zoom.scale < params.minRatio) {\n        zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;\n      }\n      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    }\n    function onGestureEnd(e) {\n      if (!eventWithinSlide(e)) return;\n      if (e.pointerType === 'mouse' && e.type === 'pointerout') return;\n      const params = swiper.params.zoom;\n      const zoom = swiper.zoom;\n      const pointerIndex = evCache.findIndex(cachedEv => cachedEv.pointerId === e.pointerId);\n      if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);\n      if (!fakeGestureTouched || !fakeGestureMoved) {\n        return;\n      }\n      fakeGestureTouched = false;\n      fakeGestureMoved = false;\n      if (!gesture.imageEl) return;\n      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);\n      gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;\n      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n      currentScale = zoom.scale;\n      isScaling = false;\n      if (zoom.scale > 1 && gesture.slideEl) {\n        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n      } else if (zoom.scale <= 1 && gesture.slideEl) {\n        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n      }\n      if (zoom.scale === 1) {\n        gesture.originX = 0;\n        gesture.originY = 0;\n        gesture.slideEl = undefined;\n      }\n    }\n    function onTouchStart(e) {\n      const device = swiper.device;\n      if (!gesture.imageEl) return;\n      if (image.isTouched) return;\n      if (device.android && e.cancelable) e.preventDefault();\n      image.isTouched = true;\n      const event = evCache.length > 0 ? evCache[0] : e;\n      image.touchesStart.x = event.pageX;\n      image.touchesStart.y = event.pageY;\n    }\n    function onTouchMove(e) {\n      if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;\n      const zoom = swiper.zoom;\n      if (!gesture.imageEl) return;\n      if (!image.isTouched || !gesture.slideEl) return;\n      if (!image.isMoved) {\n        image.width = gesture.imageEl.offsetWidth;\n        image.height = gesture.imageEl.offsetHeight;\n        image.startX = getTranslate(gesture.imageWrapEl, 'x') || 0;\n        image.startY = getTranslate(gesture.imageWrapEl, 'y') || 0;\n        gesture.slideWidth = gesture.slideEl.offsetWidth;\n        gesture.slideHeight = gesture.slideEl.offsetHeight;\n        gesture.imageWrapEl.style.transitionDuration = '0ms';\n      }\n      // Define if we need image drag\n      const scaledWidth = image.width * zoom.scale;\n      const scaledHeight = image.height * zoom.scale;\n      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n      image.maxX = -image.minX;\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n      image.maxY = -image.minY;\n      image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;\n      image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;\n      const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));\n      if (touchesDiff > 5) {\n        swiper.allowClick = false;\n      }\n      if (!image.isMoved && !isScaling) {\n        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {\n          image.isTouched = false;\n          return;\n        }\n        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {\n          image.isTouched = false;\n          return;\n        }\n      }\n      if (e.cancelable) {\n        e.preventDefault();\n      }\n      e.stopPropagation();\n      image.isMoved = true;\n      const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);\n      const {\n        originX,\n        originY\n      } = gesture;\n      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);\n      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);\n      if (image.currentX < image.minX) {\n        image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;\n      }\n      if (image.currentX > image.maxX) {\n        image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;\n      }\n      if (image.currentY < image.minY) {\n        image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;\n      }\n      if (image.currentY > image.maxY) {\n        image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;\n      }\n\n      // Velocity\n      if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;\n      if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;\n      if (!velocity.prevTime) velocity.prevTime = Date.now();\n      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;\n      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;\n      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;\n      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;\n      velocity.prevPositionX = image.touchesCurrent.x;\n      velocity.prevPositionY = image.touchesCurrent.y;\n      velocity.prevTime = Date.now();\n      gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n    }\n    function onTouchEnd() {\n      const zoom = swiper.zoom;\n      if (!gesture.imageEl) return;\n      if (!image.isTouched || !image.isMoved) {\n        image.isTouched = false;\n        image.isMoved = false;\n        return;\n      }\n      image.isTouched = false;\n      image.isMoved = false;\n      let momentumDurationX = 300;\n      let momentumDurationY = 300;\n      const momentumDistanceX = velocity.x * momentumDurationX;\n      const newPositionX = image.currentX + momentumDistanceX;\n      const momentumDistanceY = velocity.y * momentumDurationY;\n      const newPositionY = image.currentY + momentumDistanceY;\n\n      // Fix duration\n      if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);\n      if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);\n      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);\n      image.currentX = newPositionX;\n      image.currentY = newPositionY;\n      // Define if we need image drag\n      const scaledWidth = image.width * zoom.scale;\n      const scaledHeight = image.height * zoom.scale;\n      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);\n      image.maxX = -image.minX;\n      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);\n      image.maxY = -image.minY;\n      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);\n      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);\n      gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;\n      gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;\n    }\n    function onTransitionEnd() {\n      const zoom = swiper.zoom;\n      if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {\n        if (gesture.imageEl) {\n          gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n        }\n        if (gesture.imageWrapEl) {\n          gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n        }\n        gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);\n        zoom.scale = 1;\n        currentScale = 1;\n        gesture.slideEl = undefined;\n        gesture.imageEl = undefined;\n        gesture.imageWrapEl = undefined;\n        gesture.originX = 0;\n        gesture.originY = 0;\n      }\n    }\n    function zoomIn(e) {\n      const zoom = swiper.zoom;\n      const params = swiper.params.zoom;\n      if (!gesture.slideEl) {\n        if (e && e.target) {\n          gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n        }\n        if (!gesture.slideEl) {\n          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n            gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n          } else {\n            gesture.slideEl = swiper.slides[swiper.activeIndex];\n          }\n        }\n        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n        if (imageEl) {\n          imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n        }\n        gesture.imageEl = imageEl;\n        if (imageEl) {\n          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n        } else {\n          gesture.imageWrapEl = undefined;\n        }\n      }\n      if (!gesture.imageEl || !gesture.imageWrapEl) return;\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style.overflow = 'hidden';\n        swiper.wrapperEl.style.touchAction = 'none';\n      }\n      gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);\n      let touchX;\n      let touchY;\n      let offsetX;\n      let offsetY;\n      let diffX;\n      let diffY;\n      let translateX;\n      let translateY;\n      let imageWidth;\n      let imageHeight;\n      let scaledWidth;\n      let scaledHeight;\n      let translateMinX;\n      let translateMinY;\n      let translateMaxX;\n      let translateMaxY;\n      let slideWidth;\n      let slideHeight;\n      if (typeof image.touchesStart.x === 'undefined' && e) {\n        touchX = e.pageX;\n        touchY = e.pageY;\n      } else {\n        touchX = image.touchesStart.x;\n        touchY = image.touchesStart.y;\n      }\n      const forceZoomRatio = typeof e === 'number' ? e : null;\n      if (currentScale === 1 && forceZoomRatio) {\n        touchX = undefined;\n        touchY = undefined;\n      }\n      zoom.scale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n      currentScale = forceZoomRatio || gesture.imageWrapEl.getAttribute('data-swiper-zoom') || params.maxRatio;\n      if (e && !(currentScale === 1 && forceZoomRatio)) {\n        slideWidth = gesture.slideEl.offsetWidth;\n        slideHeight = gesture.slideEl.offsetHeight;\n        offsetX = elementOffset(gesture.slideEl).left + window.scrollX;\n        offsetY = elementOffset(gesture.slideEl).top + window.scrollY;\n        diffX = offsetX + slideWidth / 2 - touchX;\n        diffY = offsetY + slideHeight / 2 - touchY;\n        imageWidth = gesture.imageEl.offsetWidth;\n        imageHeight = gesture.imageEl.offsetHeight;\n        scaledWidth = imageWidth * zoom.scale;\n        scaledHeight = imageHeight * zoom.scale;\n        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);\n        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);\n        translateMaxX = -translateMinX;\n        translateMaxY = -translateMinY;\n        translateX = diffX * zoom.scale;\n        translateY = diffY * zoom.scale;\n        if (translateX < translateMinX) {\n          translateX = translateMinX;\n        }\n        if (translateX > translateMaxX) {\n          translateX = translateMaxX;\n        }\n        if (translateY < translateMinY) {\n          translateY = translateMinY;\n        }\n        if (translateY > translateMaxY) {\n          translateY = translateMaxY;\n        }\n      } else {\n        translateX = 0;\n        translateY = 0;\n      }\n      if (forceZoomRatio && zoom.scale === 1) {\n        gesture.originX = 0;\n        gesture.originY = 0;\n      }\n      gesture.imageWrapEl.style.transitionDuration = '300ms';\n      gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;\n      gesture.imageEl.style.transitionDuration = '300ms';\n      gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;\n    }\n    function zoomOut() {\n      const zoom = swiper.zoom;\n      const params = swiper.params.zoom;\n      if (!gesture.slideEl) {\n        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {\n          gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];\n        } else {\n          gesture.slideEl = swiper.slides[swiper.activeIndex];\n        }\n        let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);\n        if (imageEl) {\n          imageEl = imageEl.querySelectorAll('picture, img, svg, canvas, .swiper-zoom-target')[0];\n        }\n        gesture.imageEl = imageEl;\n        if (imageEl) {\n          gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];\n        } else {\n          gesture.imageWrapEl = undefined;\n        }\n      }\n      if (!gesture.imageEl || !gesture.imageWrapEl) return;\n      if (swiper.params.cssMode) {\n        swiper.wrapperEl.style.overflow = '';\n        swiper.wrapperEl.style.touchAction = '';\n      }\n      zoom.scale = 1;\n      currentScale = 1;\n      gesture.imageWrapEl.style.transitionDuration = '300ms';\n      gesture.imageWrapEl.style.transform = 'translate3d(0,0,0)';\n      gesture.imageEl.style.transitionDuration = '300ms';\n      gesture.imageEl.style.transform = 'translate3d(0,0,0) scale(1)';\n      gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);\n      gesture.slideEl = undefined;\n      gesture.originX = 0;\n      gesture.originY = 0;\n    }\n\n    // Toggle Zoom\n    function zoomToggle(e) {\n      const zoom = swiper.zoom;\n      if (zoom.scale && zoom.scale !== 1) {\n        // Zoom Out\n        zoomOut();\n      } else {\n        // Zoom In\n        zoomIn(e);\n      }\n    }\n    function getListeners() {\n      const passiveListener = swiper.params.passiveListeners ? {\n        passive: true,\n        capture: false\n      } : false;\n      const activeListenerWithCapture = swiper.params.passiveListeners ? {\n        passive: false,\n        capture: true\n      } : true;\n      return {\n        passiveListener,\n        activeListenerWithCapture\n      };\n    }\n\n    // Attach/Detach Events\n    function enable() {\n      const zoom = swiper.zoom;\n      if (zoom.enabled) return;\n      zoom.enabled = true;\n      const {\n        passiveListener,\n        activeListenerWithCapture\n      } = getListeners();\n\n      // Scale image\n      swiper.wrapperEl.addEventListener('pointerdown', onGestureStart, passiveListener);\n      swiper.wrapperEl.addEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n      ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n        swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);\n      });\n\n      // Move image\n      swiper.wrapperEl.addEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n    }\n    function disable() {\n      const zoom = swiper.zoom;\n      if (!zoom.enabled) return;\n      zoom.enabled = false;\n      const {\n        passiveListener,\n        activeListenerWithCapture\n      } = getListeners();\n\n      // Scale image\n      swiper.wrapperEl.removeEventListener('pointerdown', onGestureStart, passiveListener);\n      swiper.wrapperEl.removeEventListener('pointermove', onGestureChange, activeListenerWithCapture);\n      ['pointerup', 'pointercancel', 'pointerout'].forEach(eventName => {\n        swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);\n      });\n\n      // Move image\n      swiper.wrapperEl.removeEventListener('pointermove', onTouchMove, activeListenerWithCapture);\n    }\n    on('init', () => {\n      if (swiper.params.zoom.enabled) {\n        enable();\n      }\n    });\n    on('destroy', () => {\n      disable();\n    });\n    on('touchStart', (_s, e) => {\n      if (!swiper.zoom.enabled) return;\n      onTouchStart(e);\n    });\n    on('touchEnd', (_s, e) => {\n      if (!swiper.zoom.enabled) return;\n      onTouchEnd();\n    });\n    on('doubleTap', (_s, e) => {\n      if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {\n        zoomToggle(e);\n      }\n    });\n    on('transitionEnd', () => {\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled) {\n        onTransitionEnd();\n      }\n    });\n    on('slideChange', () => {\n      if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {\n        onTransitionEnd();\n      }\n    });\n    Object.assign(swiper.zoom, {\n      enable,\n      disable,\n      in: zoomIn,\n      out: zoomOut,\n      toggle: zoomToggle\n    });\n  }\n\n  /* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\n  function Controller(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      controller: {\n        control: undefined,\n        inverse: false,\n        by: 'slide' // or 'container'\n      }\n    });\n\n    swiper.controller = {\n      control: undefined\n    };\n    function LinearSpline(x, y) {\n      const binarySearch = function search() {\n        let maxIndex;\n        let minIndex;\n        let guess;\n        return (array, val) => {\n          minIndex = -1;\n          maxIndex = array.length;\n          while (maxIndex - minIndex > 1) {\n            guess = maxIndex + minIndex >> 1;\n            if (array[guess] <= val) {\n              minIndex = guess;\n            } else {\n              maxIndex = guess;\n            }\n          }\n          return maxIndex;\n        };\n      }();\n      this.x = x;\n      this.y = y;\n      this.lastIndex = x.length - 1;\n      // Given an x value (x2), return the expected y2 value:\n      // (x1,y1) is the known point before given value,\n      // (x3,y3) is the known point after given value.\n      let i1;\n      let i3;\n      this.interpolate = function interpolate(x2) {\n        if (!x2) return 0;\n\n        // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n        i3 = binarySearch(this.x, x2);\n        i1 = i3 - 1;\n\n        // We have our indexes i1 & i3, so we can calculate already:\n        // y2 := ((x2x1)  (y3y1))  (x3x1) + y1\n        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n      };\n      return this;\n    }\n    function getInterpolateFunction(c) {\n      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n    function setTranslate(_t, byController) {\n      const controlled = swiper.controller.control;\n      let multiplier;\n      let controlledTranslate;\n      const Swiper = swiper.constructor;\n      function setControlledTranslate(c) {\n        if (c.destroyed) return;\n\n        // this will create an Interpolate function based on the snapGrids\n        // x is the Grid of the scrolled scroller and y will be the controlled scroller\n        // it makes sense to create this only once and recall it for the interpolation\n        // the function does a lot of value caching for performance\n        const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n        if (swiper.params.controller.by === 'slide') {\n          getInterpolateFunction(c);\n          // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n          // but it did not work out\n          controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n        }\n        if (!controlledTranslate || swiper.params.controller.by === 'container') {\n          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n          if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {\n            multiplier = 1;\n          }\n          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n        }\n        if (swiper.params.controller.inverse) {\n          controlledTranslate = c.maxTranslate() - controlledTranslate;\n        }\n        c.updateProgress(controlledTranslate);\n        c.setTranslate(controlledTranslate, swiper);\n        c.updateActiveIndex();\n        c.updateSlidesClasses();\n      }\n      if (Array.isArray(controlled)) {\n        for (let i = 0; i < controlled.length; i += 1) {\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n            setControlledTranslate(controlled[i]);\n          }\n        }\n      } else if (controlled instanceof Swiper && byController !== controlled) {\n        setControlledTranslate(controlled);\n      }\n    }\n    function setTransition(duration, byController) {\n      const Swiper = swiper.constructor;\n      const controlled = swiper.controller.control;\n      let i;\n      function setControlledTransition(c) {\n        if (c.destroyed) return;\n        c.setTransition(duration, swiper);\n        if (duration !== 0) {\n          c.transitionStart();\n          if (c.params.autoHeight) {\n            nextTick(() => {\n              c.updateAutoHeight();\n            });\n          }\n          elementTransitionEnd(c.wrapperEl, () => {\n            if (!controlled) return;\n            c.transitionEnd();\n          });\n        }\n      }\n      if (Array.isArray(controlled)) {\n        for (i = 0; i < controlled.length; i += 1) {\n          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n            setControlledTransition(controlled[i]);\n          }\n        }\n      } else if (controlled instanceof Swiper && byController !== controlled) {\n        setControlledTransition(controlled);\n      }\n    }\n    function removeSpline() {\n      if (!swiper.controller.control) return;\n      if (swiper.controller.spline) {\n        swiper.controller.spline = undefined;\n        delete swiper.controller.spline;\n      }\n    }\n    on('beforeInit', () => {\n      if (typeof window !== 'undefined' && (\n      // eslint-disable-line\n      typeof swiper.params.controller.control === 'string' || swiper.params.controller.control instanceof HTMLElement)) {\n        const controlElement = document.querySelector(swiper.params.controller.control);\n        if (controlElement && controlElement.swiper) {\n          swiper.controller.control = controlElement.swiper;\n        } else if (controlElement) {\n          const onControllerSwiper = e => {\n            swiper.controller.control = e.detail[0];\n            swiper.update();\n            controlElement.removeEventListener('init', onControllerSwiper);\n          };\n          controlElement.addEventListener('init', onControllerSwiper);\n        }\n        return;\n      }\n      swiper.controller.control = swiper.params.controller.control;\n    });\n    on('update', () => {\n      removeSpline();\n    });\n    on('resize', () => {\n      removeSpline();\n    });\n    on('observerUpdate', () => {\n      removeSpline();\n    });\n    on('setTranslate', (_s, translate, byController) => {\n      if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n      swiper.controller.setTranslate(translate, byController);\n    });\n    on('setTransition', (_s, duration, byController) => {\n      if (!swiper.controller.control || swiper.controller.control.destroyed) return;\n      swiper.controller.setTransition(duration, byController);\n    });\n    Object.assign(swiper.controller, {\n      setTranslate,\n      setTransition\n    });\n  }\n\n  function A11y(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      a11y: {\n        enabled: true,\n        notificationClass: 'swiper-notification',\n        prevSlideMessage: 'Previous slide',\n        nextSlideMessage: 'Next slide',\n        firstSlideMessage: 'This is the first slide',\n        lastSlideMessage: 'This is the last slide',\n        paginationBulletMessage: 'Go to slide {{index}}',\n        slideLabelMessage: '{{index}} / {{slidesLength}}',\n        containerMessage: null,\n        containerRoleDescriptionMessage: null,\n        itemRoleDescriptionMessage: null,\n        slideRole: 'group',\n        id: null\n      }\n    });\n    swiper.a11y = {\n      clicked: false\n    };\n    let liveRegion = null;\n    function notify(message) {\n      const notification = liveRegion;\n      if (notification.length === 0) return;\n      notification.innerHTML = '';\n      notification.innerHTML = message;\n    }\n    const makeElementsArray = el => {\n      if (!Array.isArray(el)) el = [el].filter(e => !!e);\n      return el;\n    };\n    function getRandomNumber(size) {\n      if (size === void 0) {\n        size = 16;\n      }\n      const randomChar = () => Math.round(16 * Math.random()).toString(16);\n      return 'x'.repeat(size).replace(/x/g, randomChar);\n    }\n    function makeElFocusable(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('tabIndex', '0');\n      });\n    }\n    function makeElNotFocusable(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('tabIndex', '-1');\n      });\n    }\n    function addElRole(el, role) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('role', role);\n      });\n    }\n    function addElRoleDescription(el, description) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-roledescription', description);\n      });\n    }\n    function addElControls(el, controls) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-controls', controls);\n      });\n    }\n    function addElLabel(el, label) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-label', label);\n      });\n    }\n    function addElId(el, id) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('id', id);\n      });\n    }\n    function addElLive(el, live) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-live', live);\n      });\n    }\n    function disableEl(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-disabled', true);\n      });\n    }\n    function enableEl(el) {\n      el = makeElementsArray(el);\n      el.forEach(subEl => {\n        subEl.setAttribute('aria-disabled', false);\n      });\n    }\n    function onEnterOrSpaceKey(e) {\n      if (e.keyCode !== 13 && e.keyCode !== 32) return;\n      const params = swiper.params.a11y;\n      const targetEl = e.target;\n      if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {\n        if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;\n      }\n      if (swiper.navigation && swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) {\n        if (!(swiper.isEnd && !swiper.params.loop)) {\n          swiper.slideNext();\n        }\n        if (swiper.isEnd) {\n          notify(params.lastSlideMessage);\n        } else {\n          notify(params.nextSlideMessage);\n        }\n      }\n      if (swiper.navigation && swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl) {\n        if (!(swiper.isBeginning && !swiper.params.loop)) {\n          swiper.slidePrev();\n        }\n        if (swiper.isBeginning) {\n          notify(params.firstSlideMessage);\n        } else {\n          notify(params.prevSlideMessage);\n        }\n      }\n      if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {\n        targetEl.click();\n      }\n    }\n    function updateNavigation() {\n      if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;\n      const {\n        nextEl,\n        prevEl\n      } = swiper.navigation;\n      if (prevEl) {\n        if (swiper.isBeginning) {\n          disableEl(prevEl);\n          makeElNotFocusable(prevEl);\n        } else {\n          enableEl(prevEl);\n          makeElFocusable(prevEl);\n        }\n      }\n      if (nextEl) {\n        if (swiper.isEnd) {\n          disableEl(nextEl);\n          makeElNotFocusable(nextEl);\n        } else {\n          enableEl(nextEl);\n          makeElFocusable(nextEl);\n        }\n      }\n    }\n    function hasPagination() {\n      return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;\n    }\n    function hasClickablePagination() {\n      return hasPagination() && swiper.params.pagination.clickable;\n    }\n    function updatePagination() {\n      const params = swiper.params.a11y;\n      if (!hasPagination()) return;\n      swiper.pagination.bullets.forEach(bulletEl => {\n        if (swiper.params.pagination.clickable) {\n          makeElFocusable(bulletEl);\n          if (!swiper.params.pagination.renderBullet) {\n            addElRole(bulletEl, 'button');\n            addElLabel(bulletEl, params.paginationBulletMessage.replace(/\\{\\{index\\}\\}/, elementIndex(bulletEl) + 1));\n          }\n        }\n        if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {\n          bulletEl.setAttribute('aria-current', 'true');\n        } else {\n          bulletEl.removeAttribute('aria-current');\n        }\n      });\n    }\n    const initNavEl = (el, wrapperId, message) => {\n      makeElFocusable(el);\n      if (el.tagName !== 'BUTTON') {\n        addElRole(el, 'button');\n        el.addEventListener('keydown', onEnterOrSpaceKey);\n      }\n      addElLabel(el, message);\n      addElControls(el, wrapperId);\n    };\n    const handlePointerDown = () => {\n      swiper.a11y.clicked = true;\n    };\n    const handlePointerUp = () => {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          if (!swiper.destroyed) {\n            swiper.a11y.clicked = false;\n          }\n        });\n      });\n    };\n    const handleFocus = e => {\n      if (swiper.a11y.clicked) return;\n      const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);\n      if (!slideEl || !swiper.slides.includes(slideEl)) return;\n      const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;\n      const isVisible = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);\n      if (isActive || isVisible) return;\n      if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;\n      if (swiper.isHorizontal()) {\n        swiper.el.scrollLeft = 0;\n      } else {\n        swiper.el.scrollTop = 0;\n      }\n      swiper.slideTo(swiper.slides.indexOf(slideEl), 0);\n    };\n    const initSlides = () => {\n      const params = swiper.params.a11y;\n      if (params.itemRoleDescriptionMessage) {\n        addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);\n      }\n      if (params.slideRole) {\n        addElRole(swiper.slides, params.slideRole);\n      }\n      const slidesLength = swiper.slides.length;\n      if (params.slideLabelMessage) {\n        swiper.slides.forEach((slideEl, index) => {\n          const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10) : index;\n          const ariaLabelMessage = params.slideLabelMessage.replace(/\\{\\{index\\}\\}/, slideIndex + 1).replace(/\\{\\{slidesLength\\}\\}/, slidesLength);\n          addElLabel(slideEl, ariaLabelMessage);\n        });\n      }\n    };\n    const init = () => {\n      const params = swiper.params.a11y;\n      swiper.el.append(liveRegion);\n\n      // Container\n      const containerEl = swiper.el;\n      if (params.containerRoleDescriptionMessage) {\n        addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);\n      }\n      if (params.containerMessage) {\n        addElLabel(containerEl, params.containerMessage);\n      }\n\n      // Wrapper\n      const wrapperEl = swiper.wrapperEl;\n      const wrapperId = params.id || wrapperEl.getAttribute('id') || `swiper-wrapper-${getRandomNumber(16)}`;\n      const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? 'off' : 'polite';\n      addElId(wrapperEl, wrapperId);\n      addElLive(wrapperEl, live);\n\n      // Slide\n      initSlides();\n\n      // Navigation\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation ? swiper.navigation : {};\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      if (nextEl) {\n        nextEl.forEach(el => initNavEl(el, wrapperId, params.nextSlideMessage));\n      }\n      if (prevEl) {\n        prevEl.forEach(el => initNavEl(el, wrapperId, params.prevSlideMessage));\n      }\n\n      // Pagination\n      if (hasClickablePagination()) {\n        const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n        paginationEl.forEach(el => {\n          el.addEventListener('keydown', onEnterOrSpaceKey);\n        });\n      }\n\n      // Tab focus\n      swiper.el.addEventListener('focus', handleFocus, true);\n      swiper.el.addEventListener('pointerdown', handlePointerDown, true);\n      swiper.el.addEventListener('pointerup', handlePointerUp, true);\n    };\n    function destroy() {\n      if (liveRegion) liveRegion.remove();\n      let {\n        nextEl,\n        prevEl\n      } = swiper.navigation ? swiper.navigation : {};\n      nextEl = makeElementsArray(nextEl);\n      prevEl = makeElementsArray(prevEl);\n      if (nextEl) {\n        nextEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n      }\n      if (prevEl) {\n        prevEl.forEach(el => el.removeEventListener('keydown', onEnterOrSpaceKey));\n      }\n\n      // Pagination\n      if (hasClickablePagination()) {\n        const paginationEl = Array.isArray(swiper.pagination.el) ? swiper.pagination.el : [swiper.pagination.el];\n        paginationEl.forEach(el => {\n          el.removeEventListener('keydown', onEnterOrSpaceKey);\n        });\n      }\n\n      // Tab focus\n      swiper.el.removeEventListener('focus', handleFocus, true);\n      swiper.el.removeEventListener('pointerdown', handlePointerDown, true);\n      swiper.el.removeEventListener('pointerup', handlePointerUp, true);\n    }\n    on('beforeInit', () => {\n      liveRegion = createElement('span', swiper.params.a11y.notificationClass);\n      liveRegion.setAttribute('aria-live', 'assertive');\n      liveRegion.setAttribute('aria-atomic', 'true');\n    });\n    on('afterInit', () => {\n      if (!swiper.params.a11y.enabled) return;\n      init();\n    });\n    on('slidesLengthChange snapGridLengthChange slidesGridLengthChange', () => {\n      if (!swiper.params.a11y.enabled) return;\n      initSlides();\n    });\n    on('fromEdge toEdge afterInit lock unlock', () => {\n      if (!swiper.params.a11y.enabled) return;\n      updateNavigation();\n    });\n    on('paginationUpdate', () => {\n      if (!swiper.params.a11y.enabled) return;\n      updatePagination();\n    });\n    on('destroy', () => {\n      if (!swiper.params.a11y.enabled) return;\n      destroy();\n    });\n  }\n\n  function History(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      history: {\n        enabled: false,\n        root: '',\n        replaceState: false,\n        key: 'slides',\n        keepQuery: false\n      }\n    });\n    let initialized = false;\n    let paths = {};\n    const slugify = text => {\n      return text.toString().replace(/\\s+/g, '-').replace(/[^\\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');\n    };\n    const getPathValues = urlOverride => {\n      const window = getWindow();\n      let location;\n      if (urlOverride) {\n        location = new URL(urlOverride);\n      } else {\n        location = window.location;\n      }\n      const pathArray = location.pathname.slice(1).split('/').filter(part => part !== '');\n      const total = pathArray.length;\n      const key = pathArray[total - 2];\n      const value = pathArray[total - 1];\n      return {\n        key,\n        value\n      };\n    };\n    const setHistory = (key, index) => {\n      const window = getWindow();\n      if (!initialized || !swiper.params.history.enabled) return;\n      let location;\n      if (swiper.params.url) {\n        location = new URL(swiper.params.url);\n      } else {\n        location = window.location;\n      }\n      const slide = swiper.slides[index];\n      let value = slugify(slide.getAttribute('data-history'));\n      if (swiper.params.history.root.length > 0) {\n        let root = swiper.params.history.root;\n        if (root[root.length - 1] === '/') root = root.slice(0, root.length - 1);\n        value = `${root}/${key ? `${key}/` : ''}${value}`;\n      } else if (!location.pathname.includes(key)) {\n        value = `${key ? `${key}/` : ''}${value}`;\n      }\n      if (swiper.params.history.keepQuery) {\n        value += location.search;\n      }\n      const currentState = window.history.state;\n      if (currentState && currentState.value === value) {\n        return;\n      }\n      if (swiper.params.history.replaceState) {\n        window.history.replaceState({\n          value\n        }, null, value);\n      } else {\n        window.history.pushState({\n          value\n        }, null, value);\n      }\n    };\n    const scrollToSlide = (speed, value, runCallbacks) => {\n      if (value) {\n        for (let i = 0, length = swiper.slides.length; i < length; i += 1) {\n          const slide = swiper.slides[i];\n          const slideHistory = slugify(slide.getAttribute('data-history'));\n          if (slideHistory === value) {\n            const index = swiper.getSlideIndex(slide);\n            swiper.slideTo(index, speed, runCallbacks);\n          }\n        }\n      } else {\n        swiper.slideTo(0, speed, runCallbacks);\n      }\n    };\n    const setHistoryPopState = () => {\n      paths = getPathValues(swiper.params.url);\n      scrollToSlide(swiper.params.speed, paths.value, false);\n    };\n    const init = () => {\n      const window = getWindow();\n      if (!swiper.params.history) return;\n      if (!window.history || !window.history.pushState) {\n        swiper.params.history.enabled = false;\n        swiper.params.hashNavigation.enabled = true;\n        return;\n      }\n      initialized = true;\n      paths = getPathValues(swiper.params.url);\n      if (!paths.key && !paths.value) {\n        if (!swiper.params.history.replaceState) {\n          window.addEventListener('popstate', setHistoryPopState);\n        }\n        return;\n      }\n      scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);\n      if (!swiper.params.history.replaceState) {\n        window.addEventListener('popstate', setHistoryPopState);\n      }\n    };\n    const destroy = () => {\n      const window = getWindow();\n      if (!swiper.params.history.replaceState) {\n        window.removeEventListener('popstate', setHistoryPopState);\n      }\n    };\n    on('init', () => {\n      if (swiper.params.history.enabled) {\n        init();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.params.history.enabled) {\n        destroy();\n      }\n    });\n    on('transitionEnd _freeModeNoMomentumRelease', () => {\n      if (initialized) {\n        setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    });\n    on('slideChange', () => {\n      if (initialized && swiper.params.cssMode) {\n        setHistory(swiper.params.history.key, swiper.activeIndex);\n      }\n    });\n  }\n\n  function HashNavigation(_ref) {\n    let {\n      swiper,\n      extendParams,\n      emit,\n      on\n    } = _ref;\n    let initialized = false;\n    const document = getDocument();\n    const window = getWindow();\n    extendParams({\n      hashNavigation: {\n        enabled: false,\n        replaceState: false,\n        watchState: false,\n        getSlideIndex(_s, hash) {\n          if (swiper.virtual && swiper.params.virtual.enabled) {\n            const slideWithHash = swiper.slides.filter(slideEl => slideEl.getAttribute('data-hash') === hash)[0];\n            if (!slideWithHash) return 0;\n            const index = parseInt(slideWithHash.getAttribute('data-swiper-slide-index'), 10);\n            return index;\n          }\n          return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash=\"${hash}\"], swiper-slide[data-hash=\"${hash}\"]`)[0]);\n        }\n      }\n    });\n    const onHashChange = () => {\n      emit('hashChange');\n      const newHash = document.location.hash.replace('#', '');\n      const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n      const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') : '';\n      if (newHash !== activeSlideHash) {\n        const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);\n        if (typeof newIndex === 'undefined' || Number.isNaN(newIndex)) return;\n        swiper.slideTo(newIndex);\n      }\n    };\n    const setHash = () => {\n      if (!initialized || !swiper.params.hashNavigation.enabled) return;\n      const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index=\"${swiper.activeIndex}\"]`) : swiper.slides[swiper.activeIndex];\n      const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute('data-hash') || activeSlideEl.getAttribute('data-history') : '';\n      if (swiper.params.hashNavigation.replaceState && window.history && window.history.replaceState) {\n        window.history.replaceState(null, null, `#${activeSlideHash}` || '');\n        emit('hashSet');\n      } else {\n        document.location.hash = activeSlideHash || '';\n        emit('hashSet');\n      }\n    };\n    const init = () => {\n      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;\n      initialized = true;\n      const hash = document.location.hash.replace('#', '');\n      if (hash) {\n        const speed = 0;\n        const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);\n        swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);\n      }\n      if (swiper.params.hashNavigation.watchState) {\n        window.addEventListener('hashchange', onHashChange);\n      }\n    };\n    const destroy = () => {\n      if (swiper.params.hashNavigation.watchState) {\n        window.removeEventListener('hashchange', onHashChange);\n      }\n    };\n    on('init', () => {\n      if (swiper.params.hashNavigation.enabled) {\n        init();\n      }\n    });\n    on('destroy', () => {\n      if (swiper.params.hashNavigation.enabled) {\n        destroy();\n      }\n    });\n    on('transitionEnd _freeModeNoMomentumRelease', () => {\n      if (initialized) {\n        setHash();\n      }\n    });\n    on('slideChange', () => {\n      if (initialized && swiper.params.cssMode) {\n        setHash();\n      }\n    });\n  }\n\n  /* eslint no-underscore-dangle: \"off\" */\n  /* eslint no-use-before-define: \"off\" */\n  function Autoplay(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on,\n      emit,\n      params\n    } = _ref;\n    swiper.autoplay = {\n      running: false,\n      paused: false,\n      timeLeft: 0\n    };\n    extendParams({\n      autoplay: {\n        enabled: false,\n        delay: 3000,\n        waitForTransition: true,\n        disableOnInteraction: true,\n        stopOnLastSlide: false,\n        reverseDirection: false,\n        pauseOnMouseEnter: false\n      }\n    });\n    let timeout;\n    let raf;\n    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3000;\n    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3000;\n    let autoplayTimeLeft;\n    let autoplayStartTime = new Date().getTime;\n    let wasPaused;\n    let isTouched;\n    let pausedByTouch;\n    let touchStartTimeout;\n    let slideChanged;\n    let pausedByInteraction;\n    function onTransitionEnd(e) {\n      if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;\n      if (e.target !== swiper.wrapperEl) return;\n      swiper.wrapperEl.removeEventListener('transitionend', onTransitionEnd);\n      resume();\n    }\n    const calcTimeLeft = () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      if (swiper.autoplay.paused) {\n        wasPaused = true;\n      } else if (wasPaused) {\n        autoplayDelayCurrent = autoplayTimeLeft;\n        wasPaused = false;\n      }\n      const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();\n      swiper.autoplay.timeLeft = timeLeft;\n      emit('autoplayTimeLeft', timeLeft, timeLeft / autoplayDelayTotal);\n      raf = requestAnimationFrame(() => {\n        calcTimeLeft();\n      });\n    };\n    const getSlideDelay = () => {\n      let activeSlideEl;\n      if (swiper.virtual && swiper.params.virtual.enabled) {\n        activeSlideEl = swiper.slides.filter(slideEl => slideEl.classList.contains('swiper-slide-active'))[0];\n      } else {\n        activeSlideEl = swiper.slides[swiper.activeIndex];\n      }\n      if (!activeSlideEl) return undefined;\n      const currentSlideDelay = parseInt(activeSlideEl.getAttribute('data-swiper-autoplay'), 10);\n      return currentSlideDelay;\n    };\n    const run = delayForce => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      cancelAnimationFrame(raf);\n      calcTimeLeft();\n      let delay = typeof delayForce === 'undefined' ? swiper.params.autoplay.delay : delayForce;\n      autoplayDelayTotal = swiper.params.autoplay.delay;\n      autoplayDelayCurrent = swiper.params.autoplay.delay;\n      const currentSlideDelay = getSlideDelay();\n      if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === 'undefined') {\n        delay = currentSlideDelay;\n        autoplayDelayTotal = currentSlideDelay;\n        autoplayDelayCurrent = currentSlideDelay;\n      }\n      autoplayTimeLeft = delay;\n      const speed = swiper.params.speed;\n      const proceed = () => {\n        if (!swiper || swiper.destroyed) return;\n        if (swiper.params.autoplay.reverseDirection) {\n          if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {\n            swiper.slidePrev(speed, true, true);\n            emit('autoplay');\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\n            swiper.slideTo(swiper.slides.length - 1, speed, true, true);\n            emit('autoplay');\n          }\n        } else {\n          if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {\n            swiper.slideNext(speed, true, true);\n            emit('autoplay');\n          } else if (!swiper.params.autoplay.stopOnLastSlide) {\n            swiper.slideTo(0, speed, true, true);\n            emit('autoplay');\n          }\n        }\n        if (swiper.params.cssMode) {\n          autoplayStartTime = new Date().getTime();\n          requestAnimationFrame(() => {\n            run();\n          });\n        }\n      };\n      if (delay > 0) {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n          proceed();\n        }, delay);\n      } else {\n        requestAnimationFrame(() => {\n          proceed();\n        });\n      }\n\n      // eslint-disable-next-line\n      return delay;\n    };\n    const start = () => {\n      swiper.autoplay.running = true;\n      run();\n      emit('autoplayStart');\n    };\n    const stop = () => {\n      swiper.autoplay.running = false;\n      clearTimeout(timeout);\n      cancelAnimationFrame(raf);\n      emit('autoplayStop');\n    };\n    const pause = (internal, reset) => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      clearTimeout(timeout);\n      if (!internal) {\n        pausedByInteraction = true;\n      }\n      const proceed = () => {\n        emit('autoplayPause');\n        if (swiper.params.autoplay.waitForTransition) {\n          swiper.wrapperEl.addEventListener('transitionend', onTransitionEnd);\n        } else {\n          resume();\n        }\n      };\n      swiper.autoplay.paused = true;\n      if (reset) {\n        if (slideChanged) {\n          autoplayTimeLeft = swiper.params.autoplay.delay;\n        }\n        slideChanged = false;\n        proceed();\n        return;\n      }\n      const delay = autoplayTimeLeft || swiper.params.autoplay.delay;\n      autoplayTimeLeft = delay - (new Date().getTime() - autoplayStartTime);\n      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;\n      if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;\n      proceed();\n    };\n    const resume = () => {\n      if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;\n      autoplayStartTime = new Date().getTime();\n      if (pausedByInteraction) {\n        pausedByInteraction = false;\n        run(autoplayTimeLeft);\n      } else {\n        run();\n      }\n      swiper.autoplay.paused = false;\n      emit('autoplayResume');\n    };\n    const onVisibilityChange = () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      const document = getDocument();\n      if (document.visibilityState === 'hidden') {\n        pausedByInteraction = true;\n        pause(true);\n      }\n      if (document.visibilityState === 'visible') {\n        resume();\n      }\n    };\n    const onPointerEnter = e => {\n      if (e.pointerType !== 'mouse') return;\n      pausedByInteraction = true;\n      pause(true);\n    };\n    const onPointerLeave = e => {\n      if (e.pointerType !== 'mouse') return;\n      if (swiper.autoplay.paused) {\n        resume();\n      }\n    };\n    const attachMouseEvents = () => {\n      if (swiper.params.autoplay.pauseOnMouseEnter) {\n        swiper.el.addEventListener('pointerenter', onPointerEnter);\n        swiper.el.addEventListener('pointerleave', onPointerLeave);\n      }\n    };\n    const detachMouseEvents = () => {\n      swiper.el.removeEventListener('pointerenter', onPointerEnter);\n      swiper.el.removeEventListener('pointerleave', onPointerLeave);\n    };\n    const attachDocumentEvents = () => {\n      const document = getDocument();\n      document.addEventListener('visibilitychange', onVisibilityChange);\n    };\n    const detachDocumentEvents = () => {\n      const document = getDocument();\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    };\n    on('init', () => {\n      if (swiper.params.autoplay.enabled) {\n        attachMouseEvents();\n        attachDocumentEvents();\n        autoplayStartTime = new Date().getTime();\n        start();\n      }\n    });\n    on('destroy', () => {\n      detachMouseEvents();\n      detachDocumentEvents();\n      if (swiper.autoplay.running) {\n        stop();\n      }\n    });\n    on('beforeTransitionStart', (_s, speed, internal) => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      if (internal || !swiper.params.autoplay.disableOnInteraction) {\n        pause(true, true);\n      } else {\n        stop();\n      }\n    });\n    on('sliderFirstMove', () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      if (swiper.params.autoplay.disableOnInteraction) {\n        stop();\n        return;\n      }\n      isTouched = true;\n      pausedByTouch = false;\n      pausedByInteraction = false;\n      touchStartTimeout = setTimeout(() => {\n        pausedByInteraction = true;\n        pausedByTouch = true;\n        pause(true);\n      }, 200);\n    });\n    on('touchEnd', () => {\n      if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;\n      clearTimeout(touchStartTimeout);\n      clearTimeout(timeout);\n      if (swiper.params.autoplay.disableOnInteraction) {\n        pausedByTouch = false;\n        isTouched = false;\n        return;\n      }\n      if (pausedByTouch && swiper.params.cssMode) resume();\n      pausedByTouch = false;\n      isTouched = false;\n    });\n    on('slideChange', () => {\n      if (swiper.destroyed || !swiper.autoplay.running) return;\n      slideChanged = true;\n    });\n    Object.assign(swiper.autoplay, {\n      start,\n      stop,\n      pause,\n      resume\n    });\n  }\n\n  function Thumb(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      thumbs: {\n        swiper: null,\n        multipleActiveThumbs: true,\n        autoScrollOffset: 0,\n        slideThumbActiveClass: 'swiper-slide-thumb-active',\n        thumbsContainerClass: 'swiper-thumbs'\n      }\n    });\n    let initialized = false;\n    let swiperCreated = false;\n    swiper.thumbs = {\n      swiper: null\n    };\n    function onThumbClick() {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      const clickedIndex = thumbsSwiper.clickedIndex;\n      const clickedSlide = thumbsSwiper.clickedSlide;\n      if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;\n      if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;\n      let slideToIndex;\n      if (thumbsSwiper.params.loop) {\n        slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);\n      } else {\n        slideToIndex = clickedIndex;\n      }\n      if (swiper.params.loop) {\n        swiper.slideToLoop(slideToIndex);\n      } else {\n        swiper.slideTo(slideToIndex);\n      }\n    }\n    function init() {\n      const {\n        thumbs: thumbsParams\n      } = swiper.params;\n      if (initialized) return false;\n      initialized = true;\n      const SwiperClass = swiper.constructor;\n      if (thumbsParams.swiper instanceof SwiperClass) {\n        swiper.thumbs.swiper = thumbsParams.swiper;\n        Object.assign(swiper.thumbs.swiper.originalParams, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false\n        });\n        Object.assign(swiper.thumbs.swiper.params, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false\n        });\n        swiper.thumbs.swiper.update();\n      } else if (isObject(thumbsParams.swiper)) {\n        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);\n        Object.assign(thumbsSwiperParams, {\n          watchSlidesProgress: true,\n          slideToClickedSlide: false\n        });\n        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);\n        swiperCreated = true;\n      }\n      swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);\n      swiper.thumbs.swiper.on('tap', onThumbClick);\n      return true;\n    }\n    function update(initial) {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;\n\n      // Activate thumbs\n      let thumbsToActivate = 1;\n      const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;\n      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {\n        thumbsToActivate = swiper.params.slidesPerView;\n      }\n      if (!swiper.params.thumbs.multipleActiveThumbs) {\n        thumbsToActivate = 1;\n      }\n      thumbsToActivate = Math.floor(thumbsToActivate);\n      thumbsSwiper.slides.forEach(slideEl => slideEl.classList.remove(thumbActiveClass));\n      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {\n        for (let i = 0; i < thumbsToActivate; i += 1) {\n          elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index=\"${swiper.realIndex + i}\"]`).forEach(slideEl => {\n            slideEl.classList.add(thumbActiveClass);\n          });\n        }\n      } else {\n        for (let i = 0; i < thumbsToActivate; i += 1) {\n          if (thumbsSwiper.slides[swiper.realIndex + i]) {\n            thumbsSwiper.slides[swiper.realIndex + i].classList.add(thumbActiveClass);\n          }\n        }\n      }\n      const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;\n      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;\n      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {\n        const currentThumbsIndex = thumbsSwiper.activeIndex;\n        let newThumbsIndex;\n        let direction;\n        if (thumbsSwiper.params.loop) {\n          const newThumbsSlide = thumbsSwiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') === `${swiper.realIndex}`)[0];\n          newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);\n          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';\n        } else {\n          newThumbsIndex = swiper.realIndex;\n          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';\n        }\n        if (useOffset) {\n          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;\n        }\n        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {\n          if (thumbsSwiper.params.centeredSlides) {\n            if (newThumbsIndex > currentThumbsIndex) {\n              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;\n            } else {\n              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;\n            }\n          } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;\n          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);\n        }\n      }\n    }\n    on('beforeInit', () => {\n      const {\n        thumbs\n      } = swiper.params;\n      if (!thumbs || !thumbs.swiper) return;\n      if (typeof thumbs.swiper === 'string' || thumbs.swiper instanceof HTMLElement) {\n        const document = getDocument();\n        const getThumbsElementAndInit = () => {\n          const thumbsElement = typeof thumbs.swiper === 'string' ? document.querySelector(thumbs.swiper) : thumbs.swiper;\n          if (thumbsElement && thumbsElement.swiper) {\n            thumbs.swiper = thumbsElement.swiper;\n            init();\n            update(true);\n          } else if (thumbsElement) {\n            const onThumbsSwiper = e => {\n              thumbs.swiper = e.detail[0];\n              thumbsElement.removeEventListener('init', onThumbsSwiper);\n              init();\n              update(true);\n              thumbs.swiper.update();\n              swiper.update();\n            };\n            thumbsElement.addEventListener('init', onThumbsSwiper);\n          }\n          return thumbsElement;\n        };\n        const watchForThumbsToAppear = () => {\n          if (swiper.destroyed) return;\n          const thumbsElement = getThumbsElementAndInit();\n          if (!thumbsElement) {\n            requestAnimationFrame(watchForThumbsToAppear);\n          }\n        };\n        requestAnimationFrame(watchForThumbsToAppear);\n      } else {\n        init();\n        update(true);\n      }\n    });\n    on('slideChange update resize observerUpdate', () => {\n      update();\n    });\n    on('setTransition', (_s, duration) => {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      thumbsSwiper.setTransition(duration);\n    });\n    on('beforeDestroy', () => {\n      const thumbsSwiper = swiper.thumbs.swiper;\n      if (!thumbsSwiper || thumbsSwiper.destroyed) return;\n      if (swiperCreated) {\n        thumbsSwiper.destroy();\n      }\n    });\n    Object.assign(swiper.thumbs, {\n      init,\n      update\n    });\n  }\n\n  function freeMode(_ref) {\n    let {\n      swiper,\n      extendParams,\n      emit,\n      once\n    } = _ref;\n    extendParams({\n      freeMode: {\n        enabled: false,\n        momentum: true,\n        momentumRatio: 1,\n        momentumBounce: true,\n        momentumBounceRatio: 1,\n        momentumVelocityRatio: 1,\n        sticky: false,\n        minimumVelocity: 0.02\n      }\n    });\n    function onTouchStart() {\n      if (swiper.params.cssMode) return;\n      const translate = swiper.getTranslate();\n      swiper.setTranslate(translate);\n      swiper.setTransition(0);\n      swiper.touchEventsData.velocities.length = 0;\n      swiper.freeMode.onTouchEnd({\n        currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n      });\n    }\n    function onTouchMove() {\n      if (swiper.params.cssMode) return;\n      const {\n        touchEventsData: data,\n        touches\n      } = swiper;\n      // Velocity\n      if (data.velocities.length === 0) {\n        data.velocities.push({\n          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n          time: data.touchStartTime\n        });\n      }\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n        time: now()\n      });\n    }\n    function onTouchEnd(_ref2) {\n      let {\n        currentPos\n      } = _ref2;\n      if (swiper.params.cssMode) return;\n      const {\n        params,\n        wrapperEl,\n        rtlTranslate: rtl,\n        snapGrid,\n        touchEventsData: data\n      } = swiper;\n      // Time diff\n      const touchEndTime = now();\n      const timeDiff = touchEndTime - data.touchStartTime;\n      if (currentPos < -swiper.minTranslate()) {\n        swiper.slideTo(swiper.activeIndex);\n        return;\n      }\n      if (currentPos > -swiper.maxTranslate()) {\n        if (swiper.slides.length < snapGrid.length) {\n          swiper.slideTo(snapGrid.length - 1);\n        } else {\n          swiper.slideTo(swiper.slides.length - 1);\n        }\n        return;\n      }\n      if (params.freeMode.momentum) {\n        if (data.velocities.length > 1) {\n          const lastMoveEvent = data.velocities.pop();\n          const velocityEvent = data.velocities.pop();\n          const distance = lastMoveEvent.position - velocityEvent.position;\n          const time = lastMoveEvent.time - velocityEvent.time;\n          swiper.velocity = distance / time;\n          swiper.velocity /= 2;\n          if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n            swiper.velocity = 0;\n          }\n          // this implies that the user stopped moving a finger then released.\n          // There would be no events with distance zero, so the last event is stale.\n          if (time > 150 || now() - lastMoveEvent.time > 300) {\n            swiper.velocity = 0;\n          }\n        } else {\n          swiper.velocity = 0;\n        }\n        swiper.velocity *= params.freeMode.momentumVelocityRatio;\n        data.velocities.length = 0;\n        let momentumDuration = 1000 * params.freeMode.momentumRatio;\n        const momentumDistance = swiper.velocity * momentumDuration;\n        let newPosition = swiper.translate + momentumDistance;\n        if (rtl) newPosition = -newPosition;\n        let doBounce = false;\n        let afterBouncePosition;\n        const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n        let needsLoopFix;\n        if (newPosition < swiper.maxTranslate()) {\n          if (params.freeMode.momentumBounce) {\n            if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n              newPosition = swiper.maxTranslate() - bounceAmount;\n            }\n            afterBouncePosition = swiper.maxTranslate();\n            doBounce = true;\n            data.allowMomentumBounce = true;\n          } else {\n            newPosition = swiper.maxTranslate();\n          }\n          if (params.loop && params.centeredSlides) needsLoopFix = true;\n        } else if (newPosition > swiper.minTranslate()) {\n          if (params.freeMode.momentumBounce) {\n            if (newPosition - swiper.minTranslate() > bounceAmount) {\n              newPosition = swiper.minTranslate() + bounceAmount;\n            }\n            afterBouncePosition = swiper.minTranslate();\n            doBounce = true;\n            data.allowMomentumBounce = true;\n          } else {\n            newPosition = swiper.minTranslate();\n          }\n          if (params.loop && params.centeredSlides) needsLoopFix = true;\n        } else if (params.freeMode.sticky) {\n          let nextSlide;\n          for (let j = 0; j < snapGrid.length; j += 1) {\n            if (snapGrid[j] > -newPosition) {\n              nextSlide = j;\n              break;\n            }\n          }\n          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n            newPosition = snapGrid[nextSlide];\n          } else {\n            newPosition = snapGrid[nextSlide - 1];\n          }\n          newPosition = -newPosition;\n        }\n        if (needsLoopFix) {\n          once('transitionEnd', () => {\n            swiper.loopFix();\n          });\n        }\n        // Fix duration\n        if (swiper.velocity !== 0) {\n          if (rtl) {\n            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n          } else {\n            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n          }\n          if (params.freeMode.sticky) {\n            // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n            // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n            // It's easy to see this when simulating touch with mouse events. To fix this,\n            // limit single-slide swipes to the default slide duration. This also has the\n            // nice side effect of matching slide speed if the user stopped moving before\n            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n            // For faster swipes, also apply limits (albeit higher ones).\n            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n            if (moveDistance < currentSlideSize) {\n              momentumDuration = params.speed;\n            } else if (moveDistance < 2 * currentSlideSize) {\n              momentumDuration = params.speed * 1.5;\n            } else {\n              momentumDuration = params.speed * 2.5;\n            }\n          }\n        } else if (params.freeMode.sticky) {\n          swiper.slideToClosest();\n          return;\n        }\n        if (params.freeMode.momentumBounce && doBounce) {\n          swiper.updateProgress(afterBouncePosition);\n          swiper.setTransition(momentumDuration);\n          swiper.setTranslate(newPosition);\n          swiper.transitionStart(true, swiper.swipeDirection);\n          swiper.animating = true;\n          elementTransitionEnd(wrapperEl, () => {\n            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n            emit('momentumBounce');\n            swiper.setTransition(params.speed);\n            setTimeout(() => {\n              swiper.setTranslate(afterBouncePosition);\n              elementTransitionEnd(wrapperEl, () => {\n                if (!swiper || swiper.destroyed) return;\n                swiper.transitionEnd();\n              });\n            }, 0);\n          });\n        } else if (swiper.velocity) {\n          emit('_freeModeNoMomentumRelease');\n          swiper.updateProgress(newPosition);\n          swiper.setTransition(momentumDuration);\n          swiper.setTranslate(newPosition);\n          swiper.transitionStart(true, swiper.swipeDirection);\n          if (!swiper.animating) {\n            swiper.animating = true;\n            elementTransitionEnd(wrapperEl, () => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }\n        } else {\n          swiper.updateProgress(newPosition);\n        }\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      } else if (params.freeMode) {\n        emit('_freeModeNoMomentumRelease');\n      }\n      if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n      }\n    }\n    Object.assign(swiper, {\n      freeMode: {\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd\n      }\n    });\n  }\n\n  function Grid(_ref) {\n    let {\n      swiper,\n      extendParams\n    } = _ref;\n    extendParams({\n      grid: {\n        rows: 1,\n        fill: 'column'\n      }\n    });\n    let slidesNumberEvenToRows;\n    let slidesPerRow;\n    let numFullColumns;\n    const getSpaceBetween = () => {\n      let spaceBetween = swiper.params.spaceBetween;\n      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {\n        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;\n      } else if (typeof spaceBetween === 'string') {\n        spaceBetween = parseFloat(spaceBetween);\n      }\n      return spaceBetween;\n    };\n    const initSlides = slidesLength => {\n      const {\n        slidesPerView\n      } = swiper.params;\n      const {\n        rows,\n        fill\n      } = swiper.params.grid;\n      numFullColumns = Math.floor(slidesLength / rows);\n      if (Math.floor(slidesLength / rows) === slidesLength / rows) {\n        slidesNumberEvenToRows = slidesLength;\n      } else {\n        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;\n      }\n      if (slidesPerView !== 'auto' && fill === 'row') {\n        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);\n      }\n      slidesPerRow = slidesNumberEvenToRows / rows;\n    };\n    const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {\n      const {\n        slidesPerGroup\n      } = swiper.params;\n      const spaceBetween = getSpaceBetween();\n      const {\n        rows,\n        fill\n      } = swiper.params.grid;\n      // Set slides order\n      let newSlideOrderIndex;\n      let column;\n      let row;\n      if (fill === 'row' && slidesPerGroup > 1) {\n        const groupIndex = Math.floor(i / (slidesPerGroup * rows));\n        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;\n        const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);\n        row = Math.floor(slideIndexInGroup / columnsInGroup);\n        column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;\n        newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;\n        slide.style.order = newSlideOrderIndex;\n      } else if (fill === 'column') {\n        column = Math.floor(i / rows);\n        row = i - column * rows;\n        if (column > numFullColumns || column === numFullColumns && row === rows - 1) {\n          row += 1;\n          if (row >= rows) {\n            row = 0;\n            column += 1;\n          }\n        }\n      } else {\n        row = Math.floor(i / slidesPerRow);\n        column = i - row * slidesPerRow;\n      }\n      slide.row = row;\n      slide.column = column;\n      slide.style[getDirectionLabel('margin-top')] = row !== 0 ? spaceBetween && `${spaceBetween}px` : '';\n    };\n    const updateWrapperSize = (slideSize, snapGrid, getDirectionLabel) => {\n      const {\n        centeredSlides,\n        roundLengths\n      } = swiper.params;\n      const spaceBetween = getSpaceBetween();\n      const {\n        rows\n      } = swiper.params.grid;\n      swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;\n      swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;\n      swiper.wrapperEl.style[getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;\n      if (centeredSlides) {\n        const newSlidesGrid = [];\n        for (let i = 0; i < snapGrid.length; i += 1) {\n          let slidesGridItem = snapGrid[i];\n          if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);\n          if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);\n        }\n        snapGrid.splice(0, snapGrid.length);\n        snapGrid.push(...newSlidesGrid);\n      }\n    };\n    swiper.grid = {\n      initSlides,\n      updateSlide,\n      updateWrapperSize\n    };\n  }\n\n  function appendSlide(slides) {\n    const swiper = this;\n    const {\n      params,\n      slidesEl\n    } = swiper;\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    const appendElement = slideEl => {\n      if (typeof slideEl === 'string') {\n        const tempDOM = document.createElement('div');\n        tempDOM.innerHTML = slideEl;\n        slidesEl.append(tempDOM.children[0]);\n        tempDOM.innerHTML = '';\n      } else {\n        slidesEl.append(slideEl);\n      }\n    };\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) appendElement(slides[i]);\n      }\n    } else {\n      appendElement(slides);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n  }\n\n  function prependSlide(slides) {\n    const swiper = this;\n    const {\n      params,\n      activeIndex,\n      slidesEl\n    } = swiper;\n    if (params.loop) {\n      swiper.loopDestroy();\n    }\n    let newActiveIndex = activeIndex + 1;\n    const prependElement = slideEl => {\n      if (typeof slideEl === 'string') {\n        const tempDOM = document.createElement('div');\n        tempDOM.innerHTML = slideEl;\n        slidesEl.prepend(tempDOM.children[0]);\n        tempDOM.innerHTML = '';\n      } else {\n        slidesEl.prepend(slideEl);\n      }\n    };\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) prependElement(slides[i]);\n      }\n      newActiveIndex = activeIndex + slides.length;\n    } else {\n      prependElement(slides);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n    swiper.slideTo(newActiveIndex, 0, false);\n  }\n\n  function addSlide(index, slides) {\n    const swiper = this;\n    const {\n      params,\n      activeIndex,\n      slidesEl\n    } = swiper;\n    let activeIndexBuffer = activeIndex;\n    if (params.loop) {\n      activeIndexBuffer -= swiper.loopedSlides;\n      swiper.loopDestroy();\n      swiper.recalcSlides();\n    }\n    const baseLength = swiper.slides.length;\n    if (index <= 0) {\n      swiper.prependSlide(slides);\n      return;\n    }\n    if (index >= baseLength) {\n      swiper.appendSlide(slides);\n      return;\n    }\n    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;\n    const slidesBuffer = [];\n    for (let i = baseLength - 1; i >= index; i -= 1) {\n      const currentSlide = swiper.slides[i];\n      currentSlide.remove();\n      slidesBuffer.unshift(currentSlide);\n    }\n    if (typeof slides === 'object' && 'length' in slides) {\n      for (let i = 0; i < slides.length; i += 1) {\n        if (slides[i]) slidesEl.append(slides[i]);\n      }\n      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;\n    } else {\n      slidesEl.append(slides);\n    }\n    for (let i = 0; i < slidesBuffer.length; i += 1) {\n      slidesEl.append(slidesBuffer[i]);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n    if (params.loop) {\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n    } else {\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n  }\n\n  function removeSlide(slidesIndexes) {\n    const swiper = this;\n    const {\n      params,\n      activeIndex\n    } = swiper;\n    let activeIndexBuffer = activeIndex;\n    if (params.loop) {\n      activeIndexBuffer -= swiper.loopedSlides;\n      swiper.loopDestroy();\n    }\n    let newActiveIndex = activeIndexBuffer;\n    let indexToRemove;\n    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {\n      for (let i = 0; i < slidesIndexes.length; i += 1) {\n        indexToRemove = slidesIndexes[i];\n        if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n      }\n      newActiveIndex = Math.max(newActiveIndex, 0);\n    } else {\n      indexToRemove = slidesIndexes;\n      if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();\n      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;\n      newActiveIndex = Math.max(newActiveIndex, 0);\n    }\n    swiper.recalcSlides();\n    if (params.loop) {\n      swiper.loopCreate();\n    }\n    if (!params.observer || swiper.isElement) {\n      swiper.update();\n    }\n    if (params.loop) {\n      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);\n    } else {\n      swiper.slideTo(newActiveIndex, 0, false);\n    }\n  }\n\n  function removeAllSlides() {\n    const swiper = this;\n    const slidesIndexes = [];\n    for (let i = 0; i < swiper.slides.length; i += 1) {\n      slidesIndexes.push(i);\n    }\n    swiper.removeSlide(slidesIndexes);\n  }\n\n  function Manipulation(_ref) {\n    let {\n      swiper\n    } = _ref;\n    Object.assign(swiper, {\n      appendSlide: appendSlide.bind(swiper),\n      prependSlide: prependSlide.bind(swiper),\n      addSlide: addSlide.bind(swiper),\n      removeSlide: removeSlide.bind(swiper),\n      removeAllSlides: removeAllSlides.bind(swiper)\n    });\n  }\n\n  function effectInit(params) {\n    const {\n      effect,\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      overwriteParams,\n      perspective,\n      recreateShadows,\n      getEffectParams\n    } = params;\n    on('beforeInit', () => {\n      if (swiper.params.effect !== effect) return;\n      swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n      if (perspective && perspective()) {\n        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n      }\n      const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n      Object.assign(swiper.params, overwriteParamsResult);\n      Object.assign(swiper.originalParams, overwriteParamsResult);\n    });\n    on('setTranslate', () => {\n      if (swiper.params.effect !== effect) return;\n      setTranslate();\n    });\n    on('setTransition', (_s, duration) => {\n      if (swiper.params.effect !== effect) return;\n      setTransition(duration);\n    });\n    on('transitionEnd', () => {\n      if (swiper.params.effect !== effect) return;\n      if (recreateShadows) {\n        if (!getEffectParams || !getEffectParams().slideShadows) return;\n        // remove shadows\n        swiper.slides.forEach(slideEl => {\n          slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => shadowEl.remove());\n        });\n        // create new one\n        recreateShadows();\n      }\n    });\n    let requireUpdateOnVirtual;\n    on('virtualUpdate', () => {\n      if (swiper.params.effect !== effect) return;\n      if (!swiper.slides.length) {\n        requireUpdateOnVirtual = true;\n      }\n      requestAnimationFrame(() => {\n        if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n          setTranslate();\n          requireUpdateOnVirtual = false;\n        }\n      });\n    });\n  }\n\n  function effectTarget(effectParams, slideEl) {\n    const transformEl = getSlideTransformEl(slideEl);\n    if (transformEl !== slideEl) {\n      transformEl.style.backfaceVisibility = 'hidden';\n      transformEl.style['-webkit-backface-visibility'] = 'hidden';\n    }\n    return transformEl;\n  }\n\n  function effectVirtualTransitionEnd(_ref) {\n    let {\n      swiper,\n      duration,\n      transformElements,\n      allSlides\n    } = _ref;\n    const {\n      activeIndex\n    } = swiper;\n    const getSlide = el => {\n      if (!el.parentElement) {\n        // assume shadow root\n        const slide = swiper.slides.filter(slideEl => slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];\n        return slide;\n      }\n      return el.parentElement;\n    };\n    if (swiper.params.virtualTranslate && duration !== 0) {\n      let eventTriggered = false;\n      let transitionEndTarget;\n      if (allSlides) {\n        transitionEndTarget = transformElements;\n      } else {\n        transitionEndTarget = transformElements.filter(transformEl => {\n          const el = transformEl.classList.contains('swiper-slide-transform') ? getSlide(transformEl) : transformEl;\n          return swiper.getSlideIndex(el) === activeIndex;\n        });\n      }\n      transitionEndTarget.forEach(el => {\n        elementTransitionEnd(el, () => {\n          if (eventTriggered) return;\n          if (!swiper || swiper.destroyed) return;\n          eventTriggered = true;\n          swiper.animating = false;\n          const evt = new window.CustomEvent('transitionend', {\n            bubbles: true,\n            cancelable: true\n          });\n          swiper.wrapperEl.dispatchEvent(evt);\n        });\n      });\n    }\n  }\n\n  function EffectFade(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      fadeEffect: {\n        crossFade: false\n      }\n    });\n    const setTranslate = () => {\n      const {\n        slides\n      } = swiper;\n      const params = swiper.params.fadeEffect;\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = swiper.slides[i];\n        const offset = slideEl.swiperSlideOffset;\n        let tx = -offset;\n        if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n        let ty = 0;\n        if (!swiper.isHorizontal()) {\n          ty = tx;\n          tx = 0;\n        }\n        const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.opacity = slideOpacity;\n        targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements,\n        allSlides: true\n      });\n    };\n    effectInit({\n      effect: 'fade',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  function EffectCube(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      cubeEffect: {\n        slideShadows: true,\n        shadow: true,\n        shadowOffset: 20,\n        shadowScale: 0.94\n      }\n    });\n    const createSlideShadows = (slideEl, progress, isHorizontal) => {\n      let shadowBefore = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n      let shadowAfter = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n      if (!shadowBefore) {\n        shadowBefore = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}`.split(' '));\n        slideEl.append(shadowBefore);\n      }\n      if (!shadowAfter) {\n        shadowAfter = createElement('div', `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}`.split(' '));\n        slideEl.append(shadowAfter);\n      }\n      if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n      if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n    };\n    const recreateShadows = () => {\n      // create new ones\n      const isHorizontal = swiper.isHorizontal();\n      swiper.slides.forEach(slideEl => {\n        const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        createSlideShadows(slideEl, progress, isHorizontal);\n      });\n    };\n    const setTranslate = () => {\n      const {\n        el,\n        wrapperEl,\n        slides,\n        width: swiperWidth,\n        height: swiperHeight,\n        rtlTranslate: rtl,\n        size: swiperSize,\n        browser\n      } = swiper;\n      const params = swiper.params.cubeEffect;\n      const isHorizontal = swiper.isHorizontal();\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      let wrapperRotate = 0;\n      let cubeShadowEl;\n      if (params.shadow) {\n        if (isHorizontal) {\n          cubeShadowEl = swiper.wrapperEl.querySelector('.swiper-cube-shadow');\n          if (!cubeShadowEl) {\n            cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n            swiper.wrapperEl.append(cubeShadowEl);\n          }\n          cubeShadowEl.style.height = `${swiperWidth}px`;\n        } else {\n          cubeShadowEl = el.querySelector('.swiper-cube-shadow');\n          if (!cubeShadowEl) {\n            cubeShadowEl = createElement('div', 'swiper-cube-shadow');\n            el.append(cubeShadowEl);\n          }\n        }\n      }\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        let slideIndex = i;\n        if (isVirtual) {\n          slideIndex = parseInt(slideEl.getAttribute('data-swiper-slide-index'), 10);\n        }\n        let slideAngle = slideIndex * 90;\n        let round = Math.floor(slideAngle / 360);\n        if (rtl) {\n          slideAngle = -slideAngle;\n          round = Math.floor(-slideAngle / 360);\n        }\n        const progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        let tx = 0;\n        let ty = 0;\n        let tz = 0;\n        if (slideIndex % 4 === 0) {\n          tx = -round * 4 * swiperSize;\n          tz = 0;\n        } else if ((slideIndex - 1) % 4 === 0) {\n          tx = 0;\n          tz = -round * 4 * swiperSize;\n        } else if ((slideIndex - 2) % 4 === 0) {\n          tx = swiperSize + round * 4 * swiperSize;\n          tz = swiperSize;\n        } else if ((slideIndex - 3) % 4 === 0) {\n          tx = -swiperSize;\n          tz = 3 * swiperSize + swiperSize * 4 * round;\n        }\n        if (rtl) {\n          tx = -tx;\n        }\n        if (!isHorizontal) {\n          ty = tx;\n          tx = 0;\n        }\n        const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;\n        if (progress <= 1 && progress > -1) {\n          wrapperRotate = slideIndex * 90 + progress * 90;\n          if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;\n        }\n        slideEl.style.transform = transform;\n        if (params.slideShadows) {\n          createSlideShadows(slideEl, progress, isHorizontal);\n        }\n      }\n      wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;\n      wrapperEl.style['-webkit-transform-origin'] = `50% 50% -${swiperSize / 2}px`;\n      if (params.shadow) {\n        if (isHorizontal) {\n          cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;\n        } else {\n          const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;\n          const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);\n          const scale1 = params.shadowScale;\n          const scale2 = params.shadowScale / multiplier;\n          const offset = params.shadowOffset;\n          cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;\n        }\n      }\n      const zFactor = (browser.isSafari || browser.isWebView) && browser.needPerspectiveFix ? -swiperSize / 2 : 0;\n      wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;\n      wrapperEl.style.setProperty('--swiper-cube-translate-z', `${zFactor}px`);\n    };\n    const setTransition = duration => {\n      const {\n        el,\n        slides\n      } = swiper;\n      slides.forEach(slideEl => {\n        slideEl.style.transitionDuration = `${duration}ms`;\n        slideEl.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(subEl => {\n          subEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {\n        const shadowEl = el.querySelector('.swiper-cube-shadow');\n        if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;\n      }\n    };\n    effectInit({\n      effect: 'cube',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      recreateShadows,\n      getEffectParams: () => swiper.params.cubeEffect,\n      perspective: () => true,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        resistanceRatio: 0,\n        spaceBetween: 0,\n        centeredSlides: false,\n        virtualTranslate: true\n      })\n    });\n  }\n\n  function createShadow(suffix, slideEl, side) {\n    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ''}${suffix ? ` swiper-slide-shadow-${suffix}` : ''}`;\n    const shadowContainer = getSlideTransformEl(slideEl);\n    let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(' ').join('.')}`);\n    if (!shadowEl) {\n      shadowEl = createElement('div', shadowClass.split(' '));\n      shadowContainer.append(shadowEl);\n    }\n    return shadowEl;\n  }\n\n  function EffectFlip(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      flipEffect: {\n        slideShadows: true,\n        limitRotation: true\n      }\n    });\n    const createSlideShadows = (slideEl, progress) => {\n      let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n      let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n      if (!shadowBefore) {\n        shadowBefore = createShadow('flip', slideEl, swiper.isHorizontal() ? 'left' : 'top');\n      }\n      if (!shadowAfter) {\n        shadowAfter = createShadow('flip', slideEl, swiper.isHorizontal() ? 'right' : 'bottom');\n      }\n      if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);\n      if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);\n    };\n    const recreateShadows = () => {\n      // Set shadows\n      swiper.params.flipEffect;\n      swiper.slides.forEach(slideEl => {\n        let progress = slideEl.progress;\n        if (swiper.params.flipEffect.limitRotation) {\n          progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        }\n        createSlideShadows(slideEl, progress);\n      });\n    };\n    const setTranslate = () => {\n      const {\n        slides,\n        rtlTranslate: rtl\n      } = swiper;\n      const params = swiper.params.flipEffect;\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        let progress = slideEl.progress;\n        if (swiper.params.flipEffect.limitRotation) {\n          progress = Math.max(Math.min(slideEl.progress, 1), -1);\n        }\n        const offset = slideEl.swiperSlideOffset;\n        const rotate = -180 * progress;\n        let rotateY = rotate;\n        let rotateX = 0;\n        let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n        let ty = 0;\n        if (!swiper.isHorizontal()) {\n          ty = tx;\n          tx = 0;\n          rotateX = -rotateY;\n          rotateY = 0;\n        } else if (rtl) {\n          rotateY = -rotateY;\n        }\n        slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;\n        if (params.slideShadows) {\n          createSlideShadows(slideEl, progress);\n        }\n        const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = transform;\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements\n      });\n    };\n    effectInit({\n      effect: 'flip',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      recreateShadows,\n      getEffectParams: () => swiper.params.flipEffect,\n      perspective: () => true,\n      overwriteParams: () => ({\n        slidesPerView: 1,\n        slidesPerGroup: 1,\n        watchSlidesProgress: true,\n        spaceBetween: 0,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  function EffectCoverflow(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      coverflowEffect: {\n        rotate: 50,\n        stretch: 0,\n        depth: 100,\n        scale: 1,\n        modifier: 1,\n        slideShadows: true\n      }\n    });\n    const setTranslate = () => {\n      const {\n        width: swiperWidth,\n        height: swiperHeight,\n        slides,\n        slidesSizesGrid\n      } = swiper;\n      const params = swiper.params.coverflowEffect;\n      const isHorizontal = swiper.isHorizontal();\n      const transform = swiper.translate;\n      const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;\n      const rotate = isHorizontal ? params.rotate : -params.rotate;\n      const translate = params.depth;\n      // Each slide offset from center\n      for (let i = 0, length = slides.length; i < length; i += 1) {\n        const slideEl = slides[i];\n        const slideSize = slidesSizesGrid[i];\n        const slideOffset = slideEl.swiperSlideOffset;\n        const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;\n        const offsetMultiplier = typeof params.modifier === 'function' ? params.modifier(centerOffset) : centerOffset * params.modifier;\n        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;\n        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;\n        // var rotateZ = 0\n        let translateZ = -translate * Math.abs(offsetMultiplier);\n        let stretch = params.stretch;\n        // Allow percentage to make a relative stretch for responsive sliders\n        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {\n          stretch = parseFloat(params.stretch) / 100 * slideSize;\n        }\n        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;\n        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;\n        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);\n\n        // Fix for ultra small values\n        if (Math.abs(translateX) < 0.001) translateX = 0;\n        if (Math.abs(translateY) < 0.001) translateY = 0;\n        if (Math.abs(translateZ) < 0.001) translateZ = 0;\n        if (Math.abs(rotateY) < 0.001) rotateY = 0;\n        if (Math.abs(rotateX) < 0.001) rotateX = 0;\n        if (Math.abs(scale) < 0.001) scale = 0;\n        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = slideTransform;\n        slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;\n        if (params.slideShadows) {\n          // Set shadows\n          let shadowBeforeEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-left') : slideEl.querySelector('.swiper-slide-shadow-top');\n          let shadowAfterEl = isHorizontal ? slideEl.querySelector('.swiper-slide-shadow-right') : slideEl.querySelector('.swiper-slide-shadow-bottom');\n          if (!shadowBeforeEl) {\n            shadowBeforeEl = createShadow('coverflow', slideEl, isHorizontal ? 'left' : 'top');\n          }\n          if (!shadowAfterEl) {\n            shadowAfterEl = createShadow('coverflow', slideEl, isHorizontal ? 'right' : 'bottom');\n          }\n          if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;\n          if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;\n        }\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n    };\n    effectInit({\n      effect: 'coverflow',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => true,\n      overwriteParams: () => ({\n        watchSlidesProgress: true\n      })\n    });\n  }\n\n  function EffectCreative(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      creativeEffect: {\n        limitProgress: 1,\n        shadowPerProgress: false,\n        progressMultiplier: 1,\n        perspective: true,\n        prev: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1\n        },\n        next: {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          opacity: 1,\n          scale: 1\n        }\n      }\n    });\n    const getTranslateValue = value => {\n      if (typeof value === 'string') return value;\n      return `${value}px`;\n    };\n    const setTranslate = () => {\n      const {\n        slides,\n        wrapperEl,\n        slidesSizesGrid\n      } = swiper;\n      const params = swiper.params.creativeEffect;\n      const {\n        progressMultiplier: multiplier\n      } = params;\n      const isCenteredSlides = swiper.params.centeredSlides;\n      if (isCenteredSlides) {\n        const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;\n        wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;\n      }\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        const slideProgress = slideEl.progress;\n        const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);\n        let originalProgress = progress;\n        if (!isCenteredSlides) {\n          originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);\n        }\n        const offset = slideEl.swiperSlideOffset;\n        const t = [swiper.params.cssMode ? -offset - swiper.translate : -offset, 0, 0];\n        const r = [0, 0, 0];\n        let custom = false;\n        if (!swiper.isHorizontal()) {\n          t[1] = t[0];\n          t[0] = 0;\n        }\n        let data = {\n          translate: [0, 0, 0],\n          rotate: [0, 0, 0],\n          scale: 1,\n          opacity: 1\n        };\n        if (progress < 0) {\n          data = params.next;\n          custom = true;\n        } else if (progress > 0) {\n          data = params.prev;\n          custom = true;\n        }\n        // set translate\n        t.forEach((value, index) => {\n          t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;\n        });\n        // set rotates\n        r.forEach((value, index) => {\n          r[index] = data.rotate[index] * Math.abs(progress * multiplier);\n        });\n        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n        const translateString = t.join(', ');\n        const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;\n        const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;\n        const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;\n        const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;\n\n        // Set shadows\n        if (custom && data.shadow || !custom) {\n          let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n          if (!shadowEl && data.shadow) {\n            shadowEl = createShadow('creative', slideEl);\n          }\n          if (shadowEl) {\n            const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;\n            shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);\n          }\n        }\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = transform;\n        targetEl.style.opacity = opacityString;\n        if (data.origin) {\n          targetEl.style.transformOrigin = data.origin;\n        }\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements,\n        allSlides: true\n      });\n    };\n    effectInit({\n      effect: 'creative',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => swiper.params.creativeEffect.perspective,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  function EffectCards(_ref) {\n    let {\n      swiper,\n      extendParams,\n      on\n    } = _ref;\n    extendParams({\n      cardsEffect: {\n        slideShadows: true,\n        rotate: true,\n        perSlideRotate: 2,\n        perSlideOffset: 8\n      }\n    });\n    const setTranslate = () => {\n      const {\n        slides,\n        activeIndex,\n        rtlTranslate: rtl\n      } = swiper;\n      const params = swiper.params.cardsEffect;\n      const {\n        startTranslate,\n        isTouched\n      } = swiper.touchEventsData;\n      const currentTranslate = rtl ? -swiper.translate : swiper.translate;\n      for (let i = 0; i < slides.length; i += 1) {\n        const slideEl = slides[i];\n        const slideProgress = slideEl.progress;\n        const progress = Math.min(Math.max(slideProgress, -4), 4);\n        let offset = slideEl.swiperSlideOffset;\n        if (swiper.params.centeredSlides && !swiper.params.cssMode) {\n          swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;\n        }\n        if (swiper.params.centeredSlides && swiper.params.cssMode) {\n          offset -= slides[0].swiperSlideOffset;\n        }\n        let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;\n        let tY = 0;\n        const tZ = -100 * Math.abs(progress);\n        let scale = 1;\n        let rotate = -params.perSlideRotate * progress;\n        let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;\n        const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i : i;\n        const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;\n        const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;\n        if (isSwipeToNext || isSwipeToPrev) {\n          const subProgress = (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;\n          rotate += -28 * progress * subProgress;\n          scale += -0.5 * subProgress;\n          tXAdd += 96 * subProgress;\n          tY = `${-25 * subProgress * Math.abs(progress)}%`;\n        }\n        if (progress < 0) {\n          // next\n          tX = `calc(${tX}px ${rtl ? '-' : '+'} (${tXAdd * Math.abs(progress)}%))`;\n        } else if (progress > 0) {\n          // prev\n          tX = `calc(${tX}px ${rtl ? '-' : '+'} (-${tXAdd * Math.abs(progress)}%))`;\n        } else {\n          tX = `${tX}px`;\n        }\n        if (!swiper.isHorizontal()) {\n          const prevY = tY;\n          tY = tX;\n          tX = prevY;\n        }\n        const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;\n\n        /* eslint-disable */\n        const transform = `\n        translate3d(${tX}, ${tY}, ${tZ}px)\n        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)\n        scale(${scaleString})\n      `;\n        /* eslint-enable */\n\n        if (params.slideShadows) {\n          // Set shadows\n          let shadowEl = slideEl.querySelector('.swiper-slide-shadow');\n          if (!shadowEl) {\n            shadowEl = createShadow('cards', slideEl);\n          }\n          if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);\n        }\n        slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;\n        const targetEl = effectTarget(params, slideEl);\n        targetEl.style.transform = transform;\n      }\n    };\n    const setTransition = duration => {\n      const transformElements = swiper.slides.map(slideEl => getSlideTransformEl(slideEl));\n      transformElements.forEach(el => {\n        el.style.transitionDuration = `${duration}ms`;\n        el.querySelectorAll('.swiper-slide-shadow').forEach(shadowEl => {\n          shadowEl.style.transitionDuration = `${duration}ms`;\n        });\n      });\n      effectVirtualTransitionEnd({\n        swiper,\n        duration,\n        transformElements\n      });\n    };\n    effectInit({\n      effect: 'cards',\n      swiper,\n      on,\n      setTranslate,\n      setTransition,\n      perspective: () => true,\n      overwriteParams: () => ({\n        watchSlidesProgress: true,\n        virtualTranslate: !swiper.params.cssMode\n      })\n    });\n  }\n\n  /**\n   * Swiper 10.0.4\n   * Most modern mobile touch slider and framework with hardware accelerated transitions\n   * https://swiperjs.com\n   *\n   * Copyright 2014-2023 Vladimir Kharlampidi\n   *\n   * Released under the MIT License\n   *\n   * Released on: July 8, 2023\n   */\n\n\n  // Swiper Class\n  const modules = [Virtual, Keyboard, Mousewheel, Navigation, Pagination, Scrollbar, Parallax, Zoom, Controller, A11y, History, HashNavigation, Autoplay, Thumb, freeMode, Grid, Manipulation, EffectFade, EffectCube, EffectFlip, EffectCoverflow, EffectCreative, EffectCards];\n  Swiper.use(modules);\n\n  return Swiper;\n\n})();\n"]}